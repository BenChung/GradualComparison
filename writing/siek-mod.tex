\documentclass{report}
\usepackage{mathpartir,amsmath,amssymb,xspace,listings}


\input{common}

\newcommand{\spec}{\vartriangleright}
\begin{document}

Syntax:

\syntax

\begin{mathpar}
\inferrule*[right=TCons]{ \tau \sim \tau' \\ \G \vdash e : \t }{\G \vdash e : \t'}

\TVar 

\TStr

\TInt

\TUApp

\TApp

\TIf

\TPlus

\TNew

\TCast

\inferrule*[right=TClass]{ 
  \bar{\G \vdash \f : \t}\\
  \bar{\G \vdash \MTYPE{\m}{\bar{x:\t''}}{\t'} = e} \\ 
  \f:\t \in \xt{D} \implies \f:\t' \in \C \wedge \t' \sqsubseteq \t\\
  \MTYPE{\m}{\bar{x:\t_D''}}{\t_D'}\in \xt{D} \implies \MTYPE{\m}{\bar{x:\t_C''}}{\t_C'} \in \C \wedge \t_C' \sqsubseteq \t_D' \wedge \bar{\t_C'' \sqsubseteq \t_D''}\\
 }{
  \Gdash \CLASS \C{\xt{D}}{\bar{\f:\t},\bar{\MDEF\m{\bar{x:\t''}}{\t'}e}}
  }
\end{mathpar}

\subsection{Class well-formedness}

\begin{mathpar}
\inferrule*[right=WFField]{\G \vdash \t}{\G\vdash\f:\t}

\inferrule*[right=WFMeth]{\G \vdash \t \\ \bar{\G \vdash \t'} \\ \G,\this:this(\G),\bar{x:\t'} \vdash e : \t}{\G \vdash \m(\bar{x:\t'}):\t = e}

\inferrule*[right=WFSelfGet]{f:\t \in fields(\G)}{\G \vdash f():\t = \xt{this}.f}

\inferrule*[right=WFDelGet]{f:\t \not\in fields(\G) \\ \G \vdash e : \t}{\G \vdash f():\t = e}

\inferrule*[right=WFSelfSet]{f:\t \in fields(\G)}{\G \vdash f!(\xt{x}:\t):\t = (\xt{this}.f=\xt{x})}

\inferrule*[right=WFDelSet]{f:\t \not\in fields(\G) \\ \G,\xt{x}:\t \vdash e : \t}{\G \vdash f!(\xt{x}:\t):\t = e}
\end{mathpar}

\subsection{Cast Insertion}

\begin{mathpar}
\inferrule*[right=CICons]{
  \Gdash e \tlate e' : \t \\
  \t \sim \t'\\
}{
  \Gdash e \tlate e' : \t'
}

\CICast

\CICall

\CICallAny

\CIIf

\CIPlus

\CIVar

\CINew

\end{mathpar}


\section{Dynamic semantics:}



Reduction:

\begin{mathpar}
\EFrame

\ENew

\EInv

\EField

\EAssign

\EIfZ

\EIfNZ

\EPlus

\inferrule*[right=ECast]{ \s' = \text{cast}(\s, v, \t) }{ \cast{\t}a,\s \ereduce a,\s'}

\end{mathpar}

\subsection{Casting}

\begin{mathpar}
\inferrule*[right=CClass]{\s[a \is \{\bar{\f = v} \B \C\}] \\ \C \neq \C \sqcap \xt{D} \\ \s' = \s[a \is \{\bar{\f = v} \B \C \sqcap \xt{D}\}]\\
\f:\t \in \C \sqcap \xt{D} \\ \bar{\sigma'' = \text{cast}(\s', v, \t)}}{\text{cast}(\s, a, \xt{D}) = \s''}

\inferrule*[right=CCycle]{\s[a \is \{\bar{\f = v} \B \C\}] \\ \C = \C \sqcap \xt{D}}{\text{cast}(\s, a, \xt{D}) = \s}

\inferrule*[right=CInt]{ }{\text{cast}(\s,\xt{int}[n],\xt{\int}) = \s}

\inferrule*[right=CStr]{ }{\text{cast}(\s,\xt{str}[n],\xt{\str}) = \s}
\end{mathpar}
\subsection{Meet}
\begin{mathpar}
\inferrule*[]{}{\t \spec \t = \t}

\inferrule*[]{}{\t \spec \any = \t}

\inferrule*[]{}{\any \spec \t = \t}

\inferrule*[]{}{A \spec B = A \Rightarrow B}
\end{mathpar}

\begin{lstlisting}
classMeet(A,B)
  A = class A {(*@\bar{\f_A:\t_A},\bar{m(\bar{x:\t''_A}):\t'_A = e_A}@*)}
  B = class B {(*@\bar{\f_B:\t_B},\bar{m(\bar{x:\t''_B}):\t'_B = e_B}@*)}
  return class A(*@$\Rightarrow$@*)B {
    (*@\bar{\f:\t_A\spec\t_B}@*),
    (*@\bar{m(\bar{x:\t''_A\spec\t''_B}):\t'_A\spec\t'_B = \cast{\t'_A\spec\t'_B}\this.m'(\bar{\cast{\t''_A\spec\t''_B}x})}@*),
    (*@\bar{m'(\bar{x:\t''_A}):\t'_A = e_A}@*)
  }
\end{lstlisting}

classMeet is applied to every string of classes, in left-to-right order
\end{document}
