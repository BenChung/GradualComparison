\documentclass{report}
\usepackage{mathpartir,amsmath,amssymb,xspace}
\newcommand{\intt}{\texttt{int}}

\newcommand{\any}{\anyt}
\newcommand{\coerce}{\Rightarrow}

\newcommand{\strt}{\texttt{str}}
\newcommand{\anyt}{\texttt{any}}
\newcommand{\this}{\texttt{this}}
\newcommand{\ifthenelse}[3]{\texttt{if }#1\texttt{ then }#2\texttt{ else }#3}
\newcommand{\cast}[1]{\langle #1\rangle}
\newcommand{\xt}[1]{\texttt{#1}}
\newcommand{\castreduce}{\longrightarrow_{cr}}
\newcommand{\expreduce}{\longrightarrow_{e}}
\newcommand{\stepsto}{\longrightarrow}
\newcommand{\intv}[1]{\xt{int}[#1]}
\newcommand{\strv}[1]{\xt{str}[#1]}
\newcommand{\tlate}{\rightsquigarrow}
\begin{document}

\newcommand{\s}{\sigma}
\renewcommand{\sc}{\mu}
\renewcommand{\t}{\tau}
\newcommand{\B}{\ensuremath{~|~}\xspace}
\newcommand{\new}{\ensuremath{\texttt{new}}\xspace}
\newcommand{\NEW}[2]{\ensuremath{  \new ~ #1 ( #2 )}\xspace}
\renewcommand{\bar}[1]{\ensuremath{\overline{ #1} }\xspace}

\newcommand{\m}{\ensuremath{\xt{m}}\xspace}
\newcommand{\f}{\ensuremath{\xt{f}}\xspace}
\newcommand{\C}{\ensuremath{\xt{C}}\xspace}
\newcommand{\D}{\ensuremath{\xt{D}}\xspace}

%% TOODO if0 => if   ??

%% Cast syntax??

%% TODO \bar p ==> \bar x

\newcommand{\cl}{\mathit{cl}\xspace}
\newcommand{\implements}{\xt{implements}\xspace}

\newcommand{\CLASS}[3]{ \ensuremath{  \xt{class}~#1~\implements~#2\;\{ #3 \}}\xspace} 
\newcommand{\MDEF}[4] { #1( #2 ):#3 = #4}
\newcommand{\MVAL}[3] { #1( #2 ) = #3}

Syntax:
\begin{align*}
\t &::= \anyt \B  \strt \B  \intt \B  \{\bar{\f :\t},\bar{\m (\bar{\t}):\t}\}\\
e &::= k \B  e.\m(\bar{e}) \B e.\f  \B e.\f  = e \B  \ifthenelse{e}{e}{e}\B e + e \\
&\B x\B \NEW \C {\bar{e}} \B  e\cast{\t}\\
\cl &::= \CLASS \C {\bar \D} { \bar{ \f : \t }, ~ \bar{ \MDEF{\m}{\bar{x :\t}}{\t'}{e} } } \\
v &::= k \B  \{\bar{\texttt{f}=v},\bar{\m (\bar x)=e}\} \B  v\cast{I \coerce \any}\\
I &::= \strt \B  \intt \B  \{\bar{\f :I},\bar{\m (\bar{I}):I}\}\\
cv &::= v \B  v\cast{\t \coerce \t} \B  \{\bar{\f=cv},\bar{ \MVAL\m{\bar x}e }\}\\
\s &::= \emptyset \B  \s( a \mapsto v )\\
\sc &::= \emptyset \B  \sc( a \mapsto cv )\\
F &::=    \square.\m(\bar e) 
   \B 	  \square.\f 
   \B 	  \square.\f  = e
   \B     v.\f  = \square
   \B     v.\m(\bar v,\square, \bar e) 
   \B     \ifthenelse{\square}{e}{e} 
   \B     \square + e 
   \B      v + \square\\
&\B \NEW  \C {\bar{v},\square,\bar{e}}\\
\mathit{CF} &::= \{\f=v\ldots,\f'=\square,\f''=cv,\ldots\}\\
\end{align*}

\begin{mathpar}
\inferrule*[right=SubRefl]{ }{ \t <: \t }

\inferrule*[right=SubClass]{\texttt{class }\C\texttt{ extends }\xt{C}}{ \C <: \xt{D} }

\inferrule*[right=SubAny]{ }{\t <: \anyt}
\end{mathpar}

\begin{mathpar}
\inferrule*[right=TVar]{\Gamma(x) = A }{\Gamma \vdash x : A}

\inferrule*[right=TStr]{ }{\Gamma \vdash string : \strt}

\inferrule*[right=TInt]{ }{\Gamma \vdash int : \intt}

\inferrule*[right=TSub]{\Gamma \vdash e : \t' \\ \t' <: \t}{\Gamma \vdash e : \t}

\inferrule*[right=TApp]{\bar{\Gamma \vdash e_i : \t_i \vee \Gamma \vdash e_i : \anyt} \\ \Gamma \vdash e : \{\ldots, \m(\bar{\t'_i}):\t', \ldots\}}{\Gamma \vdash e.\m(\bar{e_i}) : \t'}

\inferrule*[right=TIf]{ 
\Gamma \vdash e_1 : \intt \vee \Gamma \vdash e_1 :\anyt \\ \Gamma \vdash \t \\ \Gamma \vdash e_2 : \t \\ \Gamma \vdash e_3 : \t} { \Gamma \vdash \ifthenelse{e_1}{e_2}{e_3} : \t}

\inferrule*[right=TPlus]{ \Gamma \vdash e_1 : \intt \\ \Gamma \vdash e_2 : \intt} { \Gamma \vdash e_1 + e_2 : \intt}

\inferrule*[right=TField]{ \Gamma \vdash e : \{\ldots \f:\t \ldots\}} { \Gamma \vdash e.\f : \t}

\inferrule*[right=TNew]{\bar{\Gamma \vdash e : \t \vee \Gamma \vdash e : \anyt} \\ \Gamma(C) = \{\ldots, \bar{\f  : \t}, \ldots\}}{\Gamma \vdash \NEW{\xt{C}}{\bar{e}} : C}

\inferrule*[right=TCast]{\Gamma \vdash e : \t'}{\Gamma \vdash e\cast{\t}}

\inferrule*[right=TClass]{ 
\bar{\Gamma \vdash D} \\  
\bar{\m '(\bar{\xt{x}:\t''}):\t' \in D \implies \m '(\bar{\xt{x}:\t''}):\t' \in C }\\
\bar{\f :\t \in D \implies \f :\t \in C}\\
\bar{\Gamma,\xt{this}:C,\bar{\xt{x}:\t''} \vdash e : \t'}\\
}{\Gamma \vdash \texttt{class } C \texttt{ implements } \bar{D}\;\{\bar{\f  : \t}, \bar{\m (\bar{\xt{x}:\t''}):\t' = \{ e \}}\}}
\end{mathpar}

\subsection{Cast Insertion}

\begin{mathpar}
\inferrule*[]{\Gamma \vdash e \tlate e' : \t' \\ \t' \sim \t}{\Gamma \vdash e\cast{\t} \tlate e'\cast{\t' \Rightarrow \t} : \t}

\inferrule*[]{\Gamma \vdash e \tlate e' : \{\ldots, \m(\bar{\t}):\t', \ldots\} \\ \bar{\Gamma \vdash e_a \tlate e_a' : \t_a} \\ \bar{\t \sim \t_a} \\ \bar{(\t_a \Rightarrow{\t}) = c}}{\Gamma \vdash e.\m(\bar{e_a}) \tlate e.\m(\bar{e_a'\cast{c}}) : \t'}

\inferrule*[]{ \Gamma \vdash e \tlate e' : \anyt \\  \bar{\Gamma \vdash e_a \tlate e_a' : \t_a} \\ \anyt \Rightarrow \{\m(\bar{\t_a}):\anyt\} = c}{\Gamma \vdash e.\m(\bar{e_a}) \tlate e'\cast{c}.\m(\bar{e_a'}) : \anyt }

\inferrule*[]{\Gamma \vdash e_1 \tlate e_1' : \t_1 \\ \t_1 \sim \intt \\ \Gamma \vdash e_2\tlate e_2':\t_2 \\ \Gamma \vdash e_3 \tlate e_3' : \t_2}{\Gamma \vdash \ifthenelse{e_1}{e_2}{e_3} \tlate \ifthenelse{e_1'\cast{\t_1 \Rightarrow \intt}}{e_2'}{e_3'} : \t_2} 

\inferrule*[]{\Gamma \vdash e_1 \tlate e_1' : \t_1 \\ \Gamma \vdash e_2 \tlate e_2' : \t_2 \\ \t_1 \sim \intt \\ \t_2 \sim \intt }{\Gamma \vdash e_1 + e_2 \tlate e_1'\cast{\t_1 \Rightarrow \intt} + e_2' \cast{\t_2 \Rightarrow \intt}:\intt }

\inferrule*[]{x:\t \in \Gamma}{\Gamma \vdash x \tlate x : \t}

\inferrule*[]{C=\{\bar{\f :\t},\ldots\} \in \Gamma \\ \bar{\Gamma \vdash e \tlate e' : \t'} \\ \bar{\t \sim \t'}}{\Gamma \vdash \xt{new } C(\bar{e}) \tlate \xt{new }C(\bar{e'\cast{\t' \Rightarrow \t}}) : C}
\end{mathpar}


\section{Dynamic semantics:}


\newcommand{\class}{\ensuremath{\xt{class}}\xspace}

Expression reduction:

\begin{mathpar}
\inferrule*[right=EFrame]{ e,v \expreduce e',v'}{F[e],v \expreduce F[e'],v'}

\inferrule*[right=ENew]{
     \class \; \C  \{\bar{\f : \t}, \bar{ \m (\bar{x:\t}) : \t' = e}\} \\
     \s'=\s(a\mapsto\{\bar{\f=v},\bar{ \m (\bar{x :\t}):\t' = e}\}) }{ \NEW \C {\bar v},\s \expreduce a,\s'}

\inferrule*[right=EInv]{a\mapsto \{\ldots,\m(\bar x)=e\}, \ldots]}{a.\m(\bar v),\s \expreduce [a/\xt{this}][\bar{v/x}]e,\s}

\inferrule*[right=EField]{ \s[a\mapsto\{\ldots,\f =v,\ldots\}] }{a.\f,\s \expreduce v,\s}

\inferrule*[right=EAssign]{ \s' = \s[a\mapsto \{\ldots,\f =v,\ldots\}] }{a.\f = v,\s \expreduce v,\s'}

\inferrule*[right=EIfZ]{ }{ \ifthenelse{\intv{0}}{e_1}{e_2},\s \expreduce e_1,\s }

\inferrule*[right=EIfNZ]{n\neq 0}{ \ifthenelse{\intv{n}}{e_1}{e_2},\s \expreduce e_2,\s }

\inferrule*[right=EPlus]{ n_1 + n_2 = n_3 }{ \intv{n_1} + \intv{n_2},\s \expreduce \intv{n_3},\s}
\end{mathpar}


\subsection{Cast reduction}

\begin{mathpar}
\inferrule*[right=CRF]{ e,\sc \castreduce e',\sc'}{F[e],\sc \castreduce F[e'],\sc'}

\inferrule*[right=CRCF]{ e,\sc\castreduce e',\sc' }{ CF[e],\sc \castreduce CF[e'],\sc'}

\inferrule*[right=CREmpty]{ } { v\cast{\t \coerce \t},\sc \castreduce v,\sc}
 
\inferrule*[right=CRChain]{ I \sim I' }{ v\cast{I \coerce \any}\cast{\any \coerce I'},\sc \castreduce v\cast{I \coerce I'},\sc}

\inferrule*[right=CRRef1]{
  \sc(a) = v : \t \\ 
  \t \sqcap \t' = \t''\\
  \t'' \neq \t\\
}{ a\cast{\t'},\sc \castreduce a,\sc(a\mapsto v \cast{\t \coerce \t''})}

\inferrule*[right=CRRef2]{
\s(a) = v : \t \\ \t \sqcap \t'
 = \t}{ a\cast{\t'},\sc \castreduce a,\sc}



\inferrule*[right=CRObj]{
       \t = \{ \bar{ \f : \t_1}, \bar{\m (\bar{ x:\t_1''}):\t_1'} \}\\
       \t' = \{ \bar{ \f : \t_2}, \bar{\m (\bar{ x:\t_2''}):\t_2'} \}\\
	v = \{\bar{\f=v'}, \bar{\m(\bar x) = e}\}\\
        v' =    \{\bar{\f= v'\cast{\t_1\coerce\t_2}}, 
     \bar{\m (\bar x) = \this.\m'(\bar{ x \cast{\t_2''\coerce\t_1''}}),
          \m'(\bar x) = e\cast{\t_1'\coerce \t_2'}}\}
}{
   v\cast{\t\coerce\t'},\sc \castreduce v',\sc
}
\end{mathpar}

State reduction:
\begin{mathpar}
\inferrule*[]{ e,\sc\castreduce e',\sc' }{ e,\sc \longrightarrow e',\sc'}

\inferrule*[]{ e,\s\expreduce e',\sc }{ e,\s \longrightarrow e',\sc}

 \inferrule*[]{
 	\sc(a) = cv : \t\\
 	cv,\sc \castreduce cv',\sc'\\
 	\sc'(a)_{rtti} = \t\\
 }{
 	e,\sc \longrightarrow e,\sc'(a \mapsto cv' : \t)
 }

 \inferrule*[]{
 	\sc(a) = cv : \t\\
 	cv,\sc \castreduce cv',\sc'\\
 	\sc'(a)_{rtti} \neq \t\\
 }{
 	e,\sc \longrightarrow e,\sc'
 }
\end{mathpar}

Cast to coersion compilation
\begin{mathpar}
\inferrule*[]{}{\intt \coerce \intt = \iota}

\inferrule*[]{}{\strt \coerce \strt = \iota}

\inferrule*[]{}{I \coerce \anyt = I!}

\inferrule*[]{}{\anyt \coerce I = I?}

\inferrule*[]{}{\{\bar{\f :\t_1}, \bar{\m (\bar{\xt{p}:\t_1''}):\t_1'} \} \coerce \{\bar{\f :\t_2}, \bar{\m (\bar{\xt{p}:\t_2''}):\t_2'} \} = \{\bar{\f :\t_1\coerce\t_2}, \bar{\m (\bar{\xt{p}:\t_2'' \coerce \t_1''}) : \t_1' \coerce \t_2'}\}}
\end{mathpar}

Meet
\begin{mathpar}
\inferrule*[]{}{\t \sqcap \t = \t}

\inferrule*[]{}{\t \sqcap \anyt = \t}

\inferrule*[]{}{\anyt \sqcap \t = \t}

\inferrule*[]{}{\{\bar{\f :\t_1}, \bar{\m (\bar{\xt{p}:\t_1''}):\t_1'} \}\sqcap \{\bar{\f :\t_2}, \bar{\m (\bar{\xt{p}:\t_2''}):\t_2'} \} = \{\bar{\f :\t_2 \sqcap \t_2}, \bar{\m (\bar{\xt{p}:\t_1'' \sqcap \t_2''}):\t_1' \sqcap \t_2'} \}}
\end{mathpar}
\end{document}
