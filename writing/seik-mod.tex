\documentclass{report}
\usepackage{mathpartir,amsmath,amssymb}
\newcommand{\intt}{\texttt{int}}
\newcommand{\strt}{\texttt{str}}
\newcommand{\anyt}{\texttt{any}}
\newcommand{\ifthenelse}[3]{\texttt{if0 }#1\texttt{ then }#2\texttt{ else }#3}
\newcommand{\cast}[1]{\langle #1\rangle}
\newcommand{\xt}[1]{\texttt{#1}}
\newcommand{\castreduce}{\longrightarrow_{cr}}
\newcommand{\expreduce}{\longrightarrow_{e}}
\newcommand{\stepsto}{\longrightarrow}
\newcommand{\intv}[1]{\xt{int}[#1]}
\newcommand{\strv}[1]{\xt{str}[#1]}
\newcommand{\cstctx}{\nu}
\begin{document}

Syntax:
\begin{align*}
\tau &::= \anyt | \strt | \intt | \{\overline{\xt{f}:\tau},\overline{\xt{m}(\overline{\tau}):\tau}\}\\
e &::= c | \;e.l(\overline{e}) \;| \ifthenelse{e}{e}{e}\;|\;e + e\\
&|\;x\;|\texttt{ new }C(\overline{e}) | e\cast{\tau}\\
v &::= i | s | \{\overline{\texttt{f}=v},\overline{\xt{m}(\overline{\xt{p}})=e}\} | v\cast{I!}\\
I &::= \strt | \intt | \{\overline{\xt{f}:I},\overline{\xt{m}(\overline{I}):I}\}\\
c &::= \iota | I? | I! | \{\overline{\xt{f}\cast{c}}, \overline{\xt{m}(\overline{c}):c}\}\\
cv &::= v | v\cast{c} | \{\overline{f=cv},\overline{\xt{m}(\overline{\xt{p}})=e}\}\\
\mu &::= \emptyset | \mu( a \mapsto v )\\
F &::= \square.l(\overline{e}) | v.l(\overline{v},\square,e,\overline{e}) | v!l(\overline{v},\square,e,\overline{e}) | \ifthenelse{\square}{e}{e} | \square + e | v + \square\\
&|\texttt{ new }C(\overline{v},\square,\overline{e})\\
CF &::= \{\texttt{x}=v\ldots,\texttt{y}=\square,\texttt{z}=e,\ldots,\texttt{f(a:}\tau\texttt{):}\tau'=e,\ldots\}\\
\end{align*}

\begin{mathpar}
\inferrule*[right=SubRefl]{ }{ C <: C }

\inferrule*[right=SubClass]{\texttt{class }C\texttt{ extends }D}{ C <: D }

\inferrule*[right=SubInt]{ }{ \intt <: \intt }

\inferrule*[right=SubStr]{ }{ \strt <: \strt }
\end{mathpar}

\begin{mathpar}
\inferrule*[right=TVar]{\Gamma(x) = A }{\Gamma \vdash x : A}

\inferrule*[right=TStr]{ }{\Gamma \vdash string : \strt}

\inferrule*[right=TInt]{ }{\Gamma \vdash int : \intt}

\inferrule*[right=TSub]{\Gamma \vdash e : \tau' \\ \tau' <: \tau}{\Gamma \vdash e : \tau}

\inferrule*[right=TApp]{\overline{\Gamma \vdash e_i : \tau_i \vee \Gamma \vdash e_i : \anyt} \\ \Gamma \vdash e : \{\ldots, l(\overline{\tau'_i}):\tau', \ldots\}}{\Gamma \vdash e.l(\overline{e_i}) : \tau'}

\inferrule*[right=TIf]{ 
\Gamma \vdash e_1 : \intt \vee \Gamma \vdash e_1 :\anyt \\ \Gamma \vdash \tau \\ \Gamma \vdash e_2 : \tau \\ \Gamma \vdash e_3 : \tau} { \Gamma \vdash \ifthenelse{e_1}{e_2}{e_3} : \tau}

\inferrule*[right=TPlus]{ \Gamma \vdash e_1 : \intt \\ \Gamma \vdash e_2 : \intt} { \Gamma \vdash e_1 + e_2 : \intt}

\inferrule*[right=TField]{ \Gamma \vdash e : \{\ldots l:\tau \ldots\}} { \Gamma \vdash e.l : \tau}

\inferrule*[right=TNew]{\overline{\Gamma \vdash e : \tau \vee \Gamma \vdash e : \anyt} \\ \Gamma(C) = \{\ldots, \overline{\xt{f} : \tau'}, \ldots\}}{\Gamma \vdash \texttt{new }C(\overline{e}) : C}

\inferrule*[right=TCast]{\Gamma \vdash e : \tau' \\ \tau <: \tau' \vee \tau' = \anyt}{\Gamma \vdash e\cast{\tau}}

\inferrule*[right=TClass]{ 
\overline{\Gamma \vdash D} \\  
\overline{\xt{m}'(\overline{\xt{p}:\tau_D''}):\tau_D' \in D \implies \xt{m}'(\overline{\xt{p}:\tau_C''}):\tau_C' \in C \wedge (\tau_C' <: \tau_D' \vee \tau_D' = \anyt) \wedge (\overline{\tau_D'' <: \tau_C'' \vee \tau_C'' = \anyt})}\\
\overline{\xt{f}:\tau_D \in D \implies \xt{f}:\tau_C \in C \wedge (\tau_C <: \tau_D \vee \tau_D = \anyt)}\\
\overline{\Gamma,\xt{this}:C,\overline{\xt{f}:\tau},\overline{\xt{p}:\tau''} \vdash e : \tau'}\\s
}{\Gamma \vdash \texttt{class } C \texttt{ implements } \overline{D}\;\{\overline{\xt{f} : \tau}, \overline{\xt{m}(\overline{\xt{p}:\tau''}):\tau' = \{ e \}}\}}
\end{mathpar}

\section{Dynamic semantics:}

Expression reduction:

\begin{mathpar}
\inferrule*[]{ e,v \castreduce e',v'}{F[e],v \castreduce F[e'],v'}

\inferrule*[]{ e,v \expreduce e',v'}{F[e],v \expreduce F[e'],v'}

\inferrule*[]{ e \stepsto e' }{ e,\mu \expreduce e',\mu}

\inferrule*[]{\xt{class}\;C\{\overline{\xt{f}:\tau}, \overline{\xt{m}(\overline{\xt{p}:\tau}):\tau' = e}\}\\\mu'=\mu(a\mapsto\{\overline{f=v},\overline{\xt{m}(\overline{\xt{p}:\tau}):\tau' = e}\}) }{ \xt{new }C(\overline{v}),\mu \expreduce a,\mu'}

\inferrule*[]{ \mu[a\mapsto \{\ldots,\xt{m}(\overline{\xt{p}\cast{c}})=e\}] }{ a.\xt{m}(\overline{v}),\mu \expreduce a!\xt{m}(\overline{v\cast{c}})}

\inferrule*[]{a\mapsto \{\ldots,\xt{m}(\overline{\xt{p}\cast{c}})=e\}]}{a!\xt{m}(\overline{v}) \expreduce [a/\xt{this}][\overline{v/\xt{p}}]e,\mu}

\inferrule*[]{ \mu[a\mapsto\{\ldots,\xt{f}=v,\ldots\}] }{a.f,\mu \expreduce v,\mu}

\inferrule*[]{ \mu' = \mu[a\mapsto v] }{a.f = v,\mu \expreduce v,\mu}

\inferrule*[]{ }{ \ifthenelse{\intv{0}}{e_1}{e_2},\mu \expreduce e_1,\mu }

\inferrule*[]{n\neq 0}{ \ifthenelse{\intv{n}}{e_1}{e_2},\mu \expreduce e_1,\mu }

\inferrule*[]{ n_1 + n_2 = n_3 }{ \intv{n_1} + \intv{n_2},\mu \expreduce \intv{n_3},\mu}
\end{mathpar}

Cast reduction:
\begin{mathpar}

\inferrule*[]{ }{ v\cast{\iota} \castreduce v}

\inferrule*[]{ I_1 \sim I_2 }{ v\cast{I_1!}\cast{I_2?} \castreduce v\cast{I_1 \Rightarrow I_2}}

\inferrule*[]{
\cstctx(a) = v : \tau \\ 
\tau \sqcap \tau' = \tau''\\
\tau'' \neq \tau\\
}{ a\cast{\tau'},\cstctx \castreduce a,\cstctx(a\mapsto v \cast{\tau \Rightarrow \tau''})}

\inferrule*[]{
\mu(a) = v : \tau \\ \tau \sqcap \tau'
 = \tau}{ a\cast{\tau'},\cstctx \castreduce a,\cstctx}

\inferrule*[]{
	v = \{\overline{\xt{f} = v'}, \overline{\xt{m}(\overline{\xt{p}}) = e}\}\\
	c = \{\overline{\xt{f}:c_f},\overline{\xt{m}(\overline{c_p}):c_m}\}
}{
	v\cast{c},\cstctx \castreduce \{\overline{\xt{f} = v\cast{c_f}}, \overline{
\xt{m}(\overline{\xt{ip}}) = \texttt{this}.\xt{m'}(\overline{\xt{ip}\cast{c_p}}),
\xt{m'}(\overline{\xt{p}}) = e\cast{c_m}
}\}
}
\end{mathpar}

State reduction:
\begin{mathpar}
\inferrule*[]{ e,v\castreduce e',v' }{ CF[e],v \longrightarrow CF[e'],v'}

\inferrule*[]{ e,v\expreduce e',v' }{ CF[e],v \longrightarrow CF[e'],v'}

\inferrule*[]{ e,v\expreduce e',v' }{ F[e],v \longrightarrow F[e'],v'}

\inferrule*[]{ e,v\castreduce e',v' }{ e,v \longrightarrow e',v'}

\inferrule*[]{ e,v\expreduce e',v' }{ e,v \longrightarrow e',v'}

 \inferrule*[]{
 	\cstctx(a) = cv : \tau\\
 	cv,\cstctx \castreduce cv',\cstctx'\\
 	\cstctx'(a)_{rtti} = \tau\\
 }{
 	e,\cstctx \longrightarrow e,\cstctx'(a \mapsto cv' : \tau)
 }

 \inferrule*[]{
 	\cstctx(a) = cv : \tau\\
 	cv,\cstctx \castreduce cv',\cstctx'\\
 	\cstctx'(a)_{rtti} \neq \tau\\
 }{
 	e,\cstctx \longrightarrow e,\cstctx'
 }
\end{mathpar}

Cast to coersion compilation
\begin{mathpar}
\inferrule*[]{}{\intt \Rightarrow \intt = \iota}

\inferrule*[]{}{\strt \Rightarrow \strt = \iota}

\inferrule*[]{}{I \Rightarrow \anyt = I!}

\inferrule*[]{}{\anyt \Rightarrow I = I?}

\inferrule*[]{}{\{\overline{\xt{f}:\tau_1}, \overline{\xt{m}(\overline{\xt{p}:\tau_1''}):\tau_1'} \} \Rightarrow \{\overline{\xt{f}:\tau_2}, \overline{\xt{m}(\overline{\xt{p}:\tau_2''}):\tau_2'} \} = \{\overline{\xt{f}:\tau_1\Rightarrow\tau_2}, \overline{\xt{m}(\overline{\xt{p}:\tau_2'' \Rightarrow \tau_1''}) : \tau_1' \Rightarrow \tau_2'}\}}
\end{mathpar}

Meet
\begin{mathpar}
\inferrule*[]{}{\tau \sqcap \tau = \tau}

\inferrule*[]{}{\tau \sqcap \anyt = \tau}

\inferrule*[]{}{\anyt \sqcap \tau = \tau}

\inferrule*[]{}{\{\overline{\xt{f}:\tau_1}, \overline{\xt{m}(\overline{\xt{p}:\tau_1''}):\tau_1'} \}\sqcap \{\overline{\xt{f}:\tau_2}, \overline{\xt{m}(\overline{\xt{p}:\tau_2''}):\tau_2'} \} = \{\overline{\xt{f}:\tau_2 \sqcap \tau_2}, \overline{\xt{m}(\overline{\xt{p}:\tau_1'' \sqcap \tau_2''}):\tau_1' \sqcap \tau_2'} \}}
\end{mathpar}
\end{document}