\documentclass[sigconf]{acmart}

\usepackage{xspace,listings,url,framed,amssymb,colortbl,
            amsmath,mathpartir,hyperref,doi, rotating,
            stmaryrd, graphicx, tikz, colortbl, xparse, etoolbox, pgffor,booktabs} % double brackets llbracket
\input{macros}

% Copyright
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}

\lstdefinelanguage{JavaScript}{
  keywords={typeof,new,true,false,instanceof,catch,function,return,null, 
    catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{darkgray},
  ndkeywords={class,def,interface,export,boolean,throw,extends,implements,import,this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,  comment=[l]{//},  morecomment=[s]{/*}{*/},
  commentstyle=\color{gray}\ttfamily,  stringstyle=\color{gray}\ttfamily,
  morestring=[b]',  morestring=[b]",
  backgroundcolor=\color{vlightgray},
  aboveskip=\medskipamount, %0em,
  belowskip=\smallskipamount, %0em
  escapeinside={(*@}{@*)}
}
\lstset{
  language=JavaScript,  extendedchars=true,  basicstyle=\footnotesize\ttfamily,
  showstringspaces=false,   showspaces=false,  numberstyle=\small,
  numbersep=9pt,  tabsize=2, breaklines=true,  showtabs=false, captionpos=b
}

% DOI
\acmDOI{10.475/123_4}

% ISBN
\acmISBN{123-4567-24-567/08/06}

%Conference
\acmConference[FtFJP]{Submitted to FtFJP}{July 2018}{}
\acmYear{2018}
%\copyrightyear{2016}
%\acmArticle{4}
%\acmPrice{15.00}


\begin{document}
\title{Monotonic Gradual Typing in a Common Calculus}
\subtitle{}

\author{Benjamin Chung}
\affiliation{\institution{Northeastern University}}
\author{Jan Vitek}
\affiliation{\institution{Northeastern and CTU}}


\begin{abstract}
Gradual typing refers to the notion that programs can be incrementally
decorated with type annotations. Languages that
support this approach to software development allow for programs being in
various state of ``typedness'' on a scale that ranges from entirely untyped
to fully statically typed. The intellectual challenge for language designers
is to assign meaning programs on that scale. The litterature in the field is
rich with a variety of proposals ranging from the laissez faire of optional
typing to sound approaches that wrap all values in protective shells to
ensure that they behave as promised by their ascribed type. Each gradual
type system comes with tradeoffs. Some systems provide strong guarantees at
the expense of vastly degraded performance, others do not impact the running
time of programs but do little to pervent type errors. This paper looks at
an intriguing point the landscape: a variant of Python referred to as
Monotonic Reticulated Python. Our contribution is a semantics of the
proposal as a translation from a surface language down to a core calculus.
\end{abstract}

\definecolor{Gray}{gray}{0.9}

\definecolor{vlightgray}{gray}{0.93}

\maketitle

\section{Introduction}

Gradual typing refers to a family of approaches that add types to untyped
programs, approaches which all solve the same problem in different
ways~\cite{SiekTaha06,tf-dls06}.  Gradual typing allows programmers to
assert types for untyped values, types which (in a sound system) need to be
checked dynamically. The pantheon of gradual type systems arises from
different mechanisms for checking the types of untyped values.

Object-oriented languages pose a particular problem for gradual typing. It
is easy to check if a base value has a type, but problems arise from
higher-order behavior. In a functional language, this manifests when trying
to assert an arrow type on a lambda. Object-oriented languages have this
same problem -- trying to assert a typed method on an object with an untyped
version of the method -- but have additional complexity in the form of
subtyping.

\begin{figure}[h]
\begin{lstlisting}
class C { 
  f(x:*):* { x } 
  g(x:*):* { new C() }
}
class D { 
  f(x:D):D { x }
}

new D().f( <*> new C() )
\end{lstlisting}
\caption{A gradually-typed program.}
\label{fig:simpleprog}
\end{figure}

Figure~\ref{fig:simpleprog} shows a simple example of a gradually typed
object-oriented program. In this program, the type \any indicates that a
variable is dynamic; thus it can hold a value of any class, and any method
can be invoked with that variable as a receiver returning a value of type
\any. Expression that use non-\any types are checked using a run-of-the-mill
static type system. The program uses dynamic behavior (a cast) to pass an
instance of class \C as one of type \D in the call to \f. \C has no
guarantee to act like a \D, so \D-ness must be enforced at runtime. However,
how this enforcement happens is an open problem. The program could fail when
the instance of \C is first passed, fail if \f is called on \x, or not fail
at all because the program never breaks the guarantee provided by the
gradual type system.

In a companion paper, to appear at ECOOP 2018~\cite{us}, we examined four of
these approaches to gradual typing.  The approaches investigated in that
paper were the optional, transient, behavioral, and concrete semantics. We
chose these semantics due to their popularity and relative simplicity, but
elided one semantics, the monotonic semantics of~\cite{siek14}, due to its
complexity. This paper places the monotonic semantics into the same
framework.

The problem the monotonic semantics sets out to solve is that in gradually
typed programs, field access or method invocation can be slow. Under the
sound semantics, which adds wrappers to enforce types, every access or call
may have a layer of indirection. This can make typed code in a gradually
typed language excruciatingly slow~\cite{popl16}.  Suppose we have an object
$\x = \{ \f:\any = 3 \}$, then alias it as $\xp = \SubCast{\{ \f:\xt{int}
  \}}\x$. Accessing $\xp.\f$ is not guaranteed to be safe, even though \xp
is fully typed. If we run \xt{\x.\f = "hello"} at some point, then $\xp.\f$
is now ill-typed via the reference. As mentioned previously, other semantics
deal with this by checking the result of operations in typed code, lazily
enforcing soundness of type annotations.

The monotonic semantics is an \emph{eager} mechanism to enforce types. With
monotonic, once a value in the heap is typed, it will always remain of that
type. In the example above, once we aliased \x as \xp, \xp's type (e.g. that
\f has type \xt{int}) will be enforced upon usages of \x. Now, our
assignment \xt{\x.\f = "hello"} will fail, because we are assigning a value
of improper type to the field \f of the object. In this manner, all
statically typed values under the monotonic semantics are known to have
correct field typing.

In this paper, we present a formalization of the monotonic semantics in our
framework for comparing gradual type systems. We use a common
gradually-typed source language and translate it to a common target language
(called \kafka) according to the monotonic semantics. We then use this
formalization to discuss the monotonic semantics's properties, and compare
it to alternative gradual type systems.

\section{Monotonic Gradual Types}

The idea behind the monotonic semantics was originally put forward by Siek
and Vitousek in~\cite{siek14} for their Reticulated Python language
implementation. The same group then went on to implement the monotonic
semantics into their Grift implementation (a functional language), allowing
the comparison of performance inherent to each gradual type system.

The idea behind the monotonic semantics is that types only ever get more
precise. This design gives rise to its name; types of values in a monotonic
language's heap monotonically get more static. Each object in the heap has
an associated type, it's run-time tag, in an object-oriented language that
tag identifies the class of the object and is used for dispatching method
invocations. When a reference to an object is cast to a more precise type,
intuitively a type with fewer occurrences of \any, that new type is attached
to the value in the heap.  If untyped code later tries to read or write
fields, or call methods, in a way that violates the updated type, a type
error will occur. By locking in applied types forevermore, typed code under
the monotonic semantics can assume that mutable state will remain well
typed.

In turn, the ability to rely on the types of mutable state 
provides several advantages over other gradual type systems. The monotonic
system has a soundness guarantee, unlike the optional semantics (which
simply forgets about all type annotations at runtime); monotonic languages
can elide field dereference guards needed by the transient semantics; do not
need the wrappers inserted by the behavioral semantics; and is far more
flexible than the concrete semantics. Additional details about these other
semantics can be found in our companion paper~\cite{us}.

As a result, monotonic has the potential to provide substantial benefits to
the performance of gradually typed languages. Variables are guaranteed to
hold values of their cast type, so they can be relied upon for memory layout
of objects. Types under the monotonic semantics can be used to optimize away
generic field accesses, and assignments to typed fields from fully typed
code do not need to be checked.

In the context of object orientation, monotonic's ability to protect mutable
state without the need for wrappers is a significant advantage. Other
gradual type systems need guards, wrappers, or a stronger notion of
soundness in order to guarantee safety of field access. The monotonic
semantics, in contrast, prevents untyped code from assigning ill-typed
values to previously typed references, allowing unchecked dereferencing in
typed code.

\section{Formalism}

We use the framework we set out in our earlier paper to provide a simple
presentation of the monotonic semantics in an object-oriented setting. Instead
of using formal languages specially crafted to support each semantics, we use
a common source and target language for every gradual typing semantics. The 
semantics is then encoded into the translation, allowing comparison of gradual 
type systems by examining their translation.

\subsection{Source Language}

Our common source language is similar to Featherweight Java, with a few
changes. This language has classes but relies on structural subtyping
instead of the nominal subtyping adopted by FJ. For our purposes there is no
need for inheritance. Structural subtyping is needed to support the
evolution of types as casts are being applied. The source language also
introduces a dynamic type, \any, and a convertibility relation, allowing
gradually typed programs to be expressed. This same source language and
source language type system is shared between the translation presented here
and the four in our main paper, allowing the same programs to be ran under
all of our semantics. We replicate the static semantics for the source
language here, in figure~\ref{slts}. The dynamic of the source language is
given by a translation to a lower-level language which we will present next.

Programs in the source language consist of a class table and an initial
expression. Classes consist of field and method definitions. Fields have a
name and a type. Method definitions have names, types for their single
argument and return type, and an expression. Expressions consist of
variables, the self-reference \this, field read and write \FRead\f and
\FWrite\f\e, invocation \Call\e\m\e, and new object creation
\New\C{\e[1]..}. Each class has an implicit default constructor that merely
assigns arguments to fields. All operations conform to what they would do in
Featherweight Java, and the type system is straightforward.

The static type system allows the implicit conversion of typed and untyped
terms via the convertibility operator, written $\ConvertE\K s\t\tp$ -- type
$\t$ is convertible to type $\tp$.  The relation is used both for up-casting
and for conversions of \any to non-\any types.  \RuleRef{SUB} ensures
soundness of up-casts. While \RuleRef{TOA} and \RuleRef{ANYC} allow implicit
conversion to and from the dynamic type.  To avoid collapsing the type
hierarchy, convertibility is not transitive. \RuleRef{TOA} and
\RuleRef{ANYC} are break soundness, their use motivates the need for dynamic
checks. 

The source language enforce privacy on fields. They can only be accessed
from them method of the object. Furthermore, fields do not show up in type
signatures. Subtyping between objects is computed solely on methods
signatures.


\begin{figure*}[!t]

\hrulefill

\vspace{4mm}

\begin{tabular}{@{}l@{~}l@{}l@{}l@{}l@{}l@{}l@{}l}
\e~::=~\x\B\this\B\FRead\f\B\FWrite\f\e\B\Call\e\m\e\B\New\C{\e[1]..}\\
\k~::=~ \Class \C {\fd[1]..}{\md[1]..} \qquad
\md~::=~\Mdef\m\x\t\t\e\qquad
\fd~::=~ \Fdef\f\t\qquad
\t~::=~ \any \B \C
\end{tabular}

\begin{mathpar}
\Rule{STG-VAR}{~\\\\
  \HasType \Env\x\t
}{
  \EnvTypeS \Env\K\x\t
}

\Rule{STG-GET}{
  \HasType \Env\this\C \\\\  \Fdef\f\t \in \App\K\C
}{
  \EnvTypeS \Env\K{\FRead\f}\t
}    

\Rule{STG-SET}{
  \HasType \Env\this\C \quad \Fdef\f\t \in \App\K\C \\\\
  \EnvTypeS \Env\K\e\tp \quad  \ConvertE\K{s}\tp\t
}{
  \EnvTypeS \Env\K{\FWrite\f\e}\t
}    

\Rule[width=15em]{STG-CALL}{
  \EnvTypeS \Env\K\e\any \\\\ \EnvTypeS \Env\K\ep\t 
}{
  \EnvTypeS \Env\K{\Call\e\m\ep}{\any}
}    

\Rule[width=15em]{STG-CALL}{
  \EnvTypeS \Env\K\e\C \quad \EnvTypeS \Env\K\ep\t \\\\
  \Mtype \m{\t[1]}{\t[2]}\in \App\K\C  \quad
  \ConvertE\K{s}\t{\t[1]}
}{
  \EnvTypeS \Env\K{\Call\e\m\ep}{\t[2]}
}   

\Rule{STG-NEW}{
  \Ftype{\f[1]}{\t[1]}.. \in \App\K\C \\\\
  \EnvTypeS \Env\K{\e[1]}{\tp[1]}..\quad \ConvertE\K{s}{\tp[1]}{\t[1]}..
}{
  \EnvTypeS \Env\K{\New\C{\e[1]..}}\C
}
\end{mathpar}

\vspace{-5mm}  
  
\begin{mathpar}
\IRule{SUB}{
   \SSub\emptyset\K\t\tp
}{
   \ConvertE\K{s}\t\tp
}
    
\IRule{TOA}{~ }{ \ConvertE\K{s}\t\any}
    
\IRule{ANYC}{~}{ \ConvertE\K{s}\any\t }
\end{mathpar}


\hrulefill
\caption{Surface language syntax and type system (extract).}\label{slts}
\end{figure*}

\begin{figure*}[!t]

\hrulefill

\vspace{4mm}

\small\begin{tabular}{@{}lll}

\begin{minipage}{5.5cm}\begin{tabular}{@{}l@{~}l@{}l@{}l@{}l@{}l@{}l@{}l}
\e\hspace{.1cm} ::= & \hspace{.2cm} \x        
   &\B \this         
   &\B \that      
   &\B \FRead\f  \\   
   & &
   &\B \FWrite\f\e 
   &\B \KCall\e\m\e\t\t \\
   & &   
   &\B \New\C{\e[1]..}  
   &\B \DynCall\e\m\e \\
   & & & \multicolumn{3}{@{}l}{\B \a \B \FReadR\a\f \B \FWriteR\a\f\e} \\
   & & & \B \src{\MonCast\t\e}
\end{tabular}\end{minipage}&
\begin{minipage}{3.7cm}\begin{tabular}{l@{~}l@{}l@{}l}
  \k &::= \Class \C {\fd[1]..}{\md[1]..} \\
 \md &::= ~ \Mdef\m\x\t\t\e \\ 
 \fd &::= ~ \Fdef\f\t \\ 
  \t &::= ~ \any  \B   \C  \\ 
\end{tabular}\end{minipage} &
\begin{minipage}{5.5cm}

\begin{tabular}{llllllllllllllllll}
\EE &::=& ~ \FWriteR\a\f\EE   &\B  
        \KCall\EE\m\e\t\t  &\B\\
        &&\KCall\a\m{\EE}\t\t &\B
        \DynCall\EE\m\e   &\B\\
&       & \DynCall\a\m\EE   &\B
       \src{\MonCast\t\EE}  &\B\\
&&     \New\C{\a[1]..\,\EE\,\e[1]..} &\B 
      \EM{\square}
\end{tabular}
\end{minipage}
\end{tabular}


\begin{mathpar}
\IRule{KT-VAR}{
   ~\\\\
   ~\\\\
   \HasType \Env\x\t
 }{
   \EnvType \Env\s\K\x\t
}

\IRule{KT-SUB}{
  ~\\\\
  \EnvType \Env\s\K\e\tp \\\\
 \StrSub \cdot\K \tp \t
 }{
  \EnvType \Env\s\K\e\t 
}   

\IRule{KT-READ}{
  ~\\\\
  \HasType\Env\this\C \\\\
  \Fdef\f\t \in \App\K\C
}{
  \EnvType \Env\s\K{\FRead\f}\t
}  

\IRule{KT-REFREAD}{
  \s(\a) = \C\{..\} \\\\
  \Fdef\f\t \in \App\K\C
}{
  \EnvType \Env\s\K{\FReadR\a\f}\t
}  

\IRule{KT-WRITE}{
  \HasType\Env\this\C \\\\
  \Fdef\f\t \in \App\K\C \\\\
  \EnvType \Env\s\K\e\t
}{
  \EnvType \Env\s\K{\FWrite\f\e}\t
}    

\IRule[width=12em]{KT-REFWRITE}{
  \s(\a) = \C\{..\} \\\\
  \Fdef\f\t \in \App\K\C \\\\
  \EnvType \Env\s\K\e\t
}{
  \EnvType \Env\s\K{\FWriteR\a\f\e}\t
}  

\IRule[width=16em]{KT-CALL}{
  \EnvType \Env\s\K\e\C \\\\
  \EnvType \Env\s\K\ep\t \\\
  \Mtype\m\t\tp \in \App\K\C 
}{
  \EnvType \Env\s\K{\KCall\e\m\ep\t\tp}\tp
}    

\IRule{KT-DYNCALL}{
  ~\\\\
  \EnvType \Env\s\K\e\any \\\\
  \EnvType \Env\s\K\ep\any
}{
  \EnvType \Env\s\K{\DynCall\e\m\ep}\any
}    

\IRule[width=20em]{KT-NEW}{
  ~\\\\
  \EnvType \Env\s\K{\e[1]}{\t[1]}..\\\\
  \Class \C {\Fdef{\f[1]}{\t[1]}..}{\md[1]..} \in \K
}{
  \EnvType\Env\s\K{\New\C{\e[1]..}}\C
}

\src{
\IRule{KT-MONOCAST}{
  \EnvType \Env\s\K\e\tp
}{
  \EnvType \Env\s\K{\MonCast\t\e}\t
}
}

\IRule{KT-REFTYPE}{
  \s(\a) = \obj\C{\ap[1]..}
}{
  \EnvType \Env\s\K\a\C
}

\IRule{KT-REFANY}{
 }{
   \EnvType \Env\s\K\a\any
}
\end{mathpar}

\vspace{4mm}

\begin{minipage}{0.45\textwidth}
\begin{tabbing}
\K\HS\New\C{\a[1]..}\HS\=\s~\HS\=\Red\HS\=\K\HS\=\ap\HS\=\sp\HS\=
   \WHERE\HS\=\fresh\ap \HS\HS\sp ={\Map\s{\Bind\ap{\obj\C{\a[1]..}}}}
\\
\K\HS \FReadR\a{\f[i]} \> \s \>\Red\>  \K\>$\a[i]$ \> \s  \> 
   \WHERE \>\App\s\a=\obj\C{\a[1],..\a[i],\a[n]..}
\\
\K\HS{\FWriteR\a{\f[i]}\ap}\>\s\>\Red\>\K\>\ap\>\sp\>  
   \WHERE \>\App\s\a=\obj\C{\a[1],..\a[i],\a[n]..} 
   \HS\HS \sp=\Map\s{\Bind\a{\obj\C{\a[1],..\ap,\a[n]..}}}
\\
\K\HS{\KCall\a\m\ap\t\tp} \> \s      \>\Red\>     \K \>  \ep \> \s \> 
    \WHERE\> \ep = {[\a/\this~{\ap/\x}]\e} \HS\HS
             \Mdef\m\x{\t_{1}}{\t_{2}}\e\In \App\K\C \HS\HS
             \App\s\a=\obj\C{\a[1]..} \HS\HS
               \StrSub {\emptyset}\K\t {\t_{1}} \HS\HS
 \StrSub {\emptyset}\K{\t_{2}} \tp
\\
 \K\HS {\DynCall\a\m\ap}\> \s        \>\Red\>    \K \> \ep \> \s \>  
       \WHERE\> \ep = {[\a/\this~{\ap/\x}]\e}\HS\HS
                \Mdef\m\x\any\any\e \In \App\K\C \HS\HS
                 \App\s\a=\obj\C{\a[1]..} 
\\
 \K\HS {\MonCast \t\a} \> \s         \>\Red\>   \Kp \> \ap \> \sp \> \WHERE\> \moncast \a\t\s\K \Kp\ap\sp    
\\
\K \HS \EM{\EE[\e]} \> \s            \>\Red\>   \Kp \> \EM{\EE[\ep]} \> \sp \> \WHERE \> \K~\e~\s \Red~\Kp~\ep~\sp
\end{tabbing}\end{minipage}\vspace{2mm}

\noindent\hrulefill

\caption{\kafka syntax, static and dynamic semantics, and monotonic
  translation.}\label{syn}
\end{figure*}


\subsection{KafKa}

\kafka's design follows the surface language with some differences.
Expressions are extended with \that a distinguished variable used for
wrapped object reference, typed and untyped method invocations, subtype and
monotonic casts.  Evaluation is likewise standard with a few exceptions,
with an evaluation context consisting of a class table \K, an expression
being evaluated \e, and a heap \s, mapping from addresses \a to objects,
denoted $\C\{\a\ldots\}$. Due to the need for dynamically generate classes,
the class table \K is part of the state, and not the evaluation context.

\kafka has two invocation forms, the untyped invocation $\DynCall\e\m\ep$
and the typed invocation $\KCall\e\m\ep{\t}{\tp}$, both denoting a method
call to method $\m$ with argument \ep. This is unusual for two
reasons. First, most gradual type systems have no explicit untyped
invocation form, and second, the typed form also specifies the argument type
(\t) and return type (\tp).

We use gray background to indicate changes to \kafka in figure~\ref{slts} to
support monotonic. The only addition is that of the monotonic cast. The next
section focuses on giving a semantics to that cast.


\section{Monotonic Semantics}

The monotonic semantics is defined by a translation from the surface
language down to \kafka and the meaning of the monotonic cast. 

The translation is syntax directed, each surface class is translated to an
eponymous \kafka class. Types of methods and fields are retained in the
translation. Expressions are translated with $\TRG[M]{\e}\Env$. Variables
are translated to themselves. Calls are translated to either dynamic calls
or static calls depending on the type of the receiver.  If the receiver is
of type \any, then the argument must be of type \any. If the receiver of
some class \C then the argument must be of type \D, where \D is the expected
argument type of the method.  We use a variant of the translation relation
that performs a cast if necessary on its argument expression,
\TAG[M]{\e}{\Env}\t.  The inserted cast is the monotonic cast,
\MonCast{\t}{\ep}.

\begin{figure*}[!t]
\center

\begin{center}
\begin{minipage}{10cm}
\begin{align*}
\TRG[M]{\x}\Env &= \x & \\
\TRG[M]{\Call{\e_1}\m{{\e_2}}}\Env &= \DynCall{\ep_1}\m{\ep_2} & 
   \IF\EM{\TypeCk{\K,\Env}{\e[1]}\any ~ \AND ~
    \TRG[M]{\e_1}\Env = \ep_1}
   \EM{~\AND~ \TAG[M]{\e_2}\Env{\any} = \ep_2}\\
\TRG[M]{\Call{\e_1}\m{{\e_2}}}\Env &= \KCall{\ep_1}\m{\ep_2}{\D[1]}{\D[2]} & 
    \IF\EM{\TypeCk{\K,\Env}{\e[1]}\C ~ \AND\; ~ 
    \Mtype\m{\D[1]}{\D[2]}\In\App\K\C}
  ~\EM{\AND ~ \TRG[M]{\e_1}\Env= \ep_1 
   ~\AND~ \TAG[M]{\e_2}\Env{\D[1]} = \ep_2}\\
\TRG[M]{\New\C{{\e_1}..}}\Env &= \New\C{\ep_1..} & 
   \IF\EM{\Ftype{\f[1]}{\t[1]}\In\App\K\C ~\AND~
     \ep[1] = \TAG[M]{\e[1]}\Env{\t[1]} ~..}\\
\TAG[M]{\e}{\Env}\t &= \e' & \IF\EM{\TypeCk{\K,\Env}\e\tp 
     ~\AND~ \K\vdash\tp\Sub\t}\\
\TAG[M]{\e}{\Env}\t &= \MonCast{\t}{\ep} & \IF\EM{\TypeCk{\K,\Env}\e\tp 
    ~\AND~ \K\vdash\tp\not\Sub\t}
\end{align*}
\end{minipage}
\end{center}

Translation

\begin{mathpar}
\IRule{CM}{
  \s(\a) = \C\{\ap..\} \\
  \tmeet \C\t\cdot\K = \Cp~\Kp\\
  \sp = \s[\a \mapsto \Cp\{\ap..\}]
}{
  \moncast \a\t\s\K \Kp \sp\\
}
\end{mathpar}

\begin{align*}
\P &::= \cdot \B \P ~{{(\C,\D)}\mapsto\Cp}
\end{align*}


\begin{mathpar}

\IRule{TM1}{ }{\tmeet\C\any\P\K = \C\,\K}

\IRule{TM2}{ }{\tmeet\any\C\P\K = \C\,\K}

\IRule{TM3}{ }{\tmeet\t\t\P\K = \t\,\K}

\IRule{TM5}{
    \P(\C,\D) = \Cp
}{
    \tmeet\C\D\P\K = \Cp\,\K
}

\IRule{TM4}{
  \fresh\Cp\\
  (\C,\D) \not\in\P \\
  \Pp = \P~{{(\C,\D)}\mapsto\Cp} \\
  \mtype\C\K = {\mt..}\\
  \mtype\D\K = {\mtp..}\\
  \mmeet{\mt..}{\mtp..}\Pp\K = \mtpp..\,\Kp\\
  \Kpp = \Kp~\typegen{\mtpp..}\Cp\\
}{
    \tmeet\C\D\P\K = \Cp\,\Kpp
}

\end{mathpar}


\begin{mathpar}
\IRule{MM1}{}{
  \mmeet{\mt ..}{\cdot}\Env\K =\mt.. ~\K
}

\IRule{MM2}{}{
  \mmeet{\cdot}{\mt ..}\Env\K ={\mt ..} ~\K
}

\IRule{MM6}{
  \Mtype\m{\t_3}{\t_4} \in {\mt_2} \\
  \tmeet{\t_3}{\t_1}\Env\K = \t_5~\Kp \\
  \tmeet{\t_2}{\t_4}\Env\Kp = {\t_6}~{\Kpp} \\
  \mmeet{{\mt_1 ..}}{{\mt_2 ..}}\Env\Kp = {\mt_3 ..}~\Kpp
}{
  \mmeet{\Mtype\m{\t_1}{\t_2}~{\mt_1 ..}}{{\mt_2 ..}}\Env\K =\Mtype\n{\t_5}{\t_6} ~{\mt_3 ..} ~\Kpp
}
\end{mathpar}

\[\begin{array}{l@{~}r@{}r@{~}r@{~}r@{~}rr}
\arrayrulecolor{white}
\classgen{\C, \md.., \mt.., \mtp.., \D, \K}= \\
  \SP \class~\D~\{ \\
    \SPP \Fdef\f\t   &
        \All{\f\!:\t\in\text{fields}(\K,\C)} \\[1mm]
    \SPP \Mdef\m\x\any\any{~\MonCast\any{\KCall\this\m{\MonCast{\t[1]}\x}{\t[1]}{\t[2]}}~}\HS\HS & 
          \All\m \Mdef\m\x{\any}{\any}\e\in\md..  ~\AND~ \Mtype\m{\C_1}{\C_2}\in{\mtp..}
\\[1mm]\hline
\SPP \Mdef\m\x{\C_1}{\C_2} {\MonCast{\C_2}{[{(\MonCast{\any}\x)}/\x]\ep}~}
&     \All \m \Mdef\m\x{\any}{\any}\e\in\md.. ~\AND~ \Mtype\m{\C_1}{\C_2}\in\mtp.. 
\\[1mm]\hline
\SP\}
\end{array}
\]

\caption{translation}
\end{figure*}

At run-time the monotonic cast invokes moncast which takes the address \a of
an aobject of class \C, a target type \t, a heap \Env and a class table \K;
it returns an updated heap \Envp and an updated class table \Kp. What it
does is compute a new class \Cp for the object at \a. That class is obtained
by taking the meet of \C (the current class) and \t (the target type).






The \texttt{mmeet} function is used by the \texttt{meet} functions to
perform the meet over the typing of each method within a class definition.
The \texttt{mmeet} function also takes four arguments, the method
signatures of the original class $\mt..$, the method signatures of the cast
class $\mtp..$, the environment $\P$, a class table $\K$, and outputs method
types $\mtpp..$ and a class table $\Kp$. \\


The \xt{monWrap} function generates the wrapper for the monotonic translations,
when a monotonic cast is required.


The \xt{typegen} function is used by the \xt{meet} function to generate the new classes
of the type produced by the meet operation.

\footnotesize
\[\begin{array}{l@{~}r@{}r@{~}r@{~}r@{~}rr}
\arrayrulecolor{white}
\typegen{\mt..}{\D} = \\
\SP \class~\D~\{
\\[1mm]
\SPP \Mdef\m\x\t\tp {{\MonCast\tp{\x}}} 
&
\All m \Mtype\m\t\tp\in\mt..
\\[1mm]
\SP\}
\end{array}
\]
\normalsize

\bibliographystyle{ACM-Reference-Format}
\bibliography{../../bib/jv,../../bib/all}

\end{document}
