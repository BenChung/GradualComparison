\documentclass[sigconf]{acmart}

\usepackage{xspace,listings,url,framed,amssymb,colortbl,
            amsmath,mathpartir,hyperref,doi, rotating,
            stmaryrd, graphicx, tikz, colortbl, xparse, etoolbox, pgffor,booktabs} % double brackets llbracket
\input{macros}

% Copyright
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}


% DOI
\acmDOI{10.475/123_4}

% ISBN
\acmISBN{123-4567-24-567/08/06}

%Conference
\acmConference[WOODSTOCK'97]{ACM Woodstock conference}{July 1997}{El
  Paso, Texas USA}
\acmYear{1997}
\copyrightyear{2016}
\acmArticle{4}
\acmPrice{15.00}


\begin{document}
\title{Monotonic Gradual Typing in a Common Calculus}
\subtitle{}

\author{Ben Trovato}
\authornote{Dr.~Trovato insisted his name be first.}
\orcid{1234-5678-9012}
\affiliation{%
  \institution{Institute for Clarity in Documentation}
  \streetaddress{P.O. Box 1212}
  \city{Dublin}
  \state{Ohio}
  \postcode{43017-6221}
}
\email{trovato@corporation.com}

\author{John Smith}
\affiliation{\institution{The Th{\o}rv{\"a}ld Group}}
\email{jsmith@affiliation.org}

% The default list of authors is too long for headers.
\renewcommand{\shortauthors}{B. Trovato et al.}


\begin{abstract}
This paper provides a sample of a \LaTeX\ document which conforms,
somewhat loosely, to the formatting guidelines for
ACM SIG Proceedings.\footnote{This is an abstract footnote}
\end{abstract}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below.
%
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>10010520.10010553.10010562</concept_id>
  <concept_desc>Computer systems organization~Embedded systems</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010575.10010755</concept_id>
  <concept_desc>Computer systems organization~Redundancy</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010553.10010554</concept_id>
  <concept_desc>Computer systems organization~Robotics</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>10003033.10003083.10003095</concept_id>
  <concept_desc>Networks~Network reliability</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Computer systems organization~Embedded systems}
\ccsdesc[300]{Computer systems organization~Redundancy}
\ccsdesc{Computer systems organization~Robotics}
\ccsdesc[100]{Networks~Network reliability}


\keywords{ACM proceedings, \LaTeX, text tagging}


\maketitle


\section{Complete translation for Monotonic}

\subsection{Monotonic cast static and dynamic rules}

\begin{minipage}{0.35\textwidth}
\begin{mathpar}
\IRule{W10}{
  \EnvType \Env\s\K\e\tp
}{
  \EnvType \Env\s\K{\MonCast\t\e}\t
}
\end{mathpar}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\begin{tabular}{l@{}l@{~}l@{~}l}
\CondRule{E11}{  %Monotonic cast  
  \moncast \a\t\s\K  \Kp\ap\sp    
}{    
  \ReduceA  \K{\MonCast \t\a}\s \Kp\ap\sp   
} \\
\multicolumn{4}{l}{\EE ::= \ldots \B \MonCast\t\EE }
\end{tabular}
\end{minipage}
\subsection{Monotonic translation for bidirectional expressions}

\begin{align*}
\TRG[M]{\x}\Env = \x & \\
\TRG[M]{\Call{\e_1}\m{{\e_2}}}\Env = \DynCall{\ep_1}\m{\ep_2} & \tag{\IF\EM{\TypeCk{\K,\Env}\e\any
\AND \TRG[M]{\e_1}\Env = \ep_1 \wedge \TAG[M]{\e_2}\Env{\any} = \ep_2}}\\
\TRG[M]{\Call{\e_1}\m{{\e_2}}}\Env = \KCall{\ep_1}\m{\ep_2}{\D[1]}{\D[2]} & \tag{\IF\EM{\TypeCk{\K,\Env}\e\C
\AND \Mtype\m{\D[1]}{\D[2]}\In\App\K\C \AND \TRG[M]{\e_1}\Env = \ep_1 \wedge \TAG[M]{\e_2}\Env{\D[1]} = \ep_2}}\\
\TRG[M]{\New\C{{\e_1}...}}\Env = \New\C{\ep_1...} & \tag{\IF\EM{\Ftype{\f[1]}{\t[1]}\In\App\K\C
    \AND \ep[1] = \TAG[M]{\e[1]}\Env{\t[1]} ~..}}\\
\TAG[M]{\e}{\Env}\t = \e' & \tag{\IF\EM{\TypeCk{\K,\Env}\e\tp \AND \K\vdash\tp\Sub\t}}\\
\TAG[M]{\e}{\Env}\t = \MonCast{\t}{\ep} & \tag{\IF\EM{\TypeCk{\K,\Env}\e\tp \AND \K\vdash\tp\not\Sub\t}}
\end{align*}

\section{Generative Monotone Casts}

\subsection{Retype function}\label{retype}

Formally, the \xt{retype} function takes a list of object
addresses \b\a and a list of types to ascribe to them \b\t, and updates the
heap \s and class table \K. 

\begin{align*}
\S &::= \cdot \B \Map\S{\Bind\a\C}
\end{align*}
\begin{mathpar}
\IRule{CRM1}{
  \htype \a\S\s\K = \C~\Kp\\
  \tmeet\C\t\cdot\Kp = \D\,\Kpp\\ 
  \C\not\EQ\D  \\
  \ftypes \a\D \s\Kpp = \b\ap~\b\tp \\
  \Sp = \Map\S{\Bind\a\D } \\
  \retype{\b\ap}{\b\tp}\Sp\s\K = \Spp\,\K'''
}{
  \retype \a\t\S\s\K = \Spp\,\K'''
}

\IRule{CRM2}{
  \htype \a\S\s\K = \tp\,\Kp\\
  \tmeet\tp\t\cdot\Kp = \tpp\,\Kp \\
  \tp\EQ\tpp \\
}{
  \retype \a\t\S\s\K = \S~\Kpp
}

\IRule{CRM3}{
  \retype\a\t\S\s\K = \Sp\,\Kp\\
  \retype{\b\a}{\b\t}\Sp\s\Kp = \Spp\,\Kpp
}{
  \retype {\a\,\b\a}{\t\,\b\t}\S\s\K = \Spp\,\Kpp
}
\end{mathpar}

\subsection{Spec function}\label{mono:spec}

Formally, the \xt{spec} (heap specialization) function takes a
sequence of object addresses \b\a, a heap typing \S, a heap \s
and a class table \K and returns a new heap where the objects
have been retyped. \Dom\S retrieves the list of addresses 
that have to be retyped.

\begin{mathpar}
\IRule{CMS1}{
  \E \text{ fresh}\\
  \D = \App\S\a \\
  \obj\C{\ap} = \App\s\a \\
  \obj\Cp{\b\app} = \App\s\ap \\
  \classoff\Cp\K = \b\mt \\
  \classoff\D\K = \b\mtp \\  
  \names{\b\mtp} \subseteq \names{\b\mt}\\
  \Kp = \K~\classgen{\Cp,\b\mt,\b\mtp,\E,\K} \\
  \sp = \Map\s{\Bind\a{\E\{\ap\}}}
}{
  \spec \a\S\s\K = \sp~\Kp
}

\IRule{CMS2}{
  \spec \a\S\s\K = \sp\\
  \spec {\b\a}\S\sp\K =\spp
}{
   \spec {\a\,\b\a}\S\s\K = \spp
}
\end{mathpar}

\subsection{Meet function}\label{monmeet}

The \texttt{mmeet} function is used by the \texttt{tmeet} functions to
perform the meet over the typing of each method within a class definition.
The \texttt{mmeet} function also takes four arguments, the method
signatures of the original class $\b\mt$, the method signatures of the cast
class $\b\mtp$, the environment $\P$, a class table $\K$, and outputs method
types $\b\mtpp$ and a class table $\Kp$. \\

\hrulefill

\opdef{
  $\mmeet{\b\mt}{\b\mtp}\P\K = \b\mtpp\,\Kp$
}{
}
\begin{mathpar}
\IRule{MM1}{
}{
  \mmeet{\b\mt}{\cdot}\P\K =\b{\mt} ~\K
}

\IRule{MM2}{
}{
  \mmeet{\cdot}{\b\mt}\P\K =\b{\mt} ~\K
}

\IRule{MM3}{ 
  \Mtype\f{}{\t} = \mt \\
  \Mtype\f{}{\tp} \in \b{\mtp} \\
  \tmeet{\t}{\tp}\P\K = \tpp~\Kp \\
  \Mtype\f{}{\tpp} = \mtpp
}{ 
   \mmeet{\mt}{\b{\mtp}}\P\K = \mtpp\,\Kp
}

\IRule{MM4}{ 
  \Mtype\f{\t}{\t} = \mt \\
  \Mtype\f{\tp}{\tp} \in \b{\mtp} \\
  \tmeet{\t}{\tp}\P\K = \tpp~\Kp \\
  \Mtype\f{\tpp}{\tpp} = \mtpp
}{ 
   \mmeet{\mt}{\b{\mtp}}\P\K = \mtpp\,\Kp
}


\IRule{MM5}{ 
  \Mtype\m{\t_1}{\t_2} = \mt \\
  \Mtype\m{\t_3}{\t_4} \in \b{\mtp} \\
  \tmeet{\t_3}{\t_1}\P\K = \t_5~\Kp \\
  \tmeet{\t_2}{\t_4}\P\Kp = {\t_6}~{\Kpp} \\
  \Mtype\n{\t_5}{\t_6} = \mtpp
}{ 
   \mmeet{\mt}{\b{\mtp}}\P\K = \mtpp\,\Kpp 
}

\IRule{MM6}{
  \mmeet{\mt}{\b{\mt_2}}\P\K = \mt_3~\Kp\\
  \mmeet{\b{\mt_1}}{\b{\mt_2}}\P\Kp = \b{\mt_4}~\Kpp
}{
  \mmeet{\mt~\b{\mt_1}}{\b{\mt_2}}\P\K =\mt_3\b{\mt_4} ~\Kpp
}
\end{mathpar}

\subsection{Monotonic class generation}\label{classgen}

The \xt{monWrap} function generates the wrapper for the monotonic translations,
when a monotonic cast is required.

\footnotesize
\[\begin{array}{l@{~}r@{}r@{~}r@{~}r@{~}rr}
\arrayrulecolor{white}
\classgen{\C, \b\md, \bmt, \bmtp, \D, \K}= \\
\SP \class~\D~\{ \\
\SPP \Fdef\that\C
\\[1mm]
\SPP \Mdef\f\x\any\any {\SubCast\any{\MonCast\tp{
      \Set{\Get\this\that}\f{\MonCast\t{\MonCast\tp\x}}}}}
&
\All f \Mtype\f\t\t\in\bmt &\wedge& \Mtype\f\tp\tp\in\bmtp
\\[1mm]\hline
\SPP \Mdefz\f\any{\SubCast\any{\MonCast\tp{\Get{\Get\this\that}\f}}}
&
 \All f \Mtype\f{}\t \in \bmt &\wedge& \Mtype\f{}\tp \in \bmtp
\\[1mm]\hline
\SPP \Mdef\m\x\any\any {~\SubCast\any{\MonCast{\tp[2]}{{[{(\MonCast{\t[1]}\x)}/\x]\ep}}}~}
&     \All \m \Mdef\m\x{\t[1]}{\tp[1]}\e\in\b\md &\wedge& \Mtype\m{\t[2]}{\tp[2]}\in\bmtp \\
&&\wedge&\multicolumn{3}{l}{\rtranstz{\bmt}\bmtp{[{(\MonCast\t\x)}/\x]\e}{\ep}}
\\[1mm]\hline
\SPP \Mdef\m\x{\t[2]}{\tp[2]} {\MonCast{\tp[2]}{[{(\MonCast{\t[1]}\x)}/\x]\ep}~}
&     \All \m \Mdef\m\x{\t[1]}{\tp[1]}\e\in\b\md &\wedge& \Mtype\m{\t[2]}{\tp[2]}\in\bmtp \\
&&\wedge&\multicolumn{3}{l}{\rtranstz{\bmt}\bmtp{\e}{\ep}} \\
&&\wedge&\multicolumn{3}{l}{\statictype{\t[2]}{\K}{\cdot}}
\\[1mm]\hline
\SP\}
\end{array}
\]
\normalsize





\subsection{Monotonic equivalent type generation}\label{typegen}

The \xt{typegen} function is used by the \xt{tmeet} function to generate the new classes
of the type produced by the meet operation.

\footnotesize
\[\begin{array}{l@{~}r@{}r@{~}r@{~}r@{~}rr}
\arrayrulecolor{white}
\typegen{\bmt}{\D} = \\
\SP \class~\D~\{
\\[1mm]
\SPP \Mdef\m\x\t\tp {{\MonCast\tp{\x}}} 
&
\All m \Mtype\m\t\tp\in\bmt
\\[1mm]\hline
\SPP \Mdef\f\x\t\t {\x}
&
\All f \Mtype\f\t\t\in\bmt
\\[1mm]\hline
\SPP \Mdefz\f\t{{\MonCast\t{\New\D{}}}}
&
 \All f \Mtype\f{}\t \in \bmt
\\[1mm]
\SP\}
\end{array}
\]
\normalsize




\subsection{Htype function}

The function \htype\a\S\s\K
returns the class of the object at address \a.  \htype\a\S\s\K is \C if \C =
\App\S\a or if $\a\not\in\S$ and \obj\C{\b\a}=\App\s\a.

\begin{mathpar}
\IRule{HT1}{
  \a \not\in \text{addr}(\S) \\
  \enfortype\C\cdot\K = \D\,\W\,\Kp
}{
  \htype\a\S{\sigma[\a \mapsto \C\{\ap\}]}\K = \D~\Kp
}

\IRule{HT2}{
  \S(\a) = \t
}{
  \htype{\a}{\S}{\sigma}\K = \t~\K
}
\end{mathpar}

\subsection{Lifting function}

\hrulefill
\begin{align*}
\W &::= \cdot \B \Map\W{\Bind\C\D}
\end{align*}
\begin{mathpar}
\IRule{ENT1}{ 
  \Class\C{\hspace{-0.3em}}{\Fdef\that\Cp ~ \b\md} \in \K \\ 
  \C \notin \text{dom}(\W) \\
  \D\text{ fresh} \\
  \Wp = \W\,\Bind\C\D \\
  \Kp = \K\,\Class\D{\hspace{-0.3em}}{\Fdef\that\Cp ~ \enformt{\b{\md}}{\Wp}{\K}} \\ 
}{
  \enfortype{\C}{\W}{\K} = \D\,\Wp\,\Kp
}

\IRule{ENT2}{ 
  \W(\C) = \D \\
}{
  \enfortype{\C}{\W}{\K} = \D\,\W\,\K
}

\IRule{ENT3}{ 
}{
  \enfortype{\any}{\W}{\K} = \any\,\W\,\K
}
\end{mathpar}
\\

\hrulefill

\begin{mathpar}
\IRule{ENMT1}{
  \md =  \Mdef\m\x\any\any {~\SubCast\any{\MonCast\tp{{[{(\MonCast\t\x)}/\x]\ep}}}~} \\
  \enfortype\t\W\K = \tpp\,\Wp\,\Kp \\
  \enfortype\tp\Wp\Kp = \tppp\,\Wpp\Kpp \\
  \mdpp = \Mdef\m\x\tpp\tppp {\MonCast\tppp\x} \\
  \enformt{\b\md}{\Wpp}{\Kpp} = \b\mddp \\
}{
  \enformt{\md\,\b\md}{\W}{\K} = \mdpp\,\b\mddp
}

\IRule{ENMT2}{
  \md = \Mdef\m\x\t\tp {\ep~}\\ 
  \enfortype\t\W\K = \tpp\,\Wp\,\Kp \\
  \enfortype\tp\Wp\Kp = \tppp\,\Wpp\Kpp \\  
  \mdpp =\Mdef\m\x\tpp\tppp {\MonCast\tppp\x}\\
  \enformt{\b\md}{\Wpp}{\Kpp} = \b\mddp \\
}{
  \enformt{\md\,\b\md}{\W}{\K} = \mdpp\,\b\mddp
}

\IRule{ENFS}{
  \md = \Mdef\f\x\any\any {\SubCast\any{\MonCast\tp{\Set{\Get\this\that}\f{\MonCast\t{\MonCast\tp\x}}}}} \\ 
  \enfortype\t\W\K = \tpp\,\Wp\,\Kp \\
  \enfortype\tp\Wp\Kp = \tppp\,\Wpp\Kpp \\   
  \mdpp = \Mdef\f\x\tpp\tppp {\MonCast\tppp\x} \\
  \enformt{\b\md}{\Wpp}{\Kpp} = \b\mddp \\
}{
  \enformt{\md\,\b\md}{\W}{\K} = \mdpp\,\b\mddp
}

\IRule{ENFG}{
  \md =  \Mdefz\f\any{\SubCast\any{\MonCast\t{\Get{\Get\this\that}\f}}} \\ 
  \enfortype\t\W\K = \tp\,\Wp\,\Kp \\
  \mdpp = \Mdefz\f\tp {\MonCast\tp{\Get{\Get\this\that}\f}} \\
  \enformt{\b\md}{\Wp}{\Kp} = \b\mddp \\
}{
  \enformt{\md\,\b\md}{\W}{\K} = \mdpp\,\b\mddp
}

\IRule{ENE}{
}{
  \enformt{\cdot}{\W}{\K} = \cdot
}
\end{mathpar}

\bibliographystyle{ACM-Reference-Format}
\bibliography{sample-bibliography}

\end{document}
