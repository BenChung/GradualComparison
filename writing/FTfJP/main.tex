\documentclass[sigconf]{acmart}

\usepackage{xspace,listings,url,framed,amssymb,colortbl,
            amsmath,mathpartir,hyperref,doi, rotating,
            stmaryrd, graphicx, tikz, colortbl, xparse, etoolbox, pgffor,booktabs} % double brackets llbracket
\input{macros}

% Copyright
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}

\lstdefinelanguage{JavaScript}{
  keywords={typeof,new,true,false,instanceof,catch,function,return,null, 
    catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{darkgray},
  ndkeywords={class,def,interface,export,boolean,throw,extends,implements,import,this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,  comment=[l]{//},  morecomment=[s]{/*}{*/},
  commentstyle=\color{gray}\ttfamily,  stringstyle=\color{gray}\ttfamily,
  morestring=[b]',  morestring=[b]",
  backgroundcolor=\color{vlightgray},
  aboveskip=\medskipamount, %0em,
  belowskip=\smallskipamount, %0em
  escapeinside={(*@}{@*)}
}
\lstset{
  language=JavaScript,  extendedchars=true,  basicstyle=\footnotesize\ttfamily,
  showstringspaces=false,   showspaces=false,  numberstyle=\small,
  numbersep=9pt,  tabsize=2, breaklines=true,  showtabs=false, captionpos=b
}

% DOI
\acmDOI{10.475/123_4}

% ISBN
\acmISBN{123-4567-24-567/08/06}

%Conference
\acmConference[FtFJP]{Submitted to FtFJP}{July 2018}{}
\acmYear{2018}
%\copyrightyear{2016}
%\acmArticle{4}
%\acmPrice{15.00}


\begin{document}
\title{Monotonic Gradual Typing in a Common Calculus}
\subtitle{}

\author{Benjamin Chung}
\affiliation{\institution{Northeastern University}}
\author{Jan Vitek}
\affiliation{\institution{Northeastern and CTU}}


\begin{abstract}
Gradual typing refers to the notion that programs can be incrementally
decorated with type annotations. Languages that support this approach to
software development allow for programs being in various state of
``typedness'' on a scale that ranges from entirely untyped to fully
statically typed. The intellectual challenge for language designers is to
assign meaning programs on that scale. The litterature in the field is rich
with a variety of proposals ranging from the laissez faire of optinal typing
to sound approaches that wrap all values in protective shells to ensure that
they behave as promised by their ascribed type. Each gradual type system
comes with tradeoffs. Some systems provide strong guarantees at the expense
of vastly degraded performance, others do not impact the running time of
programs but do little to pervent type errors. This paper looks at an
intriguing point the landscape: a variant of Python referred to as Monotonic
Reticulated Python. Our contribution is a semantics of the proposal as a
translation from a surface language down to a core calculus.
\end{abstract}

\definecolor{Gray}{gray}{0.9}

\definecolor{vlightgray}{gray}{0.93}

\maketitle

Gradual typing refers to a family of approaches that add types to untyped
programs, approaches which all solve the same problem in different ways.
Gradual typing allows programmers to assert types for untyped values, types
which (in a sound system) need to be checked dynamically. The pantheon of
gradual type systems arises from different mechanisms for checking the types
of untyped values.

Object-oriented languages pose a particular problem for gradual typing. It
is easy to check if a base value has a type, but problems arise from
higher-order behavior. In a functional language, this manifests when trying
to assert an arrow type on a lambda. Object-oriented languages have this
same problem -- trying to assert a typed method on an object with an untyped
version of the method -- but have additional complexity in the form of
subtyping.

\begin{figure}[h]
\begin{lstlisting}
class C { 
  f(x:*):* { x } 
  g(x:*):* { new C() }
}
class D { 
   f(x:D):D { x }
}
new D(<*>new C())
\end{lstlisting}
\caption{A gradually-typed program.}
\label{fig:simpleprog}
\end{figure}

Figure~\ref{fig:simpleprog} shows a simple example of a gradually typed
object-oriented program. In this program, the type \any indicates that a
variable is dynamic; thus it can hold a value of any class, and any method
can be invoked with that variable as a receiver returning a value of type
\any. Expression that use non-\any types are checked using a run-of-the-mill
static type system.


, which uses dynamic behavior to pass an instance
of class \C as one of type \D. \C has no guarantee to act like a \D, so
\D-ness must be enforced at runtime. However, how this enforcement happens
is unclear. The program could fail when the instance of \C is first passed,
fail if \f is called on \x, or not fail at all because the program never 
breaks the guarantee provided by the gradual type syste.

We examined four of these approaches to gradual typing in our paper [how do I
cite it? XXXX]. The approaches investigated in that paper were the optional,
transient, behavioral, and concrete semantics. We chose these semantics due to
their popularity and relative simplicity, but elided one, the monotonic
semantics, due its size and complexity. This paper places the monotonic
semantics into the same framework as our earlier work.

The problem the monotonic semantics sets out to solve is that in gradually
typed programs, typed mutable field access can be slow. Under the behavioral
semantics, which adds wrappers to enforce types, every typed field access on
an untyped object has to have a layer of indirection. Likewise, under the
transient semantics, every typed field access everywhere in the program is
protected with a cast, as the field's value could have been mutated by untyped
code. This can make typed code in a gradually typed language slow.

Suppose we have an object $\x = \a = \{ \f:\any = 3 \}$, then alias it as
$\xp = \SubCast{\{ \f:\xt{int} \}}\x$. Accessing $\xp.\f$ is not guaranteed
to be safe, even though \xp is fully typed. If we run \xt{\x.\f = "hello"} at
some point, then $\xp.\f$ is now ill-typed via the  reference. As mentioned
previously, both the transient and behavioral semantics deal with this by
checking the result of dereference in typed code, lazily enforcing the type.
Under the transient semantics, for example, the assignment to \x.\f will
succeed but the dereference from \xp.\f will fail. However, the monotonic
semantics takes the opposite approach.

The monotonic semantics is an \emph{eager} mechanism to enforce types. Under
the monotonic semantics, once a value in the heap is typed, it will always
remain of that type. In the example above, once we aliased \x as \xp, \xp's
type (e.g. that \f has type \xt{int}) will be enforced upon usages of \x. Now,
our assignment \xt{\x.\f = "hello"} will fail, because we are assigning a
value of improper type to the field \f of \a. In this manner, all statically
typed values under the monotonic semantics are known to have correct field
typing.

In this paper, we present a formalization of the monotonic semantics on our
framework for comparing gradual type systems. We use a common gradually-typed
source language and translate it to a common target language (called \kafka)
according to the monotonic semantics. We then use this formalization to
discuss the monotonic semantics's properties, and compare it to alternative
gradual type systems.

\section{Monotonic}

The idea behind the monotonic semantics was originally put forward by XXXX
Siek and Vitousek in DATE XXXX, with first application in their language
Reticulated Python. The same group then went on to implement the monotonic
semantics into their Grift implementation XXXX Cite Me XXX, allowing the
comparison of performance inherent to each gradual type system.

The idea behind the monotonic semantics is that types only ever get more
precise. This design gives rise to its name; types in a monotonic language's
heap monotonically get more precise. When a reference is cast to a more
precise type, that new type will get saved in the reference (and propagated to
whatever it refers to). If untyped code later tries to mutate the reference to
a new value that does not conform to the previously applied type, a type error
will occur. By locking in applied types forevermore, typed code under the
monotonic semantics can assume that mutable state will remain well typed.

In turn, the ability to rely on types on mutable state absolutely provides
several advantages over other gradual type systems. The monotonic system has
a soundness guarantee, unlike the optional semantics (which simply forgets
about all type annotations at runtime); monotonic languages can elide field
dereference guards needed by the transient semantics; do not need the wrappers
inserted by the behavioral semantics; and is far more flexible than the 
concrete semantics. Additional details about these other semantics can be found
in our XXXX ECOOP PAPER XXXX.

As a result, monotonic has the potential to provide substantial benefits to
the performance of gradually typed languages. Types are guaranteed, so they
can be relied upon for memory layout of objects. Types under the monotonic
semantics can be used to optimize away generic field accesses, and assignments
to typed fields from fully typed code do not need to be checked.

In the context of object orientation, monotonic's ability to protect mutable
state without the need for wrappers is a major advantage. Other gradual type
systems need guards, wrappers, or an incredibly strong notion of soundness
in order to guarantee safety of field access. The monotonic semantics, in 
contrast, prevents untyped code from assigning ill-typed values to previously
typed references, allowing unchecked dereferencing in typed code.

\section{Formalism}

We use the framework we set out in our earlier paper to provide a simple
presentation of the monotonic semantics in an object-oriented setting. Instead
of using formal languages specially crafted to support each semantics, we use
a common source and target language for every gradual typing semantics. The 
semantics is then encoded into the translation, allowing comparison of gradual 
type systems by examining their translation.

\paragraph{Source Language}

Our common source language is very similar to Featherweight Java, with a few
notable changes. This language extends the basic framework of FJ with a
dynamic type and a convertibility relation, allowing gradually typed programs
to be expressed. This same source language and source language type system
is shared between the translation presented here and the four in our main
paper,  allowing the same programs to be ran under all of our semantics. We
replicate the static semantics for the source language here, in figure~\ref{slts}.

Programs in the source language consist of a class table and an initial
expression. Classes consist of field and method definitions. Method
definitions have names, types for their single argument and return type, and
an expression. Expressions consist of variables, the self-reference \this,
field read and write \FRead\f and \FWrite\f\e, invocation \Call\e\m\e, and new
object creation \New\C{\e[1]..}. All operations conform to what they would do
in Featherweight Java, and the type system is straightforward. 




\begin{figure*}[!h]\begin{tabular}{@{}l@{~}l@{}l@{}l@{}l@{}l@{}l@{}l}
\e~::=~\x\B\this\B\FRead\f\B\FWrite\f\e\B\Call\e\m\e\B\New\C{\e[1]..}\\
\k~::=~ \Class \C {\fd[1]..}{\md[1]..} \qquad
\md~::=~\Mdef\m\x\t\t\e\qquad
\fd~::=~ \Fdef\f\t\qquad
\t~::=~ \any \B \C
\end{tabular}

\begin{mathpar}
\Rule{STG-VAR}{~\\\\ 
  \HasType \Env\x\t
}{
  \EnvTypeS \Env\K\x\t
}

\Rule{STG-GET}{
  \HasType \Env\this\C \\\\  \Fdef\f\t \in \App\K\C
}{
  \EnvTypeS \Env\K{\FRead\f}\t
}    

\Rule{STG-SET}{
  \HasType \Env\this\C \quad \Fdef\f\t \in \App\K\C \\\\
  \EnvTypeS \Env\K\e\tp \quad  \ConvertE\K{s}\tp\t
}{
  \EnvTypeS \Env\K{\FWrite\f\e}\t
}    

\Rule[width=15em]{STG-CALL}{
  \EnvTypeS \Env\K\e\any \\\\ \EnvTypeS \Env\K\ep\t 
}{
  \EnvTypeS \Env\K{\Call\e\m\ep}{\any}
}    

\Rule[width=15em]{STG-CALL}{
  \EnvTypeS \Env\K\e\C \quad \EnvTypeS \Env\K\ep\t \\\\
  \Mtype \m{\t[1]}{\t[2]}\in \App\K\C  \quad
  \ConvertE\K{s}\t{\t[1]}
}{
  \EnvTypeS \Env\K{\Call\e\m\ep}{\t[2]}
}   

\Rule{STG-NEW}{
  \Ftype{\f[1]}{\t[1]}.. \in \App\K\C \\\\
  \EnvTypeS \Env\K{\e[1]}{\tp[1]}..\quad \ConvertE\K{s}{\tp[1]}{\t[1]}..
}{
  \EnvTypeS \Env\K{\New\C{\e[1]..}}\C
}
\end{mathpar}

\vspace{-5mm}  
  
\begin{mathpar}
\IRule{SUB}{
   \SSub\emptyset\K\t\tp
}{
   \ConvertE\K{s}\t\tp
}
    
\IRule{TOA}{~ }{ \ConvertE\K{s}\t\any}
    
\IRule{ANYC}{~}{ \ConvertE\K{s}\any\t }
\end{mathpar}


\hrulefill
\caption{Surface language syntax and type system (extract).}\label{slts}
\end{figure*}

\begin{figure*}[!h]\hrulefill

\vspace{4mm}

\small\begin{tabular}{@{}lll}

\begin{minipage}{5.5cm}\begin{tabular}{@{}l@{~}l@{}l@{}l@{}l@{}l@{}l@{}l}
\e\hspace{.1cm} ::= & \hspace{.2cm} \x        
   &\B \this         
   &\B \that      
   &\B \FRead\f  \\   
   & &
   &\B \FWrite\f\e 
   &\B \KCall\e\m\e\t\t \\
   & &   
   &\B \New\C{\e[1]..}  
   &\B \DynCall\e\m\e \\
   & & & \multicolumn{3}{@{}l}{\B \a \B \FReadR\a\f \B \FWriteR\a\f\e} \\
   & & & \B \src{\MonCast\t\e}
\end{tabular}\end{minipage}&
\begin{minipage}{3.7cm}\begin{tabular}{l@{~}l@{}l@{}l}
  \k &::= \Class \C {\fd[1]..}{\md[1]..} \\
 \md &::= ~ \Mdef\m\x\t\t\e \\ 
 \fd &::= ~ \Fdef\f\t \\ 
  \t &::= ~ \any  \B   \C  \\ 
\end{tabular}\end{minipage} &
\begin{minipage}{5.5cm}

\begin{tabular}{llllllllllllllllll}
\EE &::=& ~ \FWriteR\a\f\EE   &\B  
        \KCall\EE\m\e\t\t  &\B\\
        &&\KCall\a\m{\EE}\t\t &\B
        \DynCall\EE\m\e   &\B\\
&       & \DynCall\a\m\EE   &\B
       \src{\MonCast\t\EE}  &\B\\
&&     \New\C{\a[1]..\,\EE\,\e[1]..} &\B 
      \EM{\square}
\end{tabular}
\end{minipage}
\end{tabular}


\begin{mathpar}
\IRule{KT-VAR}{
   ~\\\\
   ~\\\\
   \HasType \Env\x\t
 }{
   \EnvType \Env\s\K\x\t
}

\IRule{KT-SUB}{
  ~\\\\
  \EnvType \Env\s\K\e\tp \\\\
 \StrSub \cdot\K \tp \t
 }{
  \EnvType \Env\s\K\e\t 
}   

\IRule{KT-READ}{
  ~\\\\
  \HasType\Env\this\C \\\\
  \Fdef\f\t \in \App\K\C
}{
  \EnvType \Env\s\K{\FRead\f}\t
}  

\IRule{KT-REFREAD}{
  \s(\a) = \C\{..\} \\\\
  \Fdef\f\t \in \App\K\C
}{
  \EnvType \Env\s\K{\FReadR\a\f}\t
}  

\IRule{KT-WRITE}{
  \HasType\Env\this\C \\\\
  \Fdef\f\t \in \App\K\C \\\\
  \EnvType \Env\s\K\e\t
}{
  \EnvType \Env\s\K{\FWrite\f\e}\t
}    

\IRule[width=12em]{KT-REFWRITE}{
  \s(\a) = \C\{..\} \\\\
  \Fdef\f\t \in \App\K\C \\\\
  \EnvType \Env\s\K\e\t
}{
  \EnvType \Env\s\K{\FWriteR\a\f\e}\t
}  

\IRule[width=16em]{KT-CALL}{
  \EnvType \Env\s\K\e\C \\\\
  \EnvType \Env\s\K\ep\t \\\
  \Mtype\m\t\tp \in \App\K\C 
}{
  \EnvType \Env\s\K{\KCall\e\m\ep\t\tp}\tp
}    

\IRule{KT-DYNCALL}{
  ~\\\\
  \EnvType \Env\s\K\e\any \\\\
  \EnvType \Env\s\K\ep\any
}{
  \EnvType \Env\s\K{\DynCall\e\m\ep}\any
}    

\IRule[width=20em]{KT-NEW}{
  ~\\\\
  \EnvType \Env\s\K{\e[1]}{\t[1]}..\\\\
  \Class \C {\Fdef{\f[1]}{\t[1]}..}{\md[1]..} \in \K
}{
  \EnvType\Env\s\K{\New\C{\e[1]..}}\C
}

\src{
\IRule{KT-MONOCAST}{
  \EnvType \Env\s\K\e\tp
}{
  \EnvType \Env\s\K{\MonCast\t\e}\t
}
}

\IRule{KT-REFTYPE}{
  \s(\a) = \obj\C{\ap[1]..}
}{
  \EnvType \Env\s\K\a\C
}

\IRule{KT-REFANY}{
 }{
   \EnvType \Env\s\K\a\any
}
\end{mathpar}

\begin{minipage}{0.32\textwidth}
\begin{align*}
\TRG[M]{\x}\Env &= \x & \\
\TRG[M]{\Call{\e_1}\m{{\e_2}}}\Env &= \DynCall{\ep_1}\m{\ep_2} & \tag*{\IF\EM{\TypeCk{\K,\Env}\e\any
\AND \TRG[M]{\e_1}\Env = \ep_1}} \\ &\tag*{\EM{\wedge \TAG[M]{\e_2}\Env{\any} = \ep_2}}\\
\TRG[M]{\Call{\e_1}\m{{\e_2}}}\Env &= \KCall{\ep_1}\m{\ep_2}{\D[1]}{\D[2]} & \tag*{\IF\EM{\TypeCk{\K,\Env}\e\C
\AND\; \Mtype\m{\D[1]}{\D[2]}\In\App\K\C}}\\
\tag*{\EM{\AND \TRG[M]{\e_1}\Env = \ep_1 \wedge \TAG[M]{\e_2}\Env{\D[1]} = \ep_2}}\\
\TRG[M]{\New\C{{\e_1}...}}\Env &= \New\C{\ep_1...} & \tag*{\IF\EM{\Ftype{\f[1]}{\t[1]}\In\App\K\C
    \AND \ep[1] = \TAG[M]{\e[1]}\Env{\t[1]} ~..}}\\
\TAG[M]{\e}{\Env}\t &= \e' & \tag*{\IF\EM{\TypeCk{\K,\Env}\e\tp \AND \K\vdash\tp\Sub\t}}\\
\TAG[M]{\e}{\Env}\t &= \MonCast{\t}{\ep} & \tag*{\IF\EM{\TypeCk{\K,\Env}\e\tp \AND \K\vdash\tp\not\Sub\t}}
\end{align*}
\end{minipage}\hspace{1cm}
\begin{minipage}{0.45\textwidth}
\begin{tabbing}
  \K\HS \New\C{\a[1]..} \HS\= \s~ \HS \=\Red\HS \= \K \HS\= \ap \HS\= \sp\HS \= \WHERE\HS\= \fresh\ap \HS\HS\HS\HS\HS\HS\HS\=  \sp = {\Map\s{\Bind\ap{\obj\C{\a[1]..}}}}
\\
\K\HS \FReadR\a{\f[i]} \> \s           \>\Red\>     \K \>$\a[i]$ \> \s  \> \WHERE \>\App\s\a=\obj\C{\a[1],\ldots\a[i],\a[n]\ldots}
\\
\K\HS {\FWriteR\a{\f[i]}\ap} \> \s     \>\Red\>     \K \> \ap \> \sp \>  \WHERE \>\App\s\a=\obj\C{\a[1],\ldots\a[i],\a[n]\ldots} \HS  
\\ \> \> \> \> \> \> \> \sp = \Map\s{\Bind\a{\obj\C{\a[1],\ldots\ap,\a[n]\ldots}}}
\\
\K\HS{\KCall\a\m\ap\t\tp} \> \s      \>\Red\>     \K \>  \ep \> \s \> \WHERE\> \ep = {[\a/\this~{\ap/\x}]\e} \HS \\ \> \> \> \> \> \> \> \Mdef\m\x{\t_{1}}{\t_{2}}\e\In \App\K\C  \\ \> \> \> \> \> \> \>  \App\s\a=\obj\C{\a[1]..} \> \StrSub {\emptyset}\K\t {\t_{1}} \\ 
\> \> \> \> \> \> \> \StrSub {\emptyset}\K{\t_{2}} \tp
\\
 \K\HS {\DynCall\a\m\ap}\> \s        \>\Red\>    \K \> \ep \> \s \>  \WHERE\> \ep = {[\a/\this~{\ap/\x}]\e}\HS \\ \> \> \> \> \> \> \> \Mdef\m\x\any\any\e \In \App\K\C \\ \> \> \> \> \> \> \> \App\s\a=\obj\C{\a[1]..} 
\\
 \K\HS {\MonCast \t\a} \> \s         \>\Red\>   \Kp \> \ap \> \sp \> \WHERE\> \moncast \a\t\s\K \Kp\ap\sp    
\\
\K \HS \EM{\EE[\e]} \> \s            \>\Red\>   \Kp \> \EM{\EE[\ep]} \> \sp \> \WHERE \> \K~\e~\s \Red~\Kp~\ep~\sp
\end{tabbing}
\end{minipage}
\vspace{2mm}

\noindent\hrulefill\caption{\kafka Syntax.}\label{syn}
\end{figure*}


\begin{figure}[!h]

\medskip
\hrulefill
\caption{\kafka dynamic semantics.}\label{fig:semantics}
\end{figure}

\section{Complete translation for Monotonic}


\opdef{\EnvType\Env\s\K\e\t}{\e has type \t in environment \Env against heap \s and class table \K}
%\vspace{-2mm}

\subsection{Monotonic translation for bidirectional expressions}


\section{Generative Monotone Casts}

\begin{mathpar}
\IRule{CM}{
  \s(\a) = \C\{\ap\ldots\} \\
  \tmeet \C\t\cdot\K = \Cp~\Kp\\
  \sp = \s[\a \mapsto \Cp\{\ap\ldots\}]
}{
  \moncast \a\t\s\K \Kp \sp\\
}
\end{mathpar}
{Monotonic cast semantics}

\begin{align*}
\P &::= \cdot \B \P ~{{(\C,\D)}\mapsto\Cp}
\end{align*}
\begin{mathpar}
\IRule{TM1}{ }{\tmeet\C\any\P\K = \C\,\K}

\IRule{TM2}{ }{\tmeet\any\C\P\K = \C\,\K}

\IRule{TM3}{ }{\tmeet\t\t\P\K = \t\,\K}

\IRule{TM4}{
  \fresh\Cp\\
  (\C,\D) \not\in\P \\
  \Pp = \P~{{(\C,\D)}\mapsto\Cp} \\
  \mtype\C\K = {\mt..}\\
  \mtype\D\K = {\mtp..}\\
  \mmeet{\mt..}{\mtp..}\Pp\K = \mtpp..\,\Kp\\
  \Kpp = \Kp~\typegen{\mtpp..}\Cp\\
}{
    \tmeet\C\D\P\K = \Cp\,\Kpp
}

\IRule{TM5}{
    \P(\C,\D) = \Cp
}{
    \tmeet\C\D\P\K = \Cp\,\K
}
\end{mathpar}
{The \texttt{tmeet} function}

\subsection{Meet function}\label{monmeet}

The \texttt{mmeet} function is used by the \texttt{tmeet} functions to
perform the meet over the typing of each method within a class definition.
The \texttt{mmeet} function also takes four arguments, the method
signatures of the original class $\mt..$, the method signatures of the cast
class $\mtp..$, the environment $\P$, a class table $\K$, and outputs method
types $\mtpp..$ and a class table $\Kp$. \\

\hrulefill
\begin{mathpar}
\IRule{MM1}{
}{
  \mmeet{\mt ..}{\cdot}\Env\K =\mt.. ~\K
}

\IRule{MM2}{
}{
  \mmeet{\cdot}{\mt ..}\Env\K ={\mt ..} ~\K
}

\IRule{MM6}{
  \Mtype\m{\t_3}{\t_4} \in {\mt_2} \\
  \tmeet{\t_3}{\t_1}\Env\K = \t_5~\Kp \\
  \tmeet{\t_2}{\t_4}\Env\Kp = {\t_6}~{\Kpp} \\
  \mmeet{{\mt_1 ..}}{{\mt_2 ..}}\Env\Kp = {\mt_3 ..}~\Kpp
}{
  \mmeet{\Mtype\m{\t_1}{\t_2}~{\mt_1 ..}}{{\mt_2 ..}}\Env\K =\Mtype\n{\t_5}{\t_6} ~{\mt_3 ..} ~\Kpp
}
\end{mathpar}

\subsection{Monotonic class generation}\label{classgen}

The \xt{monWrap} function generates the wrapper for the monotonic translations,
when a monotonic cast is required.

\footnotesize
\[\begin{array}{l@{~}r@{}r@{~}r@{~}r@{~}rr}
\arrayrulecolor{white}
\classgen{\C, \md.., \mt.., \mtp.., \D, \K}= \\
\SP \class~\D~\{ \\
\SPP \Fdef\f\t & \All {{\f}\!:{\t} \in \text{fields}(\K,\C)}
\\[1mm]\hline
\SPP \Mdef\m\x\any\any {~\MonCast\any{\KCall\this\m{\MonCast{\t[1]}\x}{\t[1]}{\t[2]}}~}
&     \All \m \Mdef\m\x{\any}{\any}\e\in\md.. \\&\wedge\; \Mtype\m{\C_1}{\C_2}\in{\mtp..}
\\[1mm]\hline
\SPP \Mdef\m\x{\C_1}{\C_2} {\MonCast{\C_2}{[{(\MonCast{\any}\x)}/\x]\ep}~}
&     \All \m \Mdef\m\x{\any}{\any}\e\in\md.. \\&\wedge\; \Mtype\m{\C_1}{\C_2}\in\mtp.. 
\\[1mm]\hline
\SP\}
\end{array}
\]
\normalsize





\subsection{Monotonic equivalent type generation}\label{typegen}

The \xt{typegen} function is used by the \xt{tmeet} function to generate the new classes
of the type produced by the meet operation.

\footnotesize
\[\begin{array}{l@{~}r@{}r@{~}r@{~}r@{~}rr}
\arrayrulecolor{white}
\typegen{\mt..}{\D} = \\
\SP \class~\D~\{
\\[1mm]
\SPP \Mdef\m\x\t\tp {{\MonCast\tp{\x}}} 
&
\All m \Mtype\m\t\tp\in\mt..
\\[1mm]
\SP\}
\end{array}
\]
\normalsize

\bibliographystyle{ACM-Reference-Format}
\bibliography{sample-bibliography}

\end{document}
