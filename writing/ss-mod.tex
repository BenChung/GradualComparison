\documentclass{report}
\usepackage{mathpartir,amsmath,amssymb,xspace,listings,fullpage}
\begin{document}
\input{common}



Syntax:
\syntax{}

\begin{mathpar}
\inferrule*[right=SubRefl]{ }{ \t <: \t }

\inferrule*[right=SubClass]{\class~\C~\implements~\D}{ \xt{!C} <: \xt{!D} }

\inferrule*[right=SubWeak]{ \xt{!C} <: \xt{!D} }{ \C <: \xt{D}}

\inferrule*[right=SubInj]{ }{ \xt{!C} <: \C}
\end{mathpar}

Typing:

\begin{mathpar}

\TSub

\TVar 

\TInt

\TUApp

\TApp

\TIf

\TPlus

\TNew

\TCast

\inferrule*[right=TClass]{ 
  \bar{\MTYPE{\m'}{\bar{x:\t''}}{\t'} \in\D \implies \MTYPE{\m'}{\bar{x:\t''}}{\t'}\in\C }\\
  \bar{\G,\this:\C,\bar{x:\t''} \vdash e:\t'}
 }{
  \Gdash \CLASS \C{\bar\D}{\bar{\f:\t},\bar{\MDEF\m{\bar{x:\t''}}{\t'}e}}
  }
\end{mathpar}

\subsection{Cast Insertion}

\begin{mathpar}
\CICast

\CICall

\CIIf

\CIPlus

\CIVar

\CINew
\end{mathpar}


\section{Dynamic semantics:}



Reduction:

\begin{mathpar}
\inferrule*[right=EFrame]{ e,v \ereduce e',v'}{F[e],v \ereduce F[e'],v'}

\inferrule*[right=ENew]{
     \class \; \C  \{\bar{\f : \t}, \bar{ \m (\bar{x:\t}) : \t' = e}\} \\
     \s'=\s(a\is\{\bar{\f=v},\bar{ \m (\bar{x}) = e} \B \C\}) }{ \NEW \C {\bar v},\s \ereduce a,\s'}

\inferrule*[right=EInv]{a\is \{\ldots,\m(\bar x)=e, \ldots \B \t\}}{a.\m(\bar v),\s \ereduce [a/\xt{this}][\bar{v/x}]e,\s}

\inferrule*[right=EField]{ \s[a\is\{\ldots,\f =v,\ldots\B\t\}] }{a.\f,\s \ereduce v,\s}

\inferrule*[right=EAssign]{ \s' = \s[a\is \{\ldots,\f =v,\ldots\B\t\}] }{a.\f = v,\s \ereduce v,\s'}

\inferrule*[right=EIfZ]{ }{ \ifthenelse{\intv{0}}{e_1}{e_2},\s \ereduce e_1,\s }

\inferrule*[right=EIfNZ]{n\neq 0}{ \ifthenelse{\intv{n}}{e_1}{e_2},\s \ereduce e_2,\s }

\inferrule*[right=EPlus]{ n_1 + n_2 = n_3 }{ \intv{n_1} + \intv{n_2},\s \ereduce \intv{n_3},\s}

\inferrule*[right=ECast]{ \s' = \text{cast}(\s, v, \t) }{ \cast{\t}v,\s \ereduce v,\s'}
\end{mathpar}

\subsection{Cast reduction}

\begin{lstlisting}[escapeinside={(*}{*)}]
cast((*$\sigma, v, \t$*))
  (*$\sigma$*) iff type((*$v$*),(*$\sigma$*)) = type((*$v$*),(*$\sigma$*)) (*$\sqcap$*) (*$\t$*)
  (*$\sigma_{n+1}[a\is O]$*) iff (*$v = a$*)
    (*$\sigma(a) = \left.\left<v_1,\ldots,v_N \right|_\t^C\right>$*)
    (*$\t'' = \t \coerce \t \sqcap \t'$*)
    (*$\sigma_2 = $*)cast (*$(\sigma, v_1,$*)ftype((*$\t''$, 1))*)
    (*$\vdots$*)
    (*$\sigma_{n+1} = $*)cast (*$(\sigma_n, v_n,$*)ftype((*$\t''$, n))*)
\end{lstlisting}

\subsection{Meet}
\begin{mathpar}
\inferrule*[]{}{\t \sqcap \t = \t}

\inferrule*[]{}{\t \sqcap \any = \t}

\inferrule*[]{}{\any \sqcap \t = \t}

\inferrule*[]{}{\{\bar{\f :\t_1}, \bar{\m (\bar{\xt{p}:\t_1''}):\t_1'} \}\sqcap \{\bar{\f :\t_2}, \bar{\m (\bar{\xt{p}:\t_2''}):\t_2'} \} = \{\bar{\f :\t_2 \sqcap \t_2}, \bar{\m (\bar{\xt{p}:\t_1'' \sqcap \t_2''}):\t_1' \sqcap \t_2'} \}}
\end{mathpar}
\end{document}
