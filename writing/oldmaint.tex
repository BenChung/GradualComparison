\documentclass{sigplanconf}
\usepackage{xspace,hyperref,times,amsmath,xspace,listings,url,subfigure, framed}
\usepackage{graphicx,wrapfig,array,multirow,mathpartir,amsmath,amssymb}

\newcommand{\doi}[1]{doi:~\href{http://dx.doi.org/#1}{\Hurl{#1}}}
 \hypersetup{colorlinks=true,
   linkcolor=black,  citecolor=black,filecolor=magenta, urlcolor=black,
   pdftitle={R}, pdfauthor={Morandat Hill Osvald Vitek},
   pdfkeywords={Dynamic Languages, R, Reflection, Dynamic Analysis}}

\newcommand{\rl}[1]{{{\small{[{\sc #1}]}}}\xspace}
\newcommand{\lang}[1]{#1}% {\sf\scshape#1}\xspace}
\newcommand{\JAVA}{\lang{Java}\xspace}
\newcommand{\CommonLisp}{\lang{CommonLisp}\xspace}
\newcommand{\Java}{\lang{Java}\xspace}
\newcommand{\Scheme}{\lang{Scheme}\xspace}
\newcommand{\JavaScript}{\lang{Java\-Script}\xspace}
\newcommand{\Python}{\lang{Python}\xspace}
\newcommand{\Ruby}{\lang{Ruby}\xspace}
\newcommand{\Groovy}{\lang{Groovy}\xspace}

\newcommand{\NOTE}[3][NOTE]{\marginpar{\textcolor{#2}{\textbf{#1:}\scriptsize\sf#3}}}
\newcommand{\TODO}[2][Unassigned]{\NOTE[#1]{black}{#2}}
\newcommand{\FM}[1]{\NOTE[FM]{blue}{#1}}
\newcommand{\BH}[1]{\NOTE[BH]{magenta}{#1}}
\newcommand{\JV}[1]{\NOTE[JV]{red}{#1}}
\newcommand{\PROOF}[1]{#1}

\newcommand{\NUM}[2][]{#2#1\xspace}
\newcommand{\PC}[1]{#1\%\xspace}

\def\NEEDNUMBER{XXX\xspace}
\def\UrlFont{\fontfamily{cmtt}\selectfont}
\lstset{tabsize=2,columns=flexible,%
	basicstyle=\small\ttfamily,keywordstyle=\bfseries,%
	commentstyle=\rmfamily\itshape,indexstyle=[1]\indexlst,%
	showstringspaces=false,%
	lineskip=1pt,
	showspaces=false,belowcaptionskip=\baselineskip,framexleftmargin=5mm,%
	texcl=true,xleftmargin=15pt, % make room for line numbers
	breaklines=true,
	breakatwhitespace=true,
	escapeinside={(*}{*)},
}
\newcommand{\code}[1]{\lstinline[keywordstyle=]!#1!\xspace}
\newcommand{\etal}{{\em et al.}}
\def\cross{\ding{55}}\def\naive{na\"\i ve }
\newcommand{\app}[1]{{\small\textsf{#1}}}
\newcommand{\IGNORE}[1]{}\newcommand{\hide}[1]{}
\newcommand{\Section}[1]{Sect.~\ref{#1}\xspace}
\newcommand{\Figure}[1]{Fig.~\ref{#1}\xspace}
\newcommand{\figref}[1]{Fig.~\ref{fig:#1}\xspace}
\newcommand{\tabref}[1]{Table~\ref{tab:#1}\xspace}
\newcommand{\kewif}{\texttt{\textbf{if}}}
\newcommand{\kewthen}{\texttt{\textbf{then}}}
\newcommand{\kewelse}{\texttt{\textbf{else}}}
\newcommand{\kewnew}{\texttt{\textbf{new}}}
\newcommand{\kewclass}{\texttt{\textbf{class}}}
\newcommand{\kewimplements}{\texttt{\textbf{implements}}}
\newcommand{\ifabs}[3]{\kewif \; #1 \;\kewthen\; #2 \;\kewelse\; #3}
\newcommand{\opplus}[2]{#1 + #2}
\newcommand{\newclass}[2]{\kewnew\;\texttt{#1}(#2)}
\newcommand{\strt}{\texttt{str}}
\newcommand{\intt}{\texttt{int}}
\newcommand{\anyt}{\texttt{any}}
\newcommand{\vbar}{\;|\;}
\newcommand{\spec}{\vartriangleright}

\newcommand{\M}[1]{\ensuremath{#1}\xspace}
\newcommand{\xt}[1]{\sf{#1}}
\newcommand{\bt}[1]{\xt{\bf #1}}

\newcommand{\class}{\M{\bt{class}}}
\newcommand{\G}{\Gamma}
\renewcommand{\int}{\xt{int}}
\newcommand{\coerce}{\Rightarrow} %% arrow used in coercions
\newcommand{\any}{\M{\star}}
\newcommand{\this}{\M{\xt{this}}}
\newcommand{\ifthenelse}[3]{\M{\bt{if}\;#1\;#2\;#3}}
\newcommand{\cast}[1]{\M{\langle #1\rangle}}
\newcommand{\scast}[1]{\M{\{\!#1\!\}}}
\newcommand{\creduce}{\longrightarrow_{cr}}  %% reduction
\newcommand{\ereduce}{\longrightarrow_{e}}   %%  reduction
\newcommand{\stepsto}{\longrightarrow}        %% reduction
\newcommand{\intv}[1]{\xt{int}[#1]}
\newcommand{\strv}[1]{\xt{str}[#1]}
\newcommand{\tlate}{\rightsquigarrow}
\newcommand{\cicast}{\hookrightarrow}
\newcommand{\CICAST}[3]{\Gdash #1\cicast #3 \Leftarrow #2 }
\newcommand{\s}{\sigma}
\renewcommand{\sc}{\mu}
\renewcommand{\t}{\M{\xt{t}}}
\newcommand{\B}{\M{~|~}}
\newcommand{\new}{\M{\bt{new}}}
\newcommand{\NEW}[2]{\M{\new\;#1(#2)}}
\newcommand{\CALL}[3]{\M{#1.#2(#3)}}
\renewcommand{\bar}[1]{\M{\overline{ #1} }}
\newcommand{\m}{\M{\xt{m}}}
\newcommand{\e}{\M{\xt{e}}}
\newcommand{\n}{\M{\xt{n}}}
\renewcommand{\d}{\M{\xt{d}}}
\renewcommand{\r}{\M{\xt{r}}}
\newcommand{\f}{\M{\xt{f}}}
\newcommand{\fb}{\M{\xt{f!}}}
\newcommand{\x}{\M{\xt{x}}}
\newcommand{\C}{\M{\xt{C}}}
\newcommand{\D}{\M{\xt{D}}}
\newcommand{\err}{\M{\bt{err}}}
\renewcommand{\d}{\M{\xt{d}}}
\newcommand{\is}{\mapsto}
\newcommand{\cl}{\M{\xt{c}}}
\newcommand{\implements}{\M{\xt{implements}}}
\newcommand{\CLASS}[3]{ \M{\bt{class}\;#1\;\{ #3 \}}} 
\newcommand{\MDEF}[4] {\NT{#1(#2)}{#3} = #4}
\newcommand{\MTYPE}[3] {\NT{#1(#2)}{#3}}
\newcommand{\MVAL}[3] { #1( #2 ) = #3}
\newcommand{\Gdash}{\G\vdash}
\renewcommand{\TirNameStyle}[1]{\footnotesize\textsc{#1}}
\renewcommand{\S}{\Sigma}
\newcommand{\GSdash}{\S;\G\vdash}
\lstset{
    escapeinside={(*@}{@*)},       % if you want to add LaTeX within your code
}
\newcommand{\NT}[2]{#1\!: #2}

\newcommand{\opdef}[2]{\framebox[1.1\width]{#1} ~ #2\\}

\input{common}

\begin{document}
\title{Designing Gradual Types for Objects} 
\authorinfo{Benjamin Chung, Jan Vitek}{Northeastern University}{}
\maketitle

\conferenceinfo{CONF 'yy}{Month d--d, 20yy, City, ST, Country}
\copyrightyear{20yy}
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm}
\copyrightdoi{nnnnnnn.nnnnnnn}

\begin{abstract}
The popularity of dynamically typed languages has given rise to a cottage
industry of incremental type systems. These type systems allow developpers
to annotate their code with types and to feel better about the correctness
of their code.  The exact properties that these incremental type systems are
able to guarantee vary greatly from one language to another. This paper
compares some of the main design choices by embedding them into one common
core calculus representative of dynamic object-oriented languages such as
Python, TypeScript or Ruby.
\end{abstract} 

\section{Introduction}

The fundamental property a sound type system provides is the guarantee that an 
expression such as 
\begin{lstlisting}
    x = y.m(z);
\end{lstlisting}
will not ``go wrong''. If the expression passes the typechecker and the
variable \code{x} is declared to be of some type \code{T}, setting aside
issues related to null pointers and non-termination, the result of
\code{m()} will be of type \code{T}.  This is not the case in a dynamic
language where the receiver \code{y} may lack the requested method, or may
expect an argument of a different type, or may return a value that does not
belong to type \code{T}.

For any dynamic language, from the early days of Lisp to more recent times
with JavaScript, there have been attempts to add annotations to document
programmer expectations about the nature of values flowing through their
code.  The motivation for burdening the language with these extra
annotations have been either to provide hints for a just-in-time compiler or
to help programmers catch errors early.

\newcommand{\Opt}[1]{#1$^{?}$\xspace}
\newcommand{\Con}[1]{#1$^{!}$\xspace}
\newcommand{\Pro}[1]{#1$^{()}$\xspace}
\newcommand{\dyn}{$\star$}

In the last decade, the design space for these incremental annotations seems
to have stabilized around three alternatives.  A number of systems offer
\emph{optional types}, \Opt{T},
\cite{PluggableTypes,Bracha93,typescript13,oopsla09} which provide local
guarantees but do not prevent type errors at call boundaries. Other systems
rely on \emph{promised types}, \Pro{T}, these type annotations are
associated to the values that flow through the program and represent a
promise that the value will either behave as if it was of that type, or that
type error will be emitted~\cite{siek14,tf-popl08}.  Lastly, some systems
offer \emph{concrete types} which provide the traditional soundness
guarantees one would expect in a statically typed
language~\cite{thorn,stongscript,csharp}. In addition all dynamic languages
have the type dyn (\dyn) as the default type for all dynamically typed
variables.

The design space of incremental type system is an interesting one as there
are seemingly important trade-offs to be made in three different dimensions:
expressiveness, assurance and performance.  By expressiveness, we mean how
much of the legacy code base can be typed (and at what cost in terms of
changes to the original programs).  By assurance, we mean what kinds of
guarantees does the type system give to programmers. At its weakest, the
type system can be little more than a machine-checked documentation, and at
its strongest it can be equivalent to a sound statically typed language.
Performance here refers to the additional runtime overheads that are caused
by the extra checks that the language must perform to provide the
aforementioned guarantees.

\newcommand{\name}{{\sf Gool}\xspace}

This paper elucidates the difference between different designs by setting
them all in a common context. We have picked a simple class based
object-oriented language, representative of the likes of Python, Ruby,
TypeScript. Our core calculus, named \name for Gradual Object-oriented
Language, is stateful, as mutation introduces additional challenges. \name
is agnostic as to the nature of the subtyping relation (structural or
nominal) as this seems to be an orthogonal design choice.

\section{Related Work}

Typescript~\cite{typescript13} is an extension of Javascript, enabling existing 
Javascript code to be typed without substantial changes. In order to do so, 
Typescript uses an optional type system, only providing type guarantees within 
local code, not across call boundaries. This approach eases the transition from
Javascript to typed code, but the guarantees provided are very weak, only 
ensuring type saftey in local contexts, restricting optimization as well as
limiting the information provided by a type signature.

The example of a concrete type sysetm we are considering in this work is
Strongscript~\cite{stongscript}. Strongscript builds on lambda JS and 
Typescript, strengthening the guarantees provided in the latter by providing
\emph{concrete} types, represented by an excalmation mark. Within Strongscript,
concrete types impose guarantess about the runtime values that they represent, 
a stronger guarantee than that provided by Typescript, while still allowing
programmers the flexibility of the Typescript approach, though with fewer
guarantees.

Another approach is that taken by~\cite{seik-monotonic} (Seik Monotonic)
This approach presents a system that takes a \emph{promised type} approach.
Its novelty comes from a new approach to avoiding expensive and complex
wrappers. Instead of ensuring that the type of references remain consistent
by adding a wrapper, this approach works by ensuring that the type of values in
the heap only get \emph{less} generic.

Within this approach, references that were well-typed previously will always
remain well-typed, as the new type is strictly less generic than the one that
it had at the time that the reference was checked. By doing this, the monotonic
approach can avoid many of the expensive checks that wrapper approaches incur, 
while still providing similar functionality. However, this approach is less
generic than wrapper-based systems, as the monotonic constraint is much stronger
than the more usual well-typed one.

\section{Common Core Calculus}

A common core calculus is used to compare the various gradual type
systems. This common core is an imperative object-based system with
structural subtyping.  Figure~\ref{syn} summarize the syntax of this small
language where \x ranges over variables, \f ranges over field names, \m can
be either a plain method name \d, a field getter \f, or a field setter \fb,
\C and \D range over class names. We use the overbad notation to denote a
possibly empty sequence. In the common core, a class is defined as by a set
of fields, \bar\f, with distinct names and a set of method definitions,
\bar\m. An instance of class is constructed by the expression \NEW\C{\bar\e}
where each argument is used to initialize the corresponding field. Fields
are encapsulated and can only be accessed and updated in the corresponding
getter and setter from the \this variable.  Expressions include variable
access, field access and update, method invocation, object creation, and
type casts.

\begin{figure}[!h]
\begin{minipage}{3cm}\begin{tabular}{ll}
\e &::=  \x \\
   &\B \e.\f \\
   &\B \e.\f=\e\\
   &\B \CALL\e\m\e \\
   &\B \NEW\C{\bar{\e}}\\
   &\B \cast{\t}\e \\
\end{tabular}\end{minipage}\begin{minipage}{3cm}\begin{tabular}{ll}
\cl &::= \\
  &\CLASS \C {\bar\D}{\bar{\NT\f\t} ~~ \bar{\MDEF\m{\NT\x\t}\t\e}}\\
\\
\t &::= ~ \any \\
   &\B \{ \bar{\NT{\m(\t)}\t}\}\\
\\
\end{tabular}\end{minipage}
\caption{Abstract Syntax for the Core Calculus}\label{syn}
\end{figure}

Our types are structural and only account for the methods in an object's
interface. For type annotations, we use the name of classes as shorthand for
the set of methods defined in the class.



\section{Examples}

\newcommand{\tp}[1]{\M{\t_{#1}}}
\renewcommand{\mp}[1]{\M{\m_{#1}}}

\begin{figure}
\opdef{$\tp 1 <: \tp 2 $}{\tp 1 is a subtype of \tp 2}
\begin{mathpar}
\inferrule*[lab=SWidth]{
}{
\{\bar{ \NT{\mp 1(\tp 1)}{\tp 2}}~\bar{ \NT{\mp 2(\tp 3)}{\tp 4}}\}
 <: \{\bar{ \NT{\mp 1(\tp 1)}{\tp 2}}\}
}

\inferrule*[lab=SDepth]{
	\bar{\t_2 <: \t_1} \\
	\bar{\t_1' <: \t_2'}
}{\{\bar{\m(\bar{\t_1''}):\t_1'}\}<: \{\bar{\m(\bar{\t_2''}):\t_2'}\}}

\inferrule*[lab=STrans]{
  \C <: \xt{D} \\ \xt{D} <: \xt{E}
}{\C <: \xt{E}}
\end{mathpar}
\opdef{$\S;\Gamma\vdash e : \t$}{$e$ has type $\t$ in context $\G$ with heap $\S$}
\begin{mathpar}
\TVar

\TRef

\TSub

\TApp

\TNew

\TCast
\end{mathpar}
\opdef{$\Gdash e \tlate e' : \t$}{$e$ translates to $e'$ producing type $\t$ in context $\G$}
\opdef{$\CICAST{e}{\t}{e'}$}{$e$ translates to $e'$ ensuring type $\t$ in context $\G$}
\begin{mathpar}
\CICast

\CICallAny

\CICall

\CIIf

\CIPlus

\CIVar

\CINew
\end{mathpar}
\caption{Common Statics}
\end{figure}


\begin{figure}
\opdef{$e,\s \ereduce e',\s'$}{$e$ with heap $\s$ evaluates to $r$ and $\s$ in one step}
\begin{mathpar}
\EFrame

\inferrule*[lab=EFrameError]{ e,\s \ereduce \err,\s'}{F[e],\s \ereduce \err,\s'}

\ENew

\EInv

\EField

\EAssign

\EIfZ

\EIfNZ

\EPlus

\ECastInt

\ECastAny

\inferrule*[lab=ECastError]{ }{ \cast{\t}e,\s \ereduce \err,\s}
\end{mathpar}
\caption{Common Dynamics}
\end{figure}

\begin{figure}

\begin{mathpar}
\inferrule*[lab=WFField]{\G \vdash \t}{\G\vdash\f}

\inferrule*[lab=WFMeth]{\G \vdash \t \\ \bar{\G \vdash \t'} \\ \G,\this:this(\G),\bar{x:\t'} \vdash e : \t}{\G \vdash \m(\bar{x:\t'}):\t = e}

\inferrule*[lab=WFSelfGet]{\f \in fields(\G)}{\G \vdash \f():\t = \xt{this}.\f}

\inferrule*[lab=WFSelfSet]{\f \in fields(\G)}{\G \vdash \f!(\xt{x}:\t):\t = (\xt{this}.\f=\xt{x})}
\end{mathpar}
\caption{Class well-formedness}
\end{figure}


\section{Monotonic Semantics}

\begin{figure}
\opdef{$\tau \sim \tau'$}{$\tau$ is compatible with $\tau'$}
\begin{mathpar}
\inferrule*[lab=CNSym]{ }{\tau \sim \tau}

\inferrule*[lab=CNCons1]{ }{\any \sim \tau}

\inferrule*[lab=CNCons2]{ }{\tau \sim \any}

\inferrule*[lab=CNSub1]{
  \bar{\t_1 \sim \t_2}\\
  \bar{\t_2' \sim \t_2'}\\
  \bar{\t_2'' \sim \t_2''}}{\{\bar{\f_1:\t_1},\bar{\m_1(\t_1''):\t_1'}\} \sim \{\bar{\f_2:\t_2},\bar{\m_2(\t_2''):\t_2'}\}}
\end{mathpar}
\opdef{$\tau \sim \tau'$}{$\tau$ is subtype compatible with $\tau'$}
\begin{mathpar}
\inferrule*[lab=CSSub]{\C <: \xt{D}}{ \C \lesssim \xt{D}}

\inferrule*[lab=CSCons]{\tau \sim \tau'}{\tau \lesssim \tau'}

\inferrule*[lab=CSTrans]{\tau_1 \lesssim \tau_2 \\ \tau_2 \lesssim \tau_3}{\tau_1 \lesssim \tau_3}
\end{mathpar}
\caption{Monotonic operators}
\end{figure}


\begin{figure}
\opdef{$\Gamma\vdash e : \t$}{$e$ has type $\t$ in context $\G$}
\begin{mathpar}
\inferrule*[lab=TClass]{ 
  \bar{\G \vdash \f : \t}\\
  \bar{\G \vdash \MTYPE{\m}{\bar{x:\t''}}{\t'} = e} \\ 
  \f \in \xt{D} \implies \f \in \C\\
  \MTYPE{d}{\bar{x:\t''}}{\t'}\in \xt{D} \implies \MTYPE{d}{\bar{x:\t''}}{\t'} \in \C\\
 }{
  \Gdash \CLASS \C{\xt{D}}{\bar{\f},\bar{\MDEF d{\bar{x:\t''}}{\t'}e}}
  }
\end{mathpar}

\opdef{$\CICAST{e}{\t}{e'}$}{$e$ translates to $e'$ ensuring type $\t$ in context $\G$}
\begin{mathpar}
\inferrule*[lab=CIIDown]{\Gdash e \tlate e' : \t' \\ \t <: \t'}{\CICAST{e}{\t}{\cast{\t'}e'}}

\inferrule*[lab=CIIUp]{\Gdash e \tlate e' : \t' \\ \t' <: \t}{\CICAST{e}{\t}{e'}}

\inferrule*[lab=CIICons]{\Gdash e \tlate e' : \t' \\ \t' \lesssim \t \\ \t \neq \t' }{\CICAST{e}{\t}{\cast{\t}e'}}

\inferrule*[lab=CIIId]{\Gdash e \tlate e' : \t}{\CICAST{e}{\t}{e'}}
\end{mathpar}
\opdef{$e,\s \ereduce e',\s'$}{$e$ with heap $\s$ evaluates to $e'$ and $\s$ in one step}
\begin{mathpar}
\inferrule*[lab=ECast]{ \s' = \text{cast}(\s, v, \t) }{ \cast{\t}a,\s \ereduce a,\s'}
\end{mathpar}
\caption{Evaluation rules for the monotonic semantics}
\end{figure}


\begin{figure}
\opdef{$\t_1 \spec \t_2 = \t_3$}{$\tau_1$ specialized with $\tau_2$ produces type $\tau_3$}
\begin{mathpar}
\inferrule*[]{}{\t \spec \t = \t}

\inferrule*[]{}{\t \spec \any = \t}

\inferrule*[]{}{\any \spec \t = \t}

\inferrule*[]{
	\bar{\t_1 \spec \t_2 = \t_3} \\ 
	\bar{\t_1' \spec \t_2' = \t_3'} \\ 
	\bar{\t_1'' \spec \t_2'' = \t_3''}}{
	\{\bar{\f:\t_1},\bar{\f'}, \bar{\m(\bar{\t_1'}):\t_1},\bar{\m'}\} \spec \{\bar{\f:\t_2},\bar{\m(\bar{\t_2''}):\t_2'}\} = \\
	\{\bar{\f:\t_3},\bar{\f'},\bar{\m(\bar{\t_3''}):\t_3'},\bar{\m'}\}}
\end{mathpar}
\opdef{$\sigma' = \text{cast}(\s, v, \t)$}{Casting $v$ in $\s$ to type $\t$ produces heap $\s'$}
\begin{mathpar}
\inferrule*[lab=CClass]{\s[a \is \{\bar{\f = v},\bar{\f() = \xt{this}.\f},\bar{d(\bar{x}) = e},\bar{d'} \B \t\}] \\ 
\t \neq \t \spec \t' \\ 
\bar{d(\bar{\t_a}):\t_r} \in \t \spec \t'\\ \bar{\f():\t_f} \in \t \spec \t' \\
\s' = \s[a \is \\\{\bar{\f = v},\bar{\f():\t_f = \xt{this}.\f},\bar{d(\bar{x})=\cast{\t_r}\xt{this}.\m'(\bar{\cast{\t_a}x})},\\\bar{d'} \B \t \spec \t'\}]\\
\f:\t'' \in \t\spec \t' \implies \sigma'' = \text{cast}(\s', v, \t'')}{\text{cast}(\s, a, \t') = \s''}

\inferrule*[lab=CCycle]{\s[a \is \{\bar{\f = v} \B \C\}] \\ \C = \C \spec \xt{D}}{\text{cast}(\s, a, \xt{D}) = \s}

\inferrule*[lab=CInt]{ }{\text{cast}(\s,n,\xt{\int}) = \s}

\inferrule*[lab=CSub]{\s[a \is \{\bar{\f = v} \B \C\}]}{\text{cast}(\s, a, \C) = \s}
\end{mathpar}
\caption{Casting in the monotonic system}
\end{figure}

Define $types(C) = \{A_1,\ldots,A_n\}$ such that 

$classMeet(classMeet(A_1,A_2)\ldots,A_n) = C$

Define $gen(C, B) = classMeet(C,B)$

We apply $classMethod(\m)$ to every method $\m$ in every class $\C$.

classMeet is applied to every string of classes $C_1,\ldots,C_n$ where $C_1 \lesssim C_i$ for $i=2,\ldots,n$. Then, we apply wrapMethods to all classes.

\section{Wrapper Semantics}


\begin{figure}
\opdef{$\Gamma\vdash e : \t$}{$e$ has type $\t$ in context $\G$}
\begin{mathpar}

\inferrule*[lab=TNew]{
  \bar{\Gdash e:\t} \\ 
  \{\ldots \bar{\f} \ldots\} = fields(\C)\\
  typed(\C)
}{
  \Gdash \NEW \C{\bar e}:\C
}

\inferrule*[lab=TTypedClass]{ 
  {\bar{\Gdash \f}}\\
  {\bar{\Gdash \MDEF\m{\bar{x:\t''}}{\t'}e}}
 }{
  \Gdash \CLASS \C{\bar\D}{\bar{\f},\bar{\MDEF\m{\bar{x:\t''}}{\t'}e}}
  }  

\inferrule*[lab=TUntypedClass]{ 
 }{
  \Gdash \CLASS \C{\bar\D}{\bar{\f:\any},\bar{\MDEF\m{\bar{x:\any}}{\any}e}}
  } 
\end{mathpar}
\opdef{$\CICAST{e}{\t}{e'}$}{$e$ translates to $e'$ ensuring type $\t$ in context $\G$}
\begin{mathpar}
\inferrule*[lab=CIIUni]{ }{\CICAST{e}{\t}{e}}
\end{mathpar}
\opdef{$\CICAST{e}{\t}{e'}$}{$e$ translates to $e'$ producing type $\t$ in context $\G$}
\begin{mathpar}
\inferrule*[lab=CTypedClass]{typed(\C)}{\Gdash \NEW \C {\bar v} \tlate \cast{\C}\NEW\C{\bar v} : \any}

\inferrule*[lab=CUntypedClass]{ }{\Gdash \NEW \C {\bar v} \tlate \NEW\C{\bar v} : \any}
\end{mathpar}
\caption{Analytic cast insertion for the wrapper semantics}
\end{figure}


\begin{figure}
\opdef{$\sigma' = \text{cast}(\s, v, \t)$}{Casting $v$ in $\s$ to type $\t$ produces heap $\s'$}
\begin{mathpar}
\inferrule*[lab=ECastRef]{
\s[a \is \{\ldots\B \t'\}] \\
\bar{p(\bar{x:\t_a}):\t_r \in \t \wedge p \in \t'} \\
\s' = \s[a' \is \{\xt{orig} = a, \bar{p(\bar{x}) = \cast{\t_r}\xt{this.orig.}p(\bar{\cast{\t_a}x})} \B \t'\}] }{ \cast{\t}a,\s \ereduce a',\s'}
\end{mathpar}
\caption{Evaluation for the wrapper semantics}
\end{figure}

\section{Optional Semantics}

\begin{figure}

\begin{align*}
b &::= \int \B \{\bar{\f:\t}, \bar{p(\bar{\t}:\t}\}\\
\t &::= \any \B b \B !b\
\end{align*}
\opdef{$\t <: \t'$}{$\t$ is a subtype of $\t'$}
\begin{mathpar}
\inferrule*[lab=SRefl]{ }{ \t <: \t }

\inferrule*[lab=SWidth]{
}{!\{\bar{\m(\bar{\t_1''}):\t_1'},\bar{\m'(\bar{\t_2''}):\t_2'}\}<: !\{\bar{\m(\bar{\t_1''}):\t_1'}\}}

\inferrule*[lab=SDepth]{
	\bar{\t_2 <: \t_1} \\
	\bar{\t_1' <: \t_2'}
}{!\{\bar{\m(\bar{\t_1''}):\t_1'}\}<: !\{\bar{\m(\bar{\t_2''}):\t_2'}\}}

\inferrule*[lab=SubWeak]{ !b <: !b' }{ b <: b' }

\inferrule*[lab=SubInj]{ }{ !b <: b}
\end{mathpar}
\opdef{$\Gamma\vdash e : \t$}{$e$ has type $\t$ in context $\G$}
\begin{mathpar}
\inferrule*[lab=TCInj]{\Gamma \vdash e : \tau' \\ \tau' = \any \vee \tau = \any \vee \tau' <: \tau }{ \Gamma \vdash e : \tau}

\inferrule*[right=TClass]{ 
  \bar{\G,\this:\{\bar{\f:\t}, \bar{p(\bar{\t''}):\t'}\},\bar{x:\t''} \vdash e:\t'}
 }{
  \Gdash \CLASS \C{\bar\D}{\bar{\f:\t},\bar{\MDEF p {\bar{x:\t''}}{\t'}e}}
  }
\end{mathpar}
\opdef{$\CICAST{e}{\t}{e'}$}{$e$ translates to $e'$ ensuring type $\t$ in context $\G$}
\begin{mathpar}
\inferrule*[lab=CIIStrong]{\Gdash e \tlate e' : \any }{\CICAST{e}{!b}{\cast{!b}e'}}

\inferrule*[lab=CIIWeak]{\Gdash e \tlate e' : \any }{\CICAST{e}{b}{\cast{b}e'}}

\inferrule*[lab=CIISub]{\Gdash e \tlate e' : \t' \\ \t' <: \t}{\CICAST{e}{\t}{e'}}

\inferrule*[lab=CIISuper]{\Gdash e \tlate e' : \t' \\ \t' <: \t}{\CICAST{e}{\t}{\cast{\t}e'}}

\inferrule*[lab=CIIAny]{\Gdash e \tlate e' : \tau}{\CICAST{e}{\any}{e'}}
\end{mathpar}

\caption{Optional typing statics}
\end{figure}

\begin{figure}
\opdef{$\sigma' = \text{cast}(\s, v, \t)$}{Casting $v$ in $\s$ to type $\t$ produces heap $\s'$}
\begin{mathpar}
\inferrule*[lab=ECastClass]{ \s[a\is\{\ldots\B\t'\}] \\ \t' <: \t }{ \cast{\t}a,\s \ereduce a,\s}
\end{mathpar}

\caption{Optional typing evaluation}
\end{figure}

\section{Conclusion}

\bibliographystyle{plain}

\bibliography{bib/compactdoi}
\end{document}


