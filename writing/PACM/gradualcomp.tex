\documentclass[acmlarge, anonymous, authordraft]{acmart}
% can add review if you want line numbers
\usepackage{stmaryrd}


% get rid of acm noise
\settopmatter{printacmref=false}
\renewcommand\footnotetextcopyrightpermission[1]{}
%\pagestyle{plain}

%\usepackage{booktabs} % For formal tables
\usepackage{xspace,listings,url,framed,amssymb,
            mathpartir,hyperref,doi, mathtools,wrapfig,
            stmaryrd, graphicx, tikz, colortbl, xparse, etoolbox, pgffor, makecell} % double brackets llbracket
\usepackage[customcolors,norndcorners]{hf-tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{shapes.multipart}
\usetikzlibrary{positioning}
\usetikzlibrary{calc}
\usetikzlibrary{backgrounds}
\usepackage[inline]{enumitem}

% \usepackage{prelude}
\usepackage{epigraph}
%\setlength{\epigraphwidth}{0.75\linewidth}
\setlength{\epigraphrule}{0pt}
\renewcommand*{\textflush}{flushright}
%\renewcommand*{\epigraphsize}{\normalsize\itshape}
\setlength{\epigraphwidth}{4in}

\newcommand{\code}[1]{{\tt #1}\xspace}

\newcommand{\FZ}[1]{\textbf{FZ: #1}}

\input{macros}

\definecolor{Gray}{gray}{0.9}
\definecolor{vlightgray}{gray}{0.93}

\lstdefinelanguage{JavaScript}{
  keywords={typeof,new,true,false,instanceof,catch,function,return,null, 
    catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{darkgray},
  ndkeywords={class,def,interface,export,boolean,throw,extends,implements,import,this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,  comment=[l]{//},  morecomment=[s]{/*}{*/},
  commentstyle=\color{gray}\ttfamily,  stringstyle=\color{gray}\ttfamily,
  morestring=[b]',  morestring=[b]",
  %backgroundcolor=\color{vlightgray},
  aboveskip=\medskipamount, %0em,
  belowskip=\medskipamount, %0em
  escapeinside={(*@}{@*)}
}
\lstset{
  language=JavaScript,  extendedchars=true,  basicstyle=\small\ttfamily,
  showstringspaces=false,   showspaces=false,  numberstyle=\small,
  numbersep=9pt,  tabsize=2, breaklines=true,  showtabs=false, captionpos=b
}

\renewcommand{\u}[1]{\underline{#1}\xspace}

\usepackage[textsize=tiny]{todonotes}



%
%\usepackage[ruled]{algorithm2e} % For algorithms
%\renewcommand{\algorithmcfname}{ALGORITHM}
%\SetAlFnt{\small}
%\SetAlCapFnt{\small}
%\SetAlCapNameFnt{\small}
%\SetAlCapHSkip{0pt}
%\IncMargin{-\parindent}

%
%% Metadata Information
%\acmJournal{POMACS}
%\acmVolume{9}
%\acmNumber{4}
%\acmArticle{39}
%\acmYear{2010}
%\acmMonth{3}
%\acmArticleSeq{11}

%\acmBadgeR[http://ctuning.org/ae/ppopp2016.html]{ae-logo}
%\acmBadgeL[http://ctuning.org/ae/ppopp2016.html]{ae-logo}

% Copyright
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}

\setcopyright{none}

% DOI
%\acmDOI{0000001.0000001}

% Paper history
%\received{February 2007}
%\received{March 2009}
%\received[accepted]{June 2009}
%



% Document starts
\begin{document}
% Title portion
\title{Gradual Types for Objects Redux}
\author{No Author}
%\orcid{1234-5678-9012-3456}
%\affiliation{%
 % \institution{Myself}
 % }
%  \streetaddress{104 Jamestown Rd}
 % \city{Williamsburg}
 % \state{VA}
 % \postcode{23185}
 % \country{USA}}
%\author{Chengdu Huang}
%\author{John A. Stankovic}
%\author{Tarek F. Abdelzaher}
%\affiliation{%
%  \institution{University of Virginia}
%  \department{School of Engineering}
%  \city{Charlottesville}
%  \state{VA}
%  \postcode{22903}
%  \country{USA}
%}


\begin{abstract}
The enduring popularity of dynamically typed languages has given rise to a
cottage industry of static type systems, \emph{gradual type systems}, that
let developers annotate legacy code piecemeal. Soundness for a program which
mixes typed and untyped code means that some errors will caught at type
checking time, while other will be caught as the program executes. After a
decade of research it is clear that the combination of mutable state, self
references and subtyping presents serious challenges to implementers.  This
paper reviews the state of the art in gradual typing for objects. We
introduce \kafka, a class-based object calculus with a static type system,
dynamic method dispatch, transparent wrappers and dynamic class
generation. We model key features of several gradual type systems by
translation to \kafka and discuss the implications of the respective
designs.
\end{abstract}


\maketitle

\section{Introduction}

\epigraph{\small ``Because half the problem is seeing the problem''}

\vspace{-5mm}

\noindent A decade ago Siek and Taha~\cite{SiekTaha07} presented a gradual type
system for a variant of Abadi and Cardelli's object-based
calculus~\cite{cardelli:1996:theory-of-objects}. Their system featured a dynamic
type, denoted \any, and a subtype relation that combined structural subtyping
with a consistency relation between terms that differ in dynamic type
annotations.  Soundness at the boundaries between typed and untyped code is
ensured by inserting casts as shown in their previous work for functional
languages~\cite{SiekTaha06}.  Ten years later, many systems support the gradual
addition of types to untyped object-oriented programs.\footnote{Languages which
allow mixing typed and untyped with objects include
%%
C\#~\cite{Bierman10},
Dart~\cite{dart13}, 
DRuby~\cite{FurrAF2009},
Hack~\cite{hack13}, 
Gradualtalk~\cite{GS13},
Reticulated Python~\cite{siek14}, 
Safe Typescript~\cite{safe-typescript},
StrongScript~\cite{ecoop15}, 
Thorn~\cite{oopsla09}, 
Typed Racket~\cite{Takikawa:2012}, 
TypeScript~\cite{BAT14}.}
%%

Despite its age and popularity, faithful realizations of Siek and Taha's
elegant idea have proved to be surprisingly elusive, one possible reason
being that the original paper did not consider state. The combination of
mutable state, aliasing and subtyping complicates enforcement strategies as
one must consider situations where an object is being accessed at different
types. While several solutions have been proposed to address this, the
performance implications of the implementation strategies of these solutions
seem daunting.\footnote{\emph{Sound} type systems reports order of magnitude
  pathologies, e.g.~5x for Gradualtalk~\cite{allende13}, 10x Reticulated
  Python~\cite{siek14}, 22x Safe Typescript~\cite{safe-typescript}, and 121x
  Typed Racket~\cite{popl16}. These numbers merely indicate the existence of
  configurations that hurt performance.  Most systems lack rigorous
  evaluations. } Predictably, developers of industrial languages have chosen
to compromise on soundness to avoid degrading performance.\footnote{Dart,
  Typescript and Hack use unchecked modes for production, all type errors
  will not be reported.}

This paper explores the design space of gradual type systems for object-oriented
languages. We aim to expose some of the forces that have influenced existing
systems and discuss the implication of key design decisions. While there are
significant challenges that, in the end, may prevent adoption of some of the
more ambitious type systems, there are are also opportunities for improving on
existing techniques.  This paper also aims to lay the agenda for future
investigations.

To capture the essence of gradual typing for objects and to highlight the
challenges implementers face, we present translations of representative subsets
of gradually typed languages into a common target language. Targeting the same
language lets us reason about the type systems in the same framework and allows
for comparison. But which language should we target? The language should avoid
linguistic clutter while expressing key object-oriented features directly rather
than by encoding. We propose to target a typed object-oriented language
inspired by modern language runtime such as the Java Virtual Machine and the
CLR in .Net. They have a static type system with classes and subtyping but they
also allow for dynamic resolution of method dispatch.\footnote{Both runtime
support reflective invocation based on method names. Dynamic resolution was
added to C\# in version 4.0~\cite{BAT14}. In Java, \xt{invokedynamic} allows for
custom method dispatch.} As well as reasonably efficient implementations, and in
both environments, primitive types can be unboxed.

A contribution of this work is the design of \kafka, a statically typed object
calculus.  \kafka is class based (with an explicit class table \K), with mutable
state (a heap address \a refers to an object, each field \f is reified into a
pair of getter and setter methods), and allows the dynamic generation of wrapper
classes (by update of the class table \K and allocation of new objects \a).
Methods can be statically resolved, denoted by a simple call \Call\a\m\x, or can
be dynamically resolved, denoted by a dynamic call \DynCall\a\m\x. The \kafka
type system has two types, a structural type \C, allow for recursive typing 
and stored in a class table \K, and the dynamic
type \any. Types in general are referred to as \t.

The heart of any gradual type system implementation is the explicit casts
that are inserted at type boundaries.  Two different \emph{structural} casts
are built-in to \kafka; they only inspect the structure of objects.  The
subtype cast \SubCast\t\a is a structural cast that checks if the object
references by \a is a subtype of type \t. 
To support some of the more complex type systems,
\kafka is extended by \emph{generative} casts which create new wrapper
classes.  The behavioral cast \BehCast\t\a generates a wrapper object that
monitors that methods invoked on \a abide by the interface of type \t. 

Another contribution is the translation of five type systems representative
of the main strains of gradual typing for objects. Each gradually typed
expression \HT{\u\e}{\u\T} in the source is translated to a well-typed
\kafka term, \HT\e\T, each type \u\T has a corresponding \kafka type \T,
and, similarly, each expression \u\e has an equivalent \e. While soundness
in \kafka is straightforward (except for generative casts), soundness of the
source gradual type systems is more interesting.  In \kafka, a well-typed
program can only get stuck at a cast or a dynamically resolved call.  With
gradual types, an expression \Call{\u\x}\m{\u{\x'}} where \u\x is declared
to be of class \u\C can have significantly different behavior depending on
choices made while designing the gradual type system. TypeScript has
\emph{optional types}; a well-typed program can get stuck at any method call
as \u\C translates to \any. Thorn has \emph{concrete types}; a well-typed
program will not get stuck at statically resolved method calls, and \u\C
maps to itself \C. Typed Racket has \emph{promised types}; a well-typed
program will not get stuck at a call to \m, because \u\x refers to an
object, or wrapper, that implements \m.  Wrappers may fail if their target
does not behave like a \u\C. Finally we describe the 
%monotonic and 
transient variant of Reticulated Python which has somewhat surprising
semantic properties. \FZ{Does it?}

%\newpage %% Sanity check.  If you see it, then something went wrong.

\section{Background}

\vspace{-5mm}

\epigraph{\small ``If you know the enemy and know yourself...''}

\vspace{-5mm}

\noindent The intellectual lineage of gradual types can be traced back to
attempts to add types to Smalltalk and LISP. A highlight on the Smalltalk
side is the Strongtalk optional type system~\cite{Bracha93} which led to
Bracha's notion of pluggable types~\cite{pluggabletypes}. For him, types are
solely to catch errors at compile-time, they should never affect the
runtime behavior of programs. The rationale for this is that types are
viewed as an add-on that can be turned off without affecting semantics.  In
the words of Richards~\emph{et al.}~\cite{ecoop15}, an optional type system
is \emph{trace preserving}, which means that if a term \e reduces to value
\a, adding type annotations will never cause \e to get stuck. This property
is valuable to developers as it prevents type annotations from introducing
errors, and it follows that type annotations do not effect performance. The
optional type systems currently in wide use include Hack~\cite{hack13},
TypeScript~\cite{BAT14} and Dart~\cite{dart13}. 

On the functional side, the ancestry is dominated by the work of Felleisen
and his students.  The Typed Scheme~\cite{tf-popl08} design that later
became Typed Racket is strongly influenced by earlier work on higher-order
contracts~\cite{ff-icfp02}. Typed Racket was envisioned as a vehicle for
teaching programming, thus being able to explain the source of errors was an
important design constraint, another constraint was to prevent surprises --
a variable annotated as a \C should behave as a \C. Any change in behavior must be
reported at the first discrepancy. The Typed Racket approach to gradual
typing is thus quite different from optional types. Whenever a value crosses
a boundary between typed and untyped code, it is wrapped in a contract that
monitors its behavior. This ensures that the type of mutable values remains
consistent with their declared type and that functions respect their
declared interface. When a value misbehaves, blame can be assigned to the
boundary the value crossed. The granularity of typing is the module, thus a
module is either entirely typed or entirely untyped. This means that a
compilation unit only deals with uniform code (typed or untyped) and that
closely coupled functions co-located in a module will not incur
boundary crossing costs.

Siek and Taha coined the term gradual typing in~\cite{SiekTaha06} as ``any
type system that allows programmers to control the degree of static checking
for a program by choosing to annotate function parameters with types, or
not.'' Their contribution was a formalization of the idea in a lambda
calculus with references and a proof of soundness. They defined the type
consistency relation $\t \sim \tp$ which states that types that agree on
non-\any position are compatible.  In~\cite{SiekTaha07} they extended their
result to a stateless object calculus and combined consistency with
structural subtyping. Extending the approach to mutable objects proved
challenging. Reticulated Python~\cite{siek14} attempts to find a compromise
between soundness and efficiency.  The language has three modes:
\emph{guarded} mode behaves as Racket with contracts applied to values,
\emph{transient} mode performs first order checks before each call, and
\emph{monotonic} mode is similar to the guarded mode except in there are no
wrapper chains and casts only remove occurrences of \any from an object's
type.

Other noteworthy systems include Gradualtalk~\cite{GS13}, C\#
4.0~\cite{Bierman10}, Thorn~\cite{oopsla09},
StrongScript~\cite{ecoop15}. Gradualtalk is a variant of Smalltalk with
Felleisen-style contracts and mostly nominal type equivalence (structural
equivalence can be specified on demand, but it is, in practice, rarely
used). C\# 4.0 adds the type {\sf dynamic} (i.e.~\any) to the C\# language
and adds dynamically resolved method invocation when the receiver of method
call is with type \any.  This means C\# has a dynamic sublanguage that allows
developer to write unchecked code, but it also has a strongly type
sublanguage in which values are guaranteed to be of their declared type.
The implementation of C\# in the~.Net framework replaces \any by the type
{\sf object} and adds casts where needed. A dynamically resolved method call
operation is supported as part of the reflective interface of~.Net.  Thorn
and StrongScript extend the C\# approach with the addition of optional types
(called {\em like types} in Thorn).  Thorn is implemented by translation to
the JVM.\footnote{The translation strategy is surprisingly close to what we
  present later in the paper. The main difference is that the JVM does not
  have a type \any so, like in C\#, \code{Object} is used.} The presence of
concrete types means that the compiler can optimize code (unbox data and
in-line methods) and programmers are guaranteed that type errors will not
occur within concretely typed code. 

%\subsection{Surveying the design space}

%\newcommand{\rot}[1]{\begin{rotate}{80} #1 \end{rotate}}
\newcommand{\rot}[1]{\rotatebox{80}{#1}}
%\newcommand{\rot}[1]{ #1 }
\newcommand{\X}{\EM{\bullet}}
\newcommand{\XX}{\EM{\bullet^{(2)}}}
\newcommand{\XY}{\EM{\bullet^{(1)}}}

\begin{figure}[!ht]
  \center
~ \\[2cm]
  {\small
\begin{tabular}{r|lllllllllllllr}
 & & \rot{Nominal}
  & \rot{Optional types}
  & \rot{Concrete types}
  & \rot{Promised types}
  & \rot{Class based}
  & \rot{First-class Class}
  & \rot{Soundness claim}
  & \rot{Unboxed prim.}
  & \rot{Subtype cast}
  & \rot{Shallow cast}
  & \rot{Generative cast}
  & \rot{Blame}
  & \rot{Pathologies}
  \\
Dart         &&\X &\X &   &   &\X &   &    &    &\X &   &   &   &  - 
\\\hline
Hack         &&\X &\X &   &   &\X &   &    &    &\X &   &   &   &  -  
\\\hline
TypeScript   &&   &\X &   &   &\X &   &    &    &   &   &   &   &  -  
\\\hline
C\#          &&\X &\X &\X &   &\X &   &\XX & \X &\X &   &   &   &  -  
\\\hline
Thorn        &&\X &\X &\X &   &\X &   &\XX & \X &\X &   &   &   & 0.8x
\\\hline
StrongScript &&\X &\X &\X &\X &\X &   &\XX &    &\X &   &\X &   & 1.1x   
\\\hline
Gradualtalk  &&\XY&   &   &\X &\X &   & \X &    &   &   &\X &\X &  5x
\\\hline
Typed Racket &&   &   &   &\X &\X &\X &\X  &    &   &\X &\X &\X & 121x 
\\\hline
Reticulated Python    \\
\it Transient&&   &\X &   &   & \X &  & \X &    &   &\X &   &\X & 10x \\
\it Monotonic&&   &   &   &\X & \X &  & \X &    &   &   &\X &\X &  27x\\
\it Guarded  &&   &   &   &\X & \X &  & \X &    &   &   &\X &\X &  21x\\
\end{tabular}}
  \caption{Overview of implemented systems. (1) Gradualtalk has optional
    structural constraints. (2) Concretely typed expressions are sound in
    C\#, Thorn and StrongScript.}\label{over}
\end{figure}

%\noindent
\figref{over} reviews gradual type systems with publicly available
implementations. All languages here are class-based, except TypeScript which
has both classes and plain JavaScript objects. Most languages base subtyping
on explicit name-based subtype declarations, rather than on structural
similarities.  TypeScript uses structural subtyping, but does not implement
a runtime check; this is likely due to the JavaScript roots of the language,
anecdotal evidence suggests that structural subtyping is rarely
needed~\cite{ecoop15}. StongScript extends TypeScript but changes subtyping
back to nominal.  The consistency relation used in Reticulated Python is
fundamentally structural.  For Racket, the heavy use of first-class classes
and class generation naturally leads to structural subtyping as many of the
classes being manipulated have no names.  Optional types are the default
execution mode for Dart, Hack and TypeScript.  Transient Python is, in some
senses, optionally typed as any value can flow into a variable regardless of
its type annotation, leading to its ``open world'' soundness
guarantee~\cite{siek14}.  In Thorn and C\#, primitives are concretely
typed they can be unboxed without tagging.  The choice of casts follows from
other design decisions. Languages with concrete types naturally tend to use
subtype casts to establish the type of values. For nominal systems there are
highly optimized algorithms. Shallow casts are casts that only check the
presence of methods, but not their signature. These are used by Racket and Python
to ensure some basic form of type conformance. Generative casts are used
when information such as a type or a blame label must be associated with a
reference or an object.

Blame assignment is a topic of investigation in its own right. Anecdotal
evidence suggests that the context provided by blame helps developers
pinpoint the provenance of the ill-typed values. A fitting analogy are the
stack traces printed by Java when a program terminates abruptly. Developers
working in, e.g, C++ must run their program in a debugger to obtain the same
information. Stack traces have little run-time cost because they piggyback
on another feature, namely precise exceptions, which does come at a price as
it inhibits some compiler optimizations. It is likely that recording blame
is costly, but there is no data on how much implementations pay for it.

The last column of \figref{over} lists self-reported performance pathologies.
These numbers are not comparable as they refer to different programs and
different configurations of type annotations. They are not worst case scenarios
either; most languages lack a sufficient corpus of code to conduct a thorough
evaluation.  Nevertheless, one can observe that for optional types no overhead
is expected, as the type annotations are erased during compilation. Concrete
types insert efficient casts, and lead to code that can be optimized.  The
performance of the transient semantics for Reticulated Python can be viewed as a
worst case scenario for concrete types -- i.e. there is a shallow cast at almost
every call. Finally, languages with generative casts tend to suffer prohibitive
slow downs in pathological cases.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \newpage
\section{KafKa: A Core Calculus}


%\vspace{-2mm}

\epigraph{\hspace{-1cm}\small ``Aux chenilles du monde entier et aux papillons qu'elles renferment''}

\vspace{-3mm}

\noindent
The basis of our formal approach \kafka, a class-based, object-oriented,
structurally typed language with dynamic dispatch, modeled on common
compilation targets such as the JVM's Java Bytecode or the .NET CLR's Common
Intermediate Language. 
%, and taking inspiration from C\#'s approach to gradual typing~\cite{Bierman10}.  
Our design is guided by the observation that the
semantics of mainstream approaches to gradual typing can be faithfully
represented via a combination of \emph{dynamic type checks} (casts),
\emph{wrappers creation} around objects, and \emph{new class} generation.

\paragraph{Syntax}  \kafka is a simple object calculus that satisfies the above design requirement. Its syntax is given in \figref{syn}.   Types consist of class names \C, \D, ...\ and the dynamic type, written
\any.  Class definitions have a class name and (possibly empty) sequences of
field definitions and method definitions, \Class\C{\b\fd}{\b\md}. Field
definitions consist of a field and its type, \Fdef\f\t. Method definitions
have (for simplicity) a single argument and an expression, denoted \Mdef\m\x\t\t\e.
  \kafka   supports a limited form of overloading, allowing both a typed implementation and an untyped (dynamically checked) implementation for each method. 
  Fields are private to objects, and can be accessed only from the object scope; reading a field is denoted  \(\FRead\f\)  and writing a field is denoted \(\FWrite\f\e  \).  The calculus supports both statically and dynamically resolved method invocation (denoted  \KCall\e\m\e\t\t and \DynCall\e\m\e).    The static dispatch resolves overloading via the type tag
on the method call.
We let meta-variables \x ranges over variable names, \m and \f range over
methods and fields respectively; \this is a distinguished identifier
representing a method receiver, while \that is a distinguished field name that will be used
in wrapper classes. 

 Providing two different cast mechanisms is the most original feature of the calculus.
The former, the \emph{structural cast}, \(\SubCast\t\e\), denotes the usual subtype cast that dynamically type-checks its argument.  The latter, the \emph{behavioural cast}, \(\BehCast\t\e\), rather that type-checking the argument at run-time, builds a wrapper around it.  The wrapper then ensures that all the successive requests to the object will be  understood (or raise an error). The design of the behavioural cast is intricate, and deserves its own section below.  

State is represented via a heap \s mapping addresses ranged over by \a
to objects denoted \hspace{-1mm}\obj\C{\b\a}.

\begin{figure}[!h]
\hrulefill

\vspace{4mm}

\small
\begin{tabular}{@{}lll}

\begin{minipage}{9cm}\begin{tabular}{@{}l@{~}l@{}l@{}l@{}l@{}l@{}l@{}l}
\e\hspace{.1cm} ::= & \hspace{.2cm} \x        
    &\B \this         
   &\B \that      
   &\B \FRead\f     
   &\B \FWrite\f\e   
   &\B \KCall\e\m\e\t\t \\
   & &
   &\B \SubCast\t\e 
   &\B \BehCast\t\e 
   &\B \New\C{\b\e}  
   &\B \DynCall\e\m\e 
\end{tabular}\end{minipage}&
\begin{minipage}{2.9cm}\begin{tabular}{l@{~}l@{}l@{}l}
   ~ \k &::= \Class \C {\b\fd}{\b\md} \\
~ \t&::= ~ \any  \B   \C  \\ 
\end{tabular}\end{minipage} &
\begin{minipage}{2.9cm}\begin{tabular}{l@{~}l@{}l@{}l}
\md &::= \Mdef\m\x\t\t\e \\
~\fd&::= ~ \Fdef\f\t \\ 
\end{tabular}\end{minipage}\end{tabular}

\vspace{4mm}

\noindent\hrulefill
\caption{\kafka Syntax.}\label{syn}
\end{figure}

\paragraph{Static semantics}

 A well-formed program, denoted \WFp\e\K, consists of an expression \e and a
class table \K where each class \k in \K is well-formed and \e is well-typed
with respect to \K.  A class is well-formed if all its fields and methods
are well-typed with the restriction that a class can have at most two
definitions for any method \m, one typed \Mdef\m\x\C\D\e and one untyped
\Mdef\m\x\any\any\e.  The static semantics of \kafka is mostly standard,
so we report in Fig.~\ref{f:staticsem} only the subtype rule for classes and the type rules for method calls, casts and references.
The complete
set of rules is reported in Appendix section~\ref{appendix:kafka}.  


\begin{figure}[!t]
\hrulefill

{\small
\begin{mathpar}
\IRule{SAss}{
\C \Sub \D \in \M
}{
 \StrSub \M\K \C\D
}


\IRule{SRec}{
 \M' = \M~\C\Sub\D\\
\mt \in \classoff\D\K \implies \mtp \in \classoff\C\K ~.~ \StrSub{\M'}\K\mt{\mtp}
}{
 \StrSub \M\K \C \D 
}

\IRule{W6}{
  \EnvType \Env\s\K\e\C \\
  \Mtype \m\tp\tpp\in \classoff\C\K  \\
  \EnvType \Env\s\K\ep\tp
}{
  \EnvType \Env\s\K{\KCall\e\m\ep{\t'}{\t''}}\tpp
}    

\IRule{W7}{
  \EnvType \Env\s\K\e\any \\
  \EnvType \Env\s\K\ep\any
}{
  \EnvType \Env\s\K{\DynCall\e\m\ep}\any
}    

\IRule{W9}{
  \EnvType \Env\s\K\e\tp
}{
  \EnvType \Env\s\K{\SubCast\t\e}\t
}

\IRule{WB}{
  \EnvType \Env\s\K\e\tp
}{
  \EnvType \Env\s\K{\BehCast\t\e}\t
}

\IRule{W9}{
  \s(\a) = \obj\C{\b\ap}
}{
  \EnvType \Env\s\K\a\C
}

\IRule{W10}{
 }{
   \EnvType \Env\s\K\a\any
}
\end{mathpar}}
\hrulefill
\caption{\kafka static semantics (excerpt)}\label{f:staticsem}
\end{figure}

The
subtyping relation, \StrSub\M\K\t\tp, allows for recursive structural
subtyping: for this the environment \M keeps track of the set of subtype relations assumed.  The \texttt{mtypes} function takes a class name $\C$ and the class table
$\K$, and outputs a list of typing signatures $\b\mt$ for every method in
class $\C$; recall that all fields are hidden from the class type signature. 
Method calls use \emph{syntactic} disambiguation to select between
typed and untyped methods. The dynamically resolved call places no
requirements on the receiver or argument, and returns type \any. 
Statically subtype cast rules \RuleRef{W9} and \RuleRef{W10} are similar; how their soundness is enforced at run-time is very different though.  References can be typed both as dynamic, or with the type of the object the point to in the current heap \(\sigma\).   \FZ{Fix rules names.}



%
\begin{figure}[!t]
\noindent\hrulefill
\smallskip

\small

\begin{minipage}{\textwidth}
  \opdef{\Reduce \K\e\s \Kp\ep\sp}{}
        
        
\begin{center}
\begin{tabular}{r@{\;}l@{}l@{\hspace{2em}}ll}
\CondRule{}{  %% new C -> a
   \fresh\ap 
}{ 
  \ReduceA \K{\New\C{\b\a}}\s \K\ap{\Map\s{\Bind\ap{\obj\C{\b\a}}}}
}
\CondRule{}{  %% a.f() -> e
  \readf \s\a\f\K =  \ap
 %\App\s\a = \obj\C{\a_i \dots ~\ap~ \a_j \dots}  \AND $ \Class\C {\fd_i \dots ~\Fdef{\f}{\t}~ \fd_j \dots}{\md \dots}\in\K$
}{
  \ReduceA \K{\FReadR\a{\f}}\s  \K\ap\s
}
\CondRule{}{  %% a.f(e) -> e
 \setf \s\a\f\ap\K =  \sp
}{
  \ReduceA \K{\FWriteR\a{\f}\ap}\s \K\ap\sp
}
\CondRule{}{  %% a.m(a) -> e
  \Mdef\m\x\t\tp\e  \In \App\K\C \AND \App\s\a=\obj\C{\b\a}
}{
 \ReduceA \K{\KCall\a\m\ap\t\tp}\s \K{[\a/\this~{\ap/\x}]\e}\s
}
\CondRule{}{  %% a@m(a) -> e
    \Mdef\m\x\any\any\e \In \App\K\C \AND \App\s\a=\obj\C{\b\a}
}{
  \ReduceA \K{\DynCall\a\m\ap}\s \K{[\a/\this~{\ap/\x}]\e}\s
}
\CondRule{}{  %% Subtypecast
}{ 
  \ReduceA \K{\SubCast \any\a}\s \K\a\s
}
\CondRule{}{  %% Subtypecast
  \StrSub {}\K\C \D \AND \App\s\a=\obj\C{\b\a} 
}{ 
  \ReduceA \K{\SubCast \D\a}\s \K\a\s
}
\CondRule{}{  %% Behavioral cast  
  \behcast \a\t\s\K  \Kp\ap\sp    
}{    
  \ReduceA  \K{\BehCast \t\a}\s \Kp\ap\sp
} 
\CondRule{}{  %% E[e] -> E[e']
  \Reduce \K\e\s \Kp\ep\sp
}{
 \ReduceA \K{\EE[\e]}\s \Kp{\EE[\ep]}\sp
}
\end{tabular}
\end{center}\end{minipage}

\medskip

%\begin{minipage}{14cm}
\begin{tabular}{l@{~~}l@{~}l@{~}l@{~}l@{~}l@{~}l@{~}l@{~}l@{~}l}
\EE &::=  \FWriteR\a\f\EE   &\B  
        \KCall\EE\m\e\t\t  &\B
        \KCall\a\m{\EE}\t\t &\B
        \DynCall\EE\m\e   &\B
        \DynCall\a\m\EE   &\B
       \SubCast\t\EE  &\B
      \BehCast\t\EE  &\B
       \New\C{\b \a\,\EE\,\b\e}
  &\B \EM{\square}
\end{tabular}
%\end{minipage}

\medskip
\begin{tabular}{c@{\hspace{-0.6em}}c}
\(
\begin{array}{r@{~}l}
\readf \s\a\f\K &= \ap\\ 
    ~~\mathit{if}~~ &\s(\a) = \obj\C{\a_i \dots ~\ap~ \a_j \dots}\\
    ~~\mathit{and}~~ &\Class\C {\fd_i \dots ~\Fdef{\f}{\t}~ \fd_j \dots}{\md \dots}\in\K \\
\end{array} 
\) &
\(
\begin{array}{r@{~}l}
\setf \s\a\f\ap\K &= \Map\s{\Bind{\a}{\obj\C{\a_i\dots ~\ap~ \a_j\dots}}}\\
  ~~\mathit{if}~~ &\s(\a) = \obj\C{\a_i\dots ~\app~ \a_j\dots} \\
  ~~\mathit{and}~~&\Class\C{\fd_i \dots ~\Fdef{\f}{\t}~ \fd_j\dots}{\md \dots}\in\K
\end{array}
\)
\end{tabular}
\medskip

\hrulefill
\caption{\kafka dynamic semantics}\label{fig:semantics}
\end{figure}

%%%%%%%%%%%%%%%%%%% CONTEXTS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%\noindent\hrulefill


\paragraph{Dynamic Semantics}
The small  step operational semantics for \kafka is reported in \figref{fig:semantics}.  To resolve the \this reference in field accesses, the syntax of expressions is extended at runtime with forms 
%
\[ e  ::= \dots \B \a \B \FReadR\a\f \B \FWriteR\a\f\e \]
%
where \a is the pointer to the object referenced by \this and \f a field name.
The dynamic semantics is thus defined over \emph{configurations}: triples \K\e\s, where \K is a class
table, \e is an expression and \s is a heap.  A configuration evaluates in one
step to a new configuration, \Reduce \K\e\s\Kp\ep\sp;  the new configuration may
include a new class table built by extending the previous table with new
classes.
%
% Field access either reads a field from the object (if the class has a
%field definition) or invokes a getter function (if the class has a getter method
%of the field name), and setters are treated similarly. \FZ{Don't understand.  Jan explained - must integrate in text - : Getter/Setter:    A class that has fields `fd1..`  also has implicit getter/setter methods `f1():t` and `f1(x:t):t`.  These implicit g/s methods do not show up in the class table. The semantics knows that if you are trying to call an implicit get / set method it should retrieve the field and read from or write to it.
%The reason they are implicit is that we could not write their body without introducing assignment statements.
%and reads.
%Both of these are tricky because under wrapper semantics you want to be able to interpose on all reads writes.
%An alternative and equivalent design would have been to allow assignments but only in one place — the getter/setter methods of the class that defines a field.  This carries into downsides.
%} 
Calling forms specify the
typing of the method to resolve overloading; this is always \(\any \to \any\) for dynamic calls, but can be either \(\C \to \D\) or \(\any \to \any\) for  static calls.
Structural casts to \any always succeed
while structural casts to \C check that the runtime object is an instance of a
subtype of \C.  
%, while shallow casts check inclusion of method names. 
Evaluation contexts are deterministic and enforce a strict evaluation order.

\paragraph{Behavioural Casts}


\newcommand{\bscast}[2]{\EM{\BehCast{#1}{{#2}}}}

\begin{figure}[!ht]
\hrulefill
\small

\[
\begin{array}{@{}ll@{}l@{}r@{~}c@{~}r}
%    \wrap\C\bmt\bmtp\D\that = \\
%\SP \class ~\D ~ \{\\
%\SPP \Fdef\that\C \\
%\SPP \Mdef\m\x\Dp\Dpp {~\bscast\Dpp{{\KCall{\this.\that()_{\C}} \m {\bscast{\Cp}\x}\Cp\Cpp }}~}
%&     \textit{if}\,\,\,\,\,\, \Mtype\m\Cp\Cpp\in\bmt ~\wedge~ \Mtype\m\Dp\Dpp\in\bmtp ~\wedge~ \\
%&     \multicolumn{5}{l}{\qquad \Mtype\m\any\any\not\in\bmt ~\wedge~ \Mtype\m\any\any\not\in\bmtp} \\
%\\[-3mm]
%\SPP \Mdef\m\x\Dp\Dpp{~\bscast\Dpp{\KCall{\this.\that()_{\C}} \m {\bscast\any\x}\any\any }~}
%&    \textit{if}\,\,\,\,\,\, \Mtype\m\any\any\in\bmt ~\wedge~ \Mtype\m\Dp\Dpp\in\bmtp ~\wedge~  \\
%&     \multicolumn{5}{l}{\qquad \Mtype\m\Cp\Cpp\not\in\bmt ~\wedge~  \Mtype\m\any\any\not\in\bmtp } \\
%\\[-3mm]
%\SPP \Mdef\m\x\any\any{~\bscast\any{\KCall{\this.\that()_{\C}}\m{\bscast{\Cp}\x}\Cp\Cpp}~}
%&    \textit{if}\,\,\,\,\,\, \Mtype\m\Cp\Cpp\in\bmt ~\wedge~ \Mtype\m\any\any\in\bmtp ~\wedge~   \\
%&     \multicolumn{5}{l}{\qquad \Mtype\m\any\any\not\in\bmt ~\wedge~  \Mtype\m\Dp\Dpp\not\in\bmtp } \\
%\\[-3mm]
%\SPP \Mdef\m\x\any\any{~{\KCall{\this.\that()_{\C}}\m{\x}\any\any}~}
%&    \textit{if}\,\,\,\,\,\, \Mtype\m\any\any\in\bmt ~\wedge~ \Mtype\m\any\any\in\bmtp ~\wedge~ \\
%&     \multicolumn{5}{l}{\qquad \Mtype\m\Cp\Cpp\not\in\bmt ~\wedge~ \Mtype\m\Dp\Dpp\not\in\bmtp} \\
%\\[-3mm]
%\SPP \Mdef\m\x{\t}{\tp}{~\KCall{\this.\that()_{\C}}\m{\x}\t\tp~}
%&    \textit{if}\,\,\,\,\,\, \Mtype\m\t\tp\in\bmt ~\wedge~ \Mtype\m\tpp\tppp\not\in \bmtp \\
%\\[-3mm]
%\SP \}
%\\[3mm]

\wrap{\C}{\bmt}{\bmtp}{\D}{\that} = \\
\SP \class ~\D ~ \{\\
\SPP \Fdef\that\C \\
\SPP \Mdef\m\x\tpp\tppp {~\bscast\tppp{{\KCall{\this.\that()_{\C}} \m {\bscast{\t}\x}\t\tp }}~}
&     \textit{if}\,\,\,\,\,\, \Mtype\m\t\tp\in\bmt ~\wedge~ \Mtype\m\tpp\tppp\in\bmtp \\
\\[-3mm]
\SPP \Mdef\m\x{\t}{\tp}{~\KCall{\this.\that()_{\C}}\m{\x}\t\tp~}
&    \textit{if}\,\,\,\,\,\, \Mtype\m\t\tp\in\bmt ~\wedge~ \Mtype\m\tpp\tppp\not\in \bmtp \\
\\[-3mm]
\SP \}
\\[3mm]
\wrapAny\C\bmt\D\that = \\
\SP \class~\D~\{\\
\SPP \Fdef \that \C\\ 
\SPP   \Mdef\m\x\any\any {~\bscast\any{\KCall{\FRead\that\C}\m{\bscast{\t}\x}\t\tp }~}
& \textit{if}\,\,\,\,\,\,  \Mtype\m\t\tp\in\b\mt \\
\SP \}\\

\end{array}\]

  \begin{mathpar}
  
\IRule{BC1}{
  \App\s\a = \obj\C{\b{\a_1}}  \\
  \fresh\D \\
  \fresh\ap \\
  \fresh\that \\
  \cload{\classoff\C\K} \\
  \names{\classoff\Cp\K} \subseteq \names{\classoff\C\K} \\
  \k = \wrap\C{\classoff\C\K}{\classoff\Cp\K}\D\that \\
  \sp = \Map \s{\Bind\ap{\obj\D{\a}}} \\  
}{
  \behcast\a\Cp\s\K {\K\,\k}\ap\sp
}

\IRule{BC2}{
  \App\s\a = \obj\C{\b{\a_1}}  \\
  \fresh\D \\
  \fresh\ap \\
  \fresh\that \\
  \k = \wrapAny\C{\classoff\C\K}\D\that\\
  \sp = \Map \s{\Bind\ap{\obj\D{\a}}} \\  
}{
  \behcast\a\any\s\K {\K\,\k}\ap\sp
}
\end{mathpar}


\hrulefill
\vspace{-2mm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\caption{Behavioural casts.}\label{behavetext}
\end{figure}

A behavioural cast \BehCast\t\a creates a wrapped object \ap which dynamically ensures the type
guarantees defined by \t, independently of the original type of \a.  We refer to the type of \a as the \emph{source} type, 
and to the type \t as the \emph{target} type.
The behavioural cast is generative as it creates both a class (for the wrapper object)
and a new instance of that class (the wrapper itself). Its dynamic semantics is reported in
\figref{behavetext}. The rule \RuleRef{BC1} wraps a reference \a with a freshly generated
wrapper \k for some type \t, adds it to the heap, updates the class table with the class the wrapper is an instance of, 
and then hands it back to the top level dynamics. While doing so it performs several sanity checks; in particular the
target type cannot define methods not defined in the source type, and only objects with no overloaded methods can be wrapped 
(for this the \textsf{dupMeth} function checks for multiple method definitions with the same name).  This second condition 
prevents ambiguity when in method resolution in wrapped objects. Similarly, \RuleRef{BC2} wraps
\a with the guards to let \a act like an instance of \any.

Wrapper generation is implemented by the \xt{wrap} function.  Its first three arguments \(\C\), \(\bmt\), \(\bmtp\) are the type
of the expression being casted (the source type), the type declarations of all its methods, and the type declarations of all the
methods of class type the expressions is being casted to (the target type).  The fourth argument, \(\D\), is the class name  of 
the wrapper class being built; this is always a fresh name in our semantics. The last argument is used to ensure that the name of
the \that field is  fresh.   The function \xt{wrap} builds a new wrapper class with name \(\D\).  The field \xt{that} stores a 
reference to the wrapped object and has thus type \(\C\).  The invocation of a method that appears in \(\bmtp\) is forwarded to 
the corresponding method invocation in \(\bmt\), except that the arguments are protected by behavioural wrappers following the
interface in \(\bmt\) and the return type following the interface in \(\bmtp\).    Methods defined in the source type but missing
from \(\bmtp\) are added to the wrapper class and simply redirected to corresponding method in the wrapped object.
Wrapping an object so that it behaves as \any is simpler, as the wrapper systematically protects the input type and casts back the 
return type to \any.


% 
% \begin{figure}[!ht]
% \hrulefill
% \[
% \begin{array}{@{}ll@{}l@{}r@{~}c@{~}r}
%     \wrap\C\bmt\bmtp\D\that = \\
% \SP \class ~\D ~ \{\\
% \SPP \Fdef\that\C \\
% \SPP \Mdef\m\x\tpp\tppp {~\bscast\tppp{{\KCall{\this.\that()_{\C}} \m {\bscast{\t}\x}\t\tp }}~}
% &     \textit{if}\,\,\,\,\,\, \Mtype\m\t\tp\in\bmt ~\wedge~ \Mtype\m\tpp\tppp\in\bmtp \\
% \\[-3mm]
% \SPP \Mdef\m\x{\t}{\tp}{~\KCall{\this.\that()_{\C}}\m{\x}\t\tp~}
% &    \textit{if}\,\,\,\,\,\, \Mtype\m\t\tp\in\bmt ~\wedge~ \Mtype\m\tpp\tppp\not\in \bmtp \\
% \\[-3mm]
% \SP \}
% \\[3mm]
% \wrapAny\C\bmt\D\that = \\
% \SP \class~\D~\{\\
% \SPP \Fdef \that \C\\ 
% \SPP   \Mdef\m\x\any\any {~\bscast\any{\KCall{\FRead\that\C}\m{\bscast{\t}\x}\t\tp }~}
% & \textit{if}\,\,\,\,\,\,  \Mtype\m\t\tp\in\b\mt \\
% \SP \}\\
% 
% \end{array}\]
% 
%   \begin{mathpar}
%   
% \IRule{BC1}{
%   \App\s\a = \obj\C{\b{\a_1}}  \\
%   \fresh\D \\
%   \fresh\ap \\
%   \fresh\that \\
%   \cload{\classoff\C\K} \\
%   \names{\classoff\Cp\K} \subseteq \names{\classoff\C\K} \\
%   \k = \wrap\C{\classoff\C\K}{\classoff\Cp\K}\D\that \\
%   \sp = \Map \s{\Bind\ap{\obj\D{\a}}} \\  
% }{
%   \behcast\a\Cp\s\K {\K\,\k}\ap\sp
% }
% 
% \IRule{BC2}{
%   \App\s\a = \obj\C{\b{\a_1}}  \\
%   \fresh\D \\
%   \fresh\ap \\
%   \fresh\that \\
%   \k = \wrapAny\C{\classoff\C\K}\D\that\\
%   \sp = \Map \s{\Bind\ap{\obj\D{\a}}} \\  
% }{
%   \behcast\a\any\s\K {\K\,\k}\ap\sp
% }
% \end{mathpar}
% 
% 
% \hrulefill
% \vspace{-2mm}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \caption{Behavioural casts (Collapsed).}\label{behavetextC}
% \end{figure}


%
%Observe that invoking a method not present in the wrapped class results in computation getting stuck.\FZ{comment on all cases where computation gets stuck}
% \FZ{why behavioural and not structural casts?}.

%
%, that takes two class types \C and \D, and the two
%sets of method typing \bmt and \bmtp,   The class type $\C$ is the type of the expression being casted, also referred to as the source type, and represented by $\tp$ in the typing rule \xt{WB}.
%The class type $\D$ is a fresh class name, and represents the type of the wrapper class.
%%
%The method typing $\bmt$ corresponds to the typing definition of every method in $\C$.
%The method typing $\bmtp$ is the set of method typing for the casting type. The casting
%type is also known as the target type, shown by $\t$ in \xt{WB}.
%
% 
%\opdef{\mt ~~::= \Mtype\m\t\t \B  \Mtype\f\t\t  \B \Mtype\f{}\t 
%}{ method typing
%} \\

% 

%Every wrapper class has a \xt{that} field pointing to the source type.


The behavioural cast reduction rule satisfies a property instrumental to our design: a wrapper class generated for a target type \D,  is always a subtype of \D.  This will allow us to refer to both
unwrapped and wrapped objects via the original, source language,
types.   
%
%Internally, wrappers either forward values, as in the case of getters
%and setters, or mimic the behaviour of the underlying object, in the case of
%methods, ensuring that the type guarantees of both the externally visible
%type and the wrapped object are respected.
%
%



%
%Copying the behaviour of the wrapped object is unusual, but this is how we
%maintain one of the semantic Typed Racket, we will describe this in detail in \FZ{OLD SENTENCE, should go?}
%%We use the lifting
%mechanism, copying wrapped class functionality, to ensure that
%self-references refer to the wrapper, rather than to the wrapped object,
%thereby enforcing the dynamic type guarantees. \FZ{Check this text.} 
%




\paragraph{Type soundness} Well-typed \kafka configurations satisfy a type-preservation theorem, and either reduce 
to values or are stuck on a dynamic method invocation or on a cast.  Formally:
given that $\WFp\K{\e~\s}$ and $\EnvType\cdot\s\K\e\t$, then either there is some $\ep$ 
such that $\Reduce \K\e\s \Kp\ep\sp$ and $\WFp\Kp{\ep~\sp}$ and $\EnvType\cdot\sp\Kp\ep\t$ hold, 
or $\e$ is in one of the following forms:
$\a$, $\EE[\DynCall\a\m{\ap}]$, $\EE[\SubCast\tp\a]$, or $\EE[\BehCast\tp\a]$.  
The wrapper generation function will always produce a well-formed class for a target type $\D$. The reason
being that the wrapper class only contain methods from either the source or the target type. The wrapper class
will also never contain any duplicates as it can only contain methods that exists in the source type.
Furthermore, at most the wrapper class will contain every method of the source type.
Proof is in the Appendix.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Translating Gradual Type Systems}

%\vspace{-2mm}

\epigraph{\small ``Was ist mit mir geschehen? dachte er. Es war kein Traum''}

\vspace{-5mm}


\begin{figure}[!h]\hrulefill

\hspace{2mm}
\begin{minipage}{5.9cm}\begin{tabular}{@{}l@{~}l@{}l@{}l@{}ll}
\e &::=  \x          &\B \this          \\
   &\B \New\C{\b\e}  &\B \FRead\f       \\
   &\B \FWrite\f\e   &\B \Call\e\m\e   &\B \a \\ 
\end{tabular}\end{minipage}
\begin{minipage}{5.9cm}\begin{tabular}{l@{~}l@{}l@{}l}
   ~ \k &::= \Class \C {\b\fd}{\b\md}\\
\md &::= \Mdef\m\x\t\t\e \\
%\mt &::= \Mtype\m\t\t &\B~  \Mtype\f\t\t  &\B \Mtype\f{}\t  \\ 
~\fd&::= ~ \Fdef\f\t \\ 
~ \t&::= ~ \any   \B   \C   \B   \fcolorbox{lightgray}{lightgray}{\CW} \\ 
\end{tabular}\end{minipage}

\hrulefill
\caption{Idealised syntax of source languages}\label{f:sourcesyntax}
\end{figure}

\noindent
We are now ready to give semantics to the four gradual type systems of interest, by translating them into \kafka. 
Four each source language, compilation into \kafka is realised by a translation function that maps well-typed source programs into well-typed \kafka terms, respecting a uniform mapping of source types to \kafka types.  The compilation makes explicit which type casts (and, in turn, \emph{dynamic type-checks}) are implicitly inserted and performed by the run-time of each language, highlighting the similarities and differences among them.   

To avoid unnecessary clutter, we represent the source languages using the idealised syntax reported in \figref{f:sourcesyntax}.  This defines a simple object calculus similar to \kafka, but without method overloading and, most importantly, cast operations.  When modelling the Thorn type system, the additional type \CW is added to the type grammar to denote Thorn like types. 


% On top of this uniform source syntax, for each language a type system defines the well-typed terms that can be defined.   


%
% To avoid unnecessary clutter, the source syntax we use is just \kafka one without casts.
%
%Casts are not used in the source languages, but are inserted by the
%translations.  
%
%...The general approach is that for each gradual type system there is a translation function defined on well-typed programs. 
%
%...For each class it produces a well-typed Kafka class.


\subsection{TypeScript}

\begin{figure}
\hrulefill
\begin{mathpar}

\IRule{STGC-SUB}{
  \StrSub\cdot\K\t\tp
}{
  \ConvertE\K{s}\t\tp
}

\IRule{STGC-TOANY}{
}{
  \ConvertE\K{s}\t\any
}

\IRule{STGC-ANYCONC}{
}{
  \ConvertE\K{s}\any\tp
}


\IRule{STG-VAR}{
   \HasType \Env\x\t
 }{
   \EnvTypeS \Env\K\x\t
} 


\IRule{STG-GET}{
   \HasType \Env\this\C \\
  \Fdef\f\t \in \App\K\C
}{
  \EnvTypeS \Env\K{\FRead\f}\t
}    

\IRule{STG-SET}{
  \HasType \Env\this\C \\
  \Fdef\f\t \in \App\K\C \\
  \EnvTypeS \Env\K\e\tp \\
  \ConvertE\K{s}\tp\t
}{
  \EnvTypeS \Env\K{\FWrite\f\e}\t
}    

\IRule[width=20em]{STG-CALL}{
  \EnvTypeS \Env\K\e\C \\
  \Mtype \m\t\tp\in \classoff\C\K  \\
  \EnvTypeS \Env\K\ep\tpp \\
  \ConvertE\K{s}\tpp\t
}{
  \EnvTypeS \Env\K{\Call\e\m\ep}\tp
}    

\IRule{STG-NEW}{
 \EnvTypeS \Env\K{\e_1}{\tp[1]}~~\dots~~ 
 \EnvTypeS \Env\K{\e_n}{\tp[n]}\ \\  
 \ConvertE\K{s}{\tp[1]}{\t[1]} ~~\dots~~ \ConvertE\K{s}{\tp[n]}{\t[n]} \\
 \b\fd=\Fdef{\f_1}{\t_1}~\dots~\Fdef{\f_n}{\t_n} \\ 
  \Class \C {\b\fd}{\b\md} \in \K
}{
  \EnvTypeS \Env\K{\New\C{\e_1\dots\e_n}}\C
}
\end{mathpar}

\hrulefill
\caption{TypeScript type system}\label{f:typescriptts}
\end{figure}


Typescript~\cite{BAT14} is a backward compatible extension of JavaScript
with classes and type annotations. Type equivalence is structural and
subtyping of recursive types is supported (as in \kafka types arise from class
declarations). Missing annotations are treated as \any. The role of types is
to catch simple errors, such as misspelt method names, as well as assisting
IDEs.  A typical example is shown here. The first expression is ill-typed
because method \(o\) does not exist in class \C, while the second is erroneous as it
provides an instance of \C where \D is expected. The third
expression is statically correct as the instance of \C is cast to a
\D by the \n method.
%
%\[
%\begin{array}{l}

\medskip
\(
\Class \C {   \Mdef\m\x\D\C \this  ; \   \Mdef\n\x\any\D \x }
\)

\medskip
\( \Call {\New \C{}} o {\New \D{}} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \texttt{    // ERR wrong method } \)

\(\Call {\New \C{}} \m {\New \C{}} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \texttt{ // ERR wrong type } \)

\(\Call {\New \C{}} \m {\Call {\New \C{}} \n {\New \C{}}} \ \ \ \texttt{ // OK } \)


\medskip

%\FZ{fix typesetting of method name o}

%\begin{lstlisting}
% class A { 
%    m(x: C): A { this }
%    n(x: *): C { x } }
%
% new A().o(new C()) // ERR wrong method
% new A().m(new A()) // ERR wrong type
% new A().m(new A().n(new A())) // OK 
%\end{lstlisting}
%
\noindent
Our formalisation of the TypeScript type system is reported in \figref{f:typescriptts}.  We illustrate its design by focussing on the examples above and study how the \RuleRef{STG-CALL} rule enforces the expected outcome.  Since the receiver has type \C, the first expression is simply ruled out by the check that the called method must be part of the class signature.  The second is more interesting: the method exists but expects a \D argument while we are passing a \C.  The \emph{convertibility} relation, denoted   \ConvertE\K{s}\t\tp, captures precisely the allowed implicit type conversion.  For TypeScript, values can flow freely to and from \any, and it is also allowed to pass a subtype when a supertype is expected.  Since in our second example, the types \C and \D are incompatible, the convertibility check fails.

The TypeScript compiler then translates well-typed code to plain JavaScript, with all types erased and methods resolved dynamically. Of course, since convertibility allows arbitrary values can be passed whenever a \any value is expected, dynamically resolved calls may fail because the receiver need not have the requested method. The designers of TypeScript saw this unsoundness as a way to
ensure, ({\em a}) that types do not get in the way of running correct
programs, e.g. when importing a new library with type annotations
inconsistent with existing client code; and ({\em b}) an insurance for
backwards compatibility, as ignoring types means all browsers can run
TypeScript code -- with no additional overhead.


\newcommand{\TR}[1]{\EM{\llbracket    #1 \rrbracket}}
\newcommand{\TA}[1]{\EM{\llparenthesis 2 \rrparenthesis}}

\newcommand{\TRG}[2]{\EM{\llbracket    #1 \rrbracket_{#2}}}
\newcommand{\TAG}[3]{\EM{\llparenthesis #1 \rrparenthesis_{#2}^{#3}}}

The TypeScript dynamic semantics can be modelled in \kafka with a very simple translation mechanism, where every
type becomes \any  (including in method signatures) and every call becomes a dynamic call.  
For instance one would translate the class
definition and the last expression above as:

\medskip
\(
\Class \C {   \Mdef\m\x\any\any \this  ; \   \Mdef\n\x\any\any \x }
\)

\medskip

\(\DynCall {\New \C{}} \m {\DynCall {\New \C{}} \n {\New \C{}}} \)


\medskip
\noindent This  scheme can be implemented by the simple top-down algorithm in \figref{f:typescriptkafka}.  The translation function \(\TR{\dots}\) is applied to both class definitions and expression; to avoid confusion, the grey background is used to identify translated terms (that is \kafka terms).  


\begin{figure}[!h]
\hrulefill

\smallskip
\begin{tabular}{@{}l@{~ ~ ~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}ll}
\small
 \begin{minipage}{8cm}  
\begin{tabbing}
\TR{\Class \C{\fds 1..}{\mds 1 .. } } = \src{ \Class \C{ \fdsp 1..}{\mdsp 1..}}\HS \WHERE\HS
  \=\fds 1 = \Ftype\f\t ..,\HS\HS\=\fdsp 1 = \src{\Ftype\f\any} .., \HS\HS\=\mds 1 = \Mdef\m\x{\t_1}{\t_2}\e \\
  \>\mdsp 1 = \src{\Mdef\m\x\any\any\ep},\HS\HS \>\>\ep = \TR{\e}
\end{tabbing}
\begin{tabbing}
\TR{\FRead\f}\HS\HS\HS\HS\= = \src{\FRead\f}
\\[1mm]
\TR{\FWrite\f\e} \> = \src{\FWrite\f\ep} \HS\HS\HS\HS\HS\=\WHERE~\ep=\TR\e
\\[1mm]
\TR\this           \>= \src{\SubCast\any\this}
\\[1mm]
\TR\x \> = \src \x
\\[1mm]       
\TR{\Call{\e_1}\m{\e_2}} \> = \src{\DynCall{\eps 1}{\m}{\eps 2}} \HS\>\WHERE\HS\eps 1 = \TR{ \e_1}, \HS \eps 2 = \TR{\e_2}
\\[1mm]
\TR{\New\C{\e_1..}} \> = \src{\SubCast\any{\New\C{\eps 1..}}} \HS \>\WHERE \HS   \eps 1 = \TR{\e_1} ..
\end{tabbing}
\end{minipage}
\end{tabular}

\smallskip
\hrulefill
\caption{TypeScript to \kafka translation}\label{f:typescriptkafka}
\end{figure}


\noindent  All TypeScript types are represented with the dynamic \kafka type, \any, and all translated expressions have type \any.  The casts inserted in the translation are there to keep the kafka type system happy and have no operational effect.

  The unsoundness comes from the use of \TR a(\any,\e) which discards the type of \e.

...The casts inserted in the translation are there to keep the kafka type system happy and have no operational effect


% \clearpage

\subsection{Thorn}

Thorn~\cite{oopsla09} is an object-oriented language with multiple inheritance,
nominal type equivalence, and a combination of optional and concrete types.
Optional types (written \code{?T}) are translated to the \any type with
dynamically resolved method invocation, as in TypeScript. Concrete types
(written \code{T}) behave as one would expect: a variable \code{x:C} is
guaranteed to refer to an instance of \code C or a subtype thereof. Consider the
following program with calls to concretely typed method \code n and optionally
typed \code m, and assume that \code D is not a subtype of \C.

\begin{lstlisting}
 class A {
    m(x: ?C): ?C { x }
    n(x:  C):  C { x } }

 new A().m( new D() ) // OK -- warning
 new A().n( new D() ) // ERR -- D !<: C
 new A().m( new A.n(new C()) // OK
 new A().n( new A.m(new C()) // Cast
\end{lstlisting}

\noindent The first call to \code m is allowed because the argument of \code m
is treated as type \any, and a warning is emitted. The second call is ruled
incorrect as a concrete type is expected for \code n. The third call is allowed
as a \code C is a subtype of \code{?C}. The last call results in a cast being
inserted as \code{?C} cannot be guaranteed to hold an instance of \code{C} or a
subtype.  The translation of Thorn to \kafka turns optional types to \any and
inserts structural casts to \code{C} when an expression of type \any, or of type
\code{?C} is assigned to a \code{C}. So class \code A would translate to:

\begin{lstlisting}
 class A {
    m(x:  *):  * { x }
    n(x:  C):  C { x } }
\end{lstlisting}


\begin{figure}
\hrulefill
\begin{mathpar}

\IRule{STHC-SUB}{
  \ThorSub\cdot\K\t\tp
}{
  \ConvertE\K{th}\t\tp
}

\IRule{STHC-TOANY}{
}{
  \ConvertE\K{th}\t\any
}

\IRule{STHC-OPTCONC}{
  \ThorSub\cdot\K\C\D
}{
  \ConvertE\K{th}\CW\D
}

\IRule{STHC-ANYCONC}{
}{
  \ConvertE\K{th}\any\tp
}

\IRule{STH-VAR}{
   \HasType \Env\x\t
 }{
   \EnvTypeW \Env\K\x\t
}

\IRule{STH-GET}{
  \HasType \Env\this\C \\
  \Fdef\f\t \in \App\K\C
}{
  \EnvTypeW \Env\K{\FRead\f}\t
}    

\IRule[width=20em]{STH-SET}{
  \HasType \Env\this\C \\
  \Fdef\f\t \in \App\K\C \\
  \EnvTypeW \Env\K\e\tp \\
  \ConvertE\K{th}\tp\t
}{
  \EnvTypeW \Env\K{\FWrite\f\e}\t
}    

\IRule[width=20em]{STH-CALL}{
  \EnvTypeW \Env\K\e\C ~~\vee~~ \EnvTypeW \Env\K\e\CW \\
  \Mtype \m{\t}\tp\in \classoff{\C}\K  \\
  \EnvTypeW \Env\K\ep\tpp \\
  \ConvertE\K{th}\tpp\t
}{
  \EnvTypeW \Env\K{\Call\e\m\ep}\tp
}    

\IRule[width=20em]{STH-DCALL}{
  \EnvTypeW \Env\K\e\any \\
  \EnvTypeW \Env\K\ep\tpp \\
  \ConvertE\K{th}\tpp\any
}{
  \EnvTypeW \Env\K{\Call\e\m\ep}\any
}    

\IRule{STH-NEW}{
 \EnvTypeW \Env\K{\e_1}{\tp_1} ~~\dots~~ \EnvTypeW \Env\K{\e_n}{\tp_n} \\
 \ConvertE\K{th}{\tp[1]}{\t[1]} ~~\dots~~ \ConvertE\K{th}{\tp[n]}{\t[n]} \\
 \b\fd=\Fdef{\f_1}{\t_1}~\dots~\Fdef{\f_n}{\t_n} \\ 
  \Class \C {\b\fd}{\b\md} \in \K
}{
  \EnvTypeW \Env\K{\New\C{\e_1\dots\e_n}}\C
}
\end{mathpar}
\hrulefill
\caption{Thorn type system}\label{f:thornts}
\end{figure}

To model Thorn we extend the syntax of source terms with an ``unsound'' type
written $\dt\C$, which has its own subtyping relation, and compiles down to
\any. This unsound type still enforces the same static requirements as its
sound counterpart, but generates no runtime casts.  Over this new type, we
define a subtyping relation, \t~\src\Sub~\t. The relation is identical to
\kafka subtyping except in that \dt\C~\src\Sub~\dt\D and \C~\src\Sub~\dt\D
both hold if \C~\src\Sub~\D.  

...Explain translation



\begin{figure}[!h]
\begin{tabular}{@{}l@{~ ~ ~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}ll}
\small
  \hspace{-.5cm}\begin{minipage}{8cm}  
\begin{tabbing}
\TR{\Class \C{\fds 1..}{\mds 1 .. }}\= = \src{ \Class \C{ \fdsp 1..}{\mdsp 1..~ \mdspp 1..}} 
\HS \WHERE~\= \fdsp 1 = \src{\Ftype\f{\kty\t}} .., \HS\HS\HS\HS\HS \=\fds 1 = \Ftype\f\t ..   \\
\> \mdsp 1 = \src{\Mdef\m\x{\kty{\t_1}}{\kty{\t_2}}{\ep}} .., \HS \> \mds 1 = \Mdef\m\x{\t_1}{\t_2}\e ..,\HS\HS\> \ep = \TAG{\e}{\this:\C\,\x:{\t_1}}{\t_2} ..,\\
\> \mdspp 1 = \src{\Mdef\m\x\any\any{\SubCast\any{\KCall\this\m{\SubCast{\t_1}\x}{\t_1}{\t_2}}}}
\HS \IF \kty{\t_1} = \D \OR \kty{\t_2} = \D\\
          \>\hspace{1cm} empty \HS  {\bf otherwise}  ..                  
\end{tabbing}
\begin{tabbing}
\TRG{\x}\Env \hspace{1.4cm}\= = \src \x
\\[1mm]       
\TRG{\FRead\f}\Env \> = \src{\FRead\f} 
\\[1mm]
\TRG{\FWrite\f\e}\Env \> = \src{\FWrite\f\ep} \hspace{.5cm} \=
\WHERE\HS\= \TypeCk{\K, \Env}\e\C, \HS  \Ftype\f\t\In\App\K\C, \HS \ep = \TAG\e\Env{\kty\t}
\\[1mm]
\TRG{\Call{\e_1}\m{\e_2}}\Env \>= \src{\DynCall{\eps 1}{\m}{\eps 2}} 
\HS  \>\WHERE\HS \TypeCk{\K,\Env}{\e_1}\t, \HS \kty\t=\any
 \eps 1= \TRG{\e_1}\Env, \HS \eps 2=\TAG{\e_2}\Env\any
\\[1mm]
\TRG{\Call{\e_1}\m{\e_2}}\Env \>= \src{\KCall{\eps 1}{\m}{\eps 2}{\t_1}{\t_2}} 
\>\WHERE\HS   \TypeCk{\K,\Env}{\e_1}\C, \HS  \eps 1 = \TRG{\e_1}\Env, \HS
 \Mtype\m{\t_1}{\t_2}\In\App\K\C, \HS  \eps 2 = \TAG{\e_2}\Env{\t_1}
\\[1mm]
\TRG{\New\C{\e_1..}}\Env\> = \src{\New\C{\eps 1..}} 
     \>\WHERE\HS    \Ftype{\f_1}{\t_1}\In\C, \HS  \eps 1 = \TAG{\e_1}\Env{\t_1} ..
\\[1mm]
\TAG\e\Env\t\> = \src\ep \> \WHERE\HS  \EM{\K\vdash\kty\tp \Sub \kty\t}, \TypeCk{\K,\Env}\e\tp, \ep = \TRG\e\Env
\\[1mm]
 \TAG\e\Env\t \>= \src{\SubCast{\kty\t}\ep}
\>\WHERE\HS  \EM{\K\vdash\kty\tp \not\Sub \kty\t}, \TypeCk{\K,\Env}\e\tp, \ep = \TRG\e\Env
\end{tabbing}
\end{minipage}
\end{tabular}
\caption{Thorn translation.  \kty\t = \any if  \t=?\C, \t otherwise. }
\end{figure}



\subsection{Transient Python}

The Transient variant of Reticulated Python~\cite{siek14} aims for soundness
with a predictable cost model. The declared types of arguments are defensively
checked in every method, such as in method \m. Method \m expects an instance of
class \C, but it can be called with a value of type \any at any point, forcing
\m to check its arguments at every invocation.

\begin{lstlisting}
 class A {
    m(x: C): D { x.n(new C()) }
    n(x: *): * { x } }

 new A().m( new A().n( new C() ) ) // OK
 new A().m( new A().n( new D() ) ) // Runtime ERR
\end{lstlisting}

\noindent Transient Python deems both expressions well-typed. However, the
second is going to end up with a type error as a \code D is passed to a method
expecting a \code C.  When translating to \kafka, all types are erased and casts
are inserted on method entry and prior to returning.

...removed broken translation 

\begin{figure}
\hrulefill
\begin{mathpar}

\IRule{STTC-SUB}{
  \ConSub\cdot\K\t\tp
}{
  \ConvertE\K{tr}\t\tp
}

\IRule{STTC-TOANY}{
}{
  \ConvertE\K{tr}\t\any
}

\IRule{STTC-ANYCONC}{
}{
  \ConvertE\K{tr}\any\tp
}

\end{mathpar}
\hrulefill
\caption{Transient convertibility rules}\label{f:transientts}
\end{figure}

The expression typing rules for our Transient Racket source is identical to the 
typing rules, presented in figure \ref{f:typescriptts}, for our TypeScript source.

\noindent The translated class \code A has a check to validate that the
argument to \code m has all the methods defined by \code C.

...removed broken

\begin{figure}[!h]
\begin{tabular}{@{}l@{~ ~ ~}ll}
 \small
\begin{minipage}{8cm}  
\begin{tabbing}
\TR{\Class\C{\fds 1..}{\mds 1.. }} =  \src{\Class \C {\fdsp 1..}{\mdsp 1.. } }\\
\hspace{.5cm}  \WHERE\HS \=
  \fdsp 1 = \src{\Ftype\f\any} .., \HS
  \fds 1 = \Ftype\f\t ..,\HS\HS
  \mdsp 1 = \src{\Mdef\m\x\any\any{\SubCast\t\x ~; ~\eps 1}} .., \HS
  \mds 1 = \Mdef\m\x\t\tp\e ..,\HS\HS
   \eps 1 = \TAG\e{\x:\t\,\this:\C}\tp~ ..
\end{tabbing}
\begin{tabbing}
\TRG\this\Env \hspace{1cm} \= = \src\this
\\[1mm]
\TRG\x\Env \>= \src{\SubCast\t\x} \hspace{1.5cm} \=\WHERE \HS \TypeCk{\K,\Env}\x\t
\\[1mm]
\TRG{\FRead\f}\Env \>= \src{\SubCast\t{\FRead\f}} \>\WHERE\HS  \TypeCk{\K,\Env}\this\C,\HS\HS\=\Ftype\f\t\In\App\K\C
\\[1mm]
\TRG{\FWrite\e}\Env \>=  \src{\SubCast\t{\FWrite\f\ep}}
  \>\WHERE\HS
  \TypeCk\K\this\C,
  \> \Ftype\f\t\In\App\K\C, \hspace{.7cm}
  \= \ep = \TAG\e\Env\any
\\[1mm]
  \TRG{\Call{\e1_1}\m{\e_2}}\Env \>= \src{\DynCall{\eps 1}\m{\eps 2}}
  \>\WHERE \HS 
  \TypeCk{\K,\Env}{\e_1}\any, \HS
  \> \eps 1 = \TRG{\e_1}\Env, 
  \> \eps 2 = \TAG{\e_2}\Env\any
\\[1mm]
\TRG{\Call{\e1_1}\m{\e_2}}\Env \>= \src{\SubCast\tp{\KCall{\eps 1}\m{\eps 2}\t\tp}}
   \>\WHERE\HS
   \TypeCk{\K,\Env}{\e_1}\C,
   \> \Mtype\m\t\tp\In\App\K\C,\HS
   \> \eps 1 = \TRG{\e_1}\Env, \HS\HS
   \eps 2 = \TAG{\e_2}\Env\any
\\[1mm]
\TRG{\New\C{\e_1..}}\Env \>=  \src{\New\C{\eps 1..}} \>\WHERE\HS
\Ftype{\f_1}{\t_1}\In\App\K\C,
  \>\eps 1 = \TAG{\e_1}\Env{\t_1} ~..
\\[1mm]
\TAG\e\Env\t \>= \src{\SubCast\t\e}
    \>\WHERE\HS \TypeCk{\K,\Env}\e\tp, \> (\t = \any \OR \tp = \any),\HS \> \ep = \TRG\e\Env
\\[1mm]
\TAG\e\Env\t \>= \src\ep \>\WHERE\HS  \TypeCk{\K,\Env}\e\tp, \HS\>(\EM{\ConSub{}\K\t\tp}),\HS \> \ep = \TRG\e\Env
\end{tabbing}
\end{minipage}
\end{tabular}
\caption{Transient}\end{figure}

...Say: sequencing


... All type
annotations are erased and replaced by \any.  Every call, typed or untyped,
in Transient becomes untyped.  Every typed method call must be guarded with
a cast to ensure that the return type of the method is correct, as shown in
\RuleRef{TPG2}.  The lack of statically typable calls in the Transient
semantics means that a pure implementation of transient would entail no
fields ever being accessed using the setter or getter methods, as \kafka
forbids accessing fields through dynamic call sites. To overcome this, rule
\RuleRef{TPG4} is added, which allows the definition of self-referential
field access. In a transient system, the only type that is known is the type
of \this.  As a result, accesses to fields have to go through user-defined
field accessor methods.  Rule \RuleRef{TPR2} provides consistency for
Transient. In gradual type systems with consistency, consistency is used to
conclude an analytic judgment, as consistency allows the system to break
type guarantees, adding and removing types from sub-parts of a
program. 

... Consistency within \kafka is...

...it is used in the transient system to allow typed and untyped code to
interact. When consistency is used, a check is inserted to ensure that all
the methods that are required are declared on the provided type, but the
types of the methods are ignored, as they are the responsibility of the
callee to check.






\subsection{Typed Racket}

Typed Racket has an expressive object system with first-class
classes~\cite{Takikawa:2012}, which we restrict to the core of the system, a
class-based object system with structural subtyping. Classes are either typed,
in which case all variables have types different from \any, or untyped, where
all types are \any.  In the following example, \code A is untyped, it constructs
an instance of the typed class \code{B} and invokes method \code{n} with \code
x, a variable of type \any.

\begin{lstlisting}
 class A {
   m(x: *): * { new B().n(x) } }
 class B {
   n(x: B): C { x.n(x) } }

 new A().m( new A())
\end{lstlisting}

\noindent Class \code B expects \code x to be of type \code B, yet it will
be given an \code A. Typed Racket mediates at boundaries between typed and
untyped code by inserting wrappers around exchanged values. These wrappers
ensure that the values behave according to their \emph{promised} types. The
translation to \kafka is such that typed code remains untouched, untyped
code is extended with \emph{behavioral generative casts} at creation of
instances of typed classes. The body of \code m becomes {\tt ({\BehStart
    \any \BehEnd}new B())@n(x)}.  The instance of \code B is cast to \any,
and the call is dynamically resolved. The cast creates a new wrapper class
that has all of the methods of \code B accepting untyped arguments as well
as typed arguments. The wrapper generated by the cast is (roughly) as
follows:

\begin{lstlisting}
  class BW {
   that : B
   n(x: *): * { (*@\BehStart \any \BehEnd@*) that.n( (*@\BehStart B \BehEnd
     ShaStart B ShaEnd x@*) ) }
   n(x: B): C { that.n(x) } }
\end{lstlisting}

\noindent Class \code{BW}, a fresh name, is a subtype of
\code B (in \kafka, subtyping is defined only over typed methods).  The
wrapper has a field \that which refers to the instance of \code B. When it
is called from a typed context, all it does is forward calls to the
target. In an untyped context, the wrapper will cast the argument to the
promised type and cast results back to \any. Each of these casts introduces
new wrappers. A shallow structural cast is used to catch obvious mismatches
early.   \FZ{FIXME, we do not have shallow casts anymore.}
 The key properties of this translation are that typed code can rely
on the presence of methods of the right type (and thus use static method
resolution) but calls can still fail at casts within the wrapper. An easily
overlooked, but significant, feature of Racket is that the \this variable is
wrapped by any wrapper(s) applied at the call site.

The complete type system for our Typed Racket source is identical to the type
system of our TypeScript source presented in figure \ref{f:typescriptts}.

Our model of Typed Racket does not preserve the ``macro'' model of gradual
typing of the source language, as it does not effect the fundamental
semantics of the typing system.  Typed Racket requires a new cast, a
\emph{generative cast}, which is sufficiently different from what we have
seen so far that we will extend the syntax and semantics of \kafka to
support it.  For an expression \e and type \t, the cast \BehCast\t\e depicts
the behavioural cast, and the typing and semantic rules are next.


\begin{figure}[!h]
\begin{tabular}{@{}l@{~ ~ ~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}ll}
 \small
\begin{minipage}{8cm}  
\begin{tabbing}
\TR{\Class\C{\fds 1..}{\mds 1.. }} =  \src{\Class \C {\fds 1..}{\mdsp 1.. } }\\
\hspace{.7cm} \WHERE\HS 
\mdsp 1 = \src{\Mdef\m\x\t\tp{\eps 1}} ..,\HS\HS
\mds 1 = \Mdef\m\x\t\tp{\e_1} ..,\HS\HS
\eps 1 = \TRG{\e_1}{\x:\t\,\this:\C}
\end{tabbing}
\begin{tabbing}
\TRG\x\Env = \src{\x}
\\[1mm]
\TRG{\FRead\f}\Env  = \src{\FRead\f}
\\[1mm]
\TRG{\FWrite\f\e}\Env =  \src{\FWrite\f\ep} \hspace{.5cm}
\=\WHERE
\= \TypeCk\K{\e_1}\C, \HS\HS
\= \Ftype\f\t\In\App\K\C, \hspace{1cm}
\=  \eps 1 = \TRG{\e_1}\Env,\HS\HS\HS
\= \eps 2 = \TAG\e\Env\t
\\[1mm]
\TRG{\Call{\e1_1}\m{\e_2}}\Env = \src{\DynCall{\eps 1}\m{\eps 2}}
\>\WHERE \> \TypeCk{\K,\Env}{\e_1}\any, \HS
\> \eps 1 = \TRG{\e_1}\Env,\HS
\> \eps 2 = \TAG{\e_2}\Env\any
\\
\TRG{\Call{\e1_1}\m{\e_2}}\Env = \src{\KCall{\eps 1}{\m}{\eps 2}{\D_1}{\D_2}}
\>\WHERE \> \TypeCk{\K,\Env}{\e_1}\C, \HS
\> \Mtype\m{\D_1}{\D_2}\In\App\K\C, \HS
\> \eps 1 = \TRG{\e_1}\Env,\HS
\> \eps 2 = \TAG{\e_2}\Env{\D_1}
\\[1mm]
\TRG{\New\C{\e_1..}}\Env =  \src{\New\C{\eps 1..}}
   \>\WHERE \> \Ftype{\f_1}{\t_1}\In\App\K\C ~..
   \>       \>  \eps 1 = \TAG{\e_1}\Env{\t_1} ~..
\\[1mm]
\TAG\e\Env\t = \src\ep
\> \WHERE\> \TypeCk{\K,\Env}\e\tp, \HS
\> \EM{\K\vdash \t \Sub \tp},
\>  \ep = \TRG\e\Env
\\[1mm]
\TAG\e\Env\t = \src{\BehCast\t\e}
\>\WHERE\> \TypeCk{\K,\Env}\e\tp, \HS
   \> \EM{\K\vdash \t \not \Sub \tp}
   \>     \ep = \TRG\e\Env
\end{tabbing}
\end{minipage}
\end{tabular}
\caption{Typed Racket}\end{figure}




The other major concern when designing a wrapper-based protection system for
objects is that losing methods is a real possibility. If a wrapper zealously
enforces its type, then it will not wrap methods that do not appear on its
type, which can then be lost to later untyped or more-typed code that is
given that wrapper.
Our approach avoids this by inserting ``passthrough'' methods that retain their
original types and behaviors into the output wrappers, as illustrated in
figure~\ref{ctod}, where we make a \C into a \D and then back again. When we
reduce the set of required methods by casting a \C to a \D, we retain the method
\mp by adding it to the output class. Notably, this operation preserves existing
subtyping relationships, as the generated wrappers only appear as values, and
the operation only adds additional methods.


The Typed Racket translation demonstrates some of the key issues inherent in
a wrapper-based system, where wrapper-inserting casts build up very quickly
internally, leading to the potential for a wrapper explosion, as previously
noted by Takikawa et al~\cite{practical-gt}, a point that is further
highlighted by the number of casts inserted into the wrappers.




\begin{figure}[!t]
\small
\begin{tabular}{@{}cc}
  \begin{tabular}{|@{}cc@{\hspace{1mm}}|}\hline
  \begin{minipage}{4.6cm}
    \begin{lstlisting}
class A {
 m(x:A):A {this}}

class I {
 n(x:I):I {this}}

class T {
 s(x:I):T {this}
 t(x:*):* {this.s(x)}}
      \end{lstlisting}    
  \end{minipage}
&
  \begin{minipage}{4.6cm}
    \begin{lstlisting}
class A {
 m(x:A): A {this}}

class I {
 m(x:C):I {this}}

class T {
 s(x:I):T {this}
 t(x:*):* {this.s(x)}}
      \end{lstlisting}    
  \end{minipage}
\\[2mm]
(Litmus test 1) & (Litmus test 2)\\[3mm]
  \begin{minipage}{4.3cm}
    \begin{lstlisting}
class A {
 m(x:*):* {this}}

class I {
 m(x:C):C {x}}

class J {
 m(x:D):D {x}}

class E {f:I g:J}

class T {
 t(x:*):* {
   new E(x,x)}}
      \end{lstlisting}    
  \end{minipage}
&
  \begin{minipage}{4.6cm}
    \begin{lstlisting}
class A {
 f:*
 m(x:A):A {
  this.f(new A(new C()))}}


class I {
 f:D
 m(x:I):I {this}}


class T {
 s(x:I):I {x.m(x)}
 t(x:*):* {this.s(x)}}
      \end{lstlisting}    
  \end{minipage}
\\[2mm]
(Litmus test 3) &  (Litmus test 4)\\\hline
  \end{tabular}
  &
\begin{minipage}{4cm}
\begin{tabular}{|@{}c@{\hspace{1mm}}|}\hline
  \begin{minipage}{4cm}
    \begin{lstlisting}
class C { 
  n(x:C):C {this}}

class D {
  o(x:D):D {this}}
    \end{lstlisting}    
  \end{minipage}
 \\
  (Auxiliary classes)\\\hline
\end{tabular}
\\ \\ \\  
\begin{tabular}{|@{}c@{\hspace{1mm}}|}\hline
  \begin{minipage}{4cm}
    \begin{lstlisting}
new T()@t(new A())
    \end{lstlisting}    
  \end{minipage}
  \\
  (Program 1-3)\\\hline
\end{tabular}
\\ \\ \\  
\begin{tabular}{|@{}c@{\hspace{1mm}}|}\hline
  \begin{minipage}{4cm}
    \begin{lstlisting}
new T()@t(
    new A(new D()))
    \end{lstlisting}    
  \end{minipage}
  \\
  (Program 4)\\\hline
\end{tabular}
\end{minipage}
\end{tabular}


\center

\begin{tabular}{|r|l@{~}l@{~}l@{~}l|}\hline
                     & L1 & L2 & L3 & L4\\\hline\rowcolor{Gray}
Thorn                &    &    &    &   \\
Typed Racket         &    & \V & \V &  \\\rowcolor{Gray}
Monotonic  RetPy     &    & \V &    &   \\
Transient RetPy      &    & \V & \V & \V \\\rowcolor{Gray}
TypeScript           & \V & \V & \V & \V \\\hline
\end{tabular}  
  \caption{Semantic litmus tests.}\label{litmus}
\end{figure}


\subsection{Trace preservation}

One outcome of our work is showing how \emph{all} of the gradual type systems
are observationally distinct.  \figref{litmus} presents four litmus tests that
are sufficient to distinguish the five type systems being studied in this
paper.  Each litmus test is a program composed of a class table and a main
expression. The programs are written in \kafka syntax but equivalent
programs can be expressed in each of the target languages. All programs are
well-typed in each of the respective type systems and give raise to
different runtime errors. Under TypeScript semantics, all programs run to
completion without getting stuck. With Thorn, all litmus programs fail at a structural cast from \code A to \code I.  For the other languages the situation is
as follows:
\begin{itemize}
\item {\bf L1:} Fails because \code A is not a subtype of \code I, the
  failure is at a shallow cast because \code A does not have all the methods of
  \code I.   \FZ{CHECK, we do not have shallow casts, is this still relevant?}
\item{\bf L2:} Succeeds in Monotonic/Transient/Racket because shallow casts
  of \code A to \code I go through. \FZ{CHECK, we do not have shallow casts, is this still relevant?  Cite monotonic here?}
\item{\bf L3:} Fails in Monotonic because the same object is being cast to
  two different types, \code I and \code J.  \FZ{CHECK, cite monotonic or not?}
\item{\bf L4:} Fails in Monotonic because the object refereed to by \code x
  in method \code s is cast to \code I. This updates the effective type of field
  \code f to \code D. However, the assignment in method \code m tries to give it
  an \code A. This fails in Racket because the \this field is wrapped with an
  \code I type, and the assignment to \code f does not respect that type.
\end{itemize}

\section{Implementation} We designed \kafka to have a close correspondence to
the intermediate languages (ILs) used by common VMs, but by necessity the
correspondence is not exact; real ILs are far too complex to be easily
presented or formally reasoned about. To validate this aspect of \kafka's
design, we implemented a compiler from \kafka to C\#, alongside a runtime that
provides the key behavioral cast operation.

The key challenge that we encountered in the development of this compiler
relates to one of our earliest design choices: the use of a structural type
system. As previously mentioned, structural typing is common in gradually
typed languages, but is very uncommon in actual virtual machines, especially
those that already have static typing like the CLR or the JVM. In order to
implement \kafka by translation to C\#, we have to convert \kafka's structural
types to C\# nominal types, maintaining semantic equivalence.

\subsection{Structural to Nominal Translation} Our implementation of the
conversion of \kafka to C\# types is based on a whole program type analysis.
Consider a (structural) class table \K, and assume that $\StrSub{}\K\t\tp$ for
some $\t$ and $\tp$. C\# already handles the case where $\t$ or $\tp$ is
$\any$, via its \xt{dynamic} type, which has the same semantics, but if $\t$
and $\tp$ are classes $\C$ and $\D$, then we have to be more careful.

The approach works by introducing the interface \xt{ID}, which the translated
version of $\C$ implements. \xt{ID} has all of the same methods as $\D$ did,
allowing the same operations to be performed on its instances. We then refer
to $\D$ by \xt{ID} in the generated C\# type signatures and casts, which then
allows our translation of the class $\C$ to be used wherever a $\D$ is
expected, satisfying subtyping. If we apply this to every pair of types $\C$
and $\D$ where the subtyping relation holds, the C\# subtyping relation
mirrors the \kafka one exactly.

We chose C\# for this translation because it provides the natural
correspondence between our $\any$ and its \xt{dynamic}. However, C\# also
created a substantial problem for our implementation, for it does not allow
for covariance or contravariance in interface implementation, whereas \kafka's
subtyping mechanism does allow both. However, C\# does allow for
\emph{explicit implementations}, which we use to implement covariant and
contravariant interface implementation, by explicitly calling out the
interface method to implement and forwarding to the actual implementation.

\subsection{Proof of concept}

The goal of our implementation was to validate the choice of features to
include in \kafka by showing that they are similar to those provided in
modern, high performance VMs, and for most of \kafka's functionality, the
implementation was trivial. However, structural typing proved difficult, both
because of fundamental differences forcing the generation of a very large and
fixed inheritance hierarchy, and because of specific design choices made in
C\#. Even when making a major assumption - the closed-world restriction - our
implementation of structural typing on top of a nominal type system is
relatively non-trivial. While some practical, sound, implementations of
structurally typed languages exist (with Scala being the most notable),
structural typing creates fundamental difficulties in using off-the-shelf VMs.

What our implementation does not do is provide an accurate picture of the
performance of the gradual typing systems in question, rather focusing on
semantic differences. This limitation is due to a wide range of factors,
including having none of the commonly-cited performance optimizations, such as
threesomes~\cite{siek10}, combined with the severe inherent restrictions on
what programs can be reasonably written in \kafka. As a result, any
performance evaluation based on our \kafka implementation would not be
representative of the performance of a real implementation. %\clearpage


\section{Conclusion}

Gradual typing is no longer simply a popular research topic in academia.
Real-world applications are being written with gradual types and the tug of
war between soundness and performance is being played out in multiple
language designs.  It is the responsibility of language researchers to
present a clear understanding of each viable gradual typing idiom available.
We have introduced \kafka, a formal language that serves as the foundation
for deconstructing five existing gradual typing systems: Typescript, Thorn,
Transient Python, and Typed Racket.
%, and Monotonic Python. 
\kafka offers the
opportunity for comparing and contrasting these gradual typing systems
within an unified framework. The translations to \kafka for each gradual
typing system highlights the essences which makes each system unique.


\bibliographystyle{unsrturl}
\bibliography{../../bib/jv,../../bib/all}

\clearpage

\appendix
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Full \kafka Definition}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{appendix:kafka}



% \subsection{Semantics}

\subsection{Subtyping}

The structural subtype relation, written \StrSub\M\K\t\tp, asserts that \t
is a subtype of \tp in the environment \M composing a set of subtype relations and
a class table \K.   The set of subtype relations can be omitted if its empty.

~\\

\opdef{\StrSub\M\K\t\tp}{\t is a subtype of \tp}
\begin{mathpar}
\IRule{SRef}{
}{
 \StrSub\M\K \t \t
}

\IRule{SAss}{
\C \Sub \D \in \M
}{
 \StrSub \M\K \C\D
}

\IRule{SRec}{
 \M' = \M~\C\Sub\D\\
\mt \in \classoff\D\K \implies \mtp \in \classoff\C\K ~.~ \StrSub{\M'}\K\mt{\mtp}
}{
 \StrSub \M\K \C \D 
}
\end{mathpar}

\opdef{\StrSub\M\K\mt\mtp}{\mt is a subtype of \mtp}
\begin{mathpar}
\IRule{SMet}{
  \StrSub \M\K {\t[1]} {\t[2]} \\
  \StrSub \M\K {\tp[2]} {\tp[1]}
}{
 \StrSub \M\K {\Mtype\m{\t[1]}{\tp[1]}} {\Mtype\m{\t[2]}{\tp[2]}}
}
\end{mathpar}

\subsection{Consistent Subtyping}

\opdef{\ConSub\M\K\t\tp}{\t is a consistent subtype of \tp}
\begin{mathpar}
\IRule{CSCons}{
  \t = \any \vee \tp = \any \vee \t = \tp
}{
 \ConSub\M\K \t \tp
}

\IRule{CSAss}{
\C \Sub \D \in \M
}{
 \ConSub \M\K \C\D
}

\IRule{CSRec}{
 \M' = \M~\C\Sub\D\\
\mt \in \classoff\D\K \implies \mtp \in \classoff\C\K ~.~ \ConSub{\M'}\K\mt{\mtp}
}{
 \ConSub \M\K \C \D 
}
\end{mathpar}

\opdef{\ConSub\M\K\mt\mtp}{$\mt$ is a consistent subtype of $\mtp$}
\begin{mathpar}
\IRule{CSMet}{
  \ConSub \M\K {\t[1]} {\t[2]} \\
  \ConSub \M\K {\tp[2]} {\tp[1]}
}{
 \ConSub \M\K {\Mtype\m{\t[1]}{\tp[1]}} {\Mtype\m{\t[2]}{\tp[2]}}
}
\end{mathpar}

\subsection{Well-formedness}

The well-formedness judgments for \kafka are defined for programs, classes, methods, fields, and types.

~\\

\opdef{~\WFq{\K~\e~\s}}{Well-formed program}

\begin{mathpar}
\IRule{WP}{
  \k \in \K \implies \WF{}\cdot\K\k \\
  \EnvType\Env\s\K\e\t \\
  \WFtype\K\s
}{
  \WFq{\K~\e~\s}
}
\end{mathpar}

\opdef{\WF{}\s\K {\Class\C{\b\fd}{\b\md}}}{Well-formed class}

\begin{mathpar}
\IRule{WC}{
 \xt{overloading}_{\emptyset}(\b\md~\b\fd) \\
 \fd\in\b\fd\implies \WF {}{}\K \fd \\
 \md\in\b\md\implies \WF {\text{this}:\C~}\s\K \md 
}{
 \WF {}\s\K {\Class \C {\b\fd}{\b\md}}
}
\end{mathpar}

The \xt{overloading} auxiliary function states that there are no overloaded 
field or method names within the given field and method definitions. \\

\opdef{~\WF \Env\s\K \md}{Well-formed methods}
\begin{mathpar}
\IRule[width=18em]{WT1}{
 \EnvType {\Env{~\Ftype\x\any}~}\s\K\e\any\\
 \WFtype\K\any \\
}{
 \WF \Env\s\K {\Mdef\m\x\any\any\e}
}

\IRule[width=18em]{WT2}{
 \EnvType {\Env{~\Ftype\x\C}~}\s\K\e\Cp\\
 \WFtype\K\C \\
 \WFtype\K\Cp \\
}{
 \WF \Env\s\K {\Mdef\m\x\C\Cp\e}
}
\end{mathpar}

\opdef{~\WFtype \K {\fd}}{Well-formed fields}
\begin{mathpar}
\IRule{WF}{
 \WFtype\K\t 
}{
 \WFtype\K{\Fdef\f\t}
}
\end{mathpar}
 
\opdef{~\WFtype\K\t}{Well-formed types}
\begin{mathpar}
\IRule{WA}{
}{
 \WFtype\K\any
}

\IRule{WC}{
 \C \in \K
}{
 \WFtype\K\C
}
\end{mathpar}

\opdef{~\WFtype\K\s}{Well-formed heaps}
\begin{mathpar}
\IRule{WH}{
\Bind\ap{\obj\C{\a_1 \ldots \a_n}}~\in~\s \implies \Class\C{\HT{\f_1}{\t_1} \ldots \HT{\f_n}{\t_n}}{\b\md}\in\K ~~~\wedge~~~  
\EnvType\cdot\s\K{\a_1}{\t_1} ~\ldots~ \EnvType\cdot\s\K{\a_n}{\t_n}
}{
 \WFtype\K\s
}
\end{mathpar}

\subsection{Expression typing}

The expression typing judgments for \kafka includes in ascending order as listed in the formalism:
variable, untyped address, subsumption, field set, field get, static method invocation, dynamic method invocation, object creation,
subtype cast,
% shallow cast, 
typed address, \xt{that} field get, and \xt{that} field set.

Field access rules W3 and W4 require a typed receiver, since \any does not
have any methods a receiver typed at \any will never typecheck.

Shallow casts, W9, do not change the type of the expression, as we are casting
to the name of \t not to \t.  

~\\

\opdef{\EnvType\Env\s\K\e\t}{\e has type \t in environment \Env against heap \s and class table \K}
\begin{mathpar}

\IRule{KT-VAR}{
   \HasType \Env\x\t
 }{
   \EnvType \Env\s\K\x\t
}

\IRule{KT-SUB}{ 
  \EnvType \Env\s\K\e\tp \\
 \StrSub \cdot\K \tp \t
 }{
  \EnvType \Env\s\K\e\t 
}   

\IRule[width=12em]{KT-READ}{
  \HasType\Env\this\C\\
  \Fdef\f\t \in \App\K\C
}{
  \EnvType \Env\s\K{\FRead\f}\t
}  

\IRule[width=12em]{KT-REFREAD}{
  \EnvType \Env\s\K\a\C \\
  \Fdef\f\t \in \App\K\C \\
  \EnvType \Env\s\K\e\t
}{
  \EnvType \Env\s\K{\FReadR\a\f}\t
}  

\IRule[width=12em]{KT-WRITE}{
  \HasType\Env\this\C\\
  \Fdef\f\t \in \App\K\C \\
  \EnvType \Env\s\K\e\t
}{
  \EnvType \Env\s\K{\FWrite\f\e}\t
}    

\IRule[width=12em]{KT-REFWRITE}{
  \EnvType \Env\s\K\a\C \\
  \Fdef\f\t \in \App\K\C \\
  \EnvType \Env\s\K\e\t
}{
  \EnvType \Env\s\K{\FWriteR\a\f\e}\t
}  

\IRule[width=16em]{KT-CALL}{
  \EnvType \Env\s\K\e\C \\
  \Mtype\m\t\tp \in \classoff\C\K \\
  \EnvType \Env\s\K\ep\t
}{
  \EnvType \Env\s\K{\KCall\e\m\ep\t\tp}\tp
}    

\IRule{KT-DYNCALL}{
  \EnvType \Env\s\K\e\any \\
  \EnvType \Env\s\K\ep\any
}{
  \EnvType \Env\s\K{\DynCall\e\m\ep}\any
}    


\IRule[width=20em]{KT-NEW}{
 \EnvType \Env\s\K{\e_1}{\t_1}\dots 
 \EnvType \Env\s\K{\e_n}{\t_n}\ \\ 
 \b\fd=\Fdef{\f_1}{\t_1}\dots\Fdef{\f_n}{\t_n} \\ 
  \Class \C {\b\fd}{\b\md} \in \K
}{
  \EnvType\Env\s\K{\New\C{\e_1\dots\e_n}}\C
}

\IRule{KT-SUBCAST}{
  \EnvType \Env\s\K\e\tp
}{
  \EnvType \Env\s\K{\SubCast\t\e}\t
}

\IRule{KT-BEHCAST}{
  \EnvType \Env\s\K\e\tp
}{
  \EnvType \Env\s\K{\BehCast\t\e}\t
}

\\

\IRule{KT-REFTYPE}{
  \s(\a) = \obj\C{\b\ap}
}{
  \EnvType \Env\s\K\a\C
}

\IRule{KT-REFANY}{
 }{
   \EnvType \Env\s\K\a\any
}
\end{mathpar}


\subsection{Field access}

The function $\readf\s\a\f\K$ reads the value in the field \f in the object \a.

\(
\begin{array}{r@{~}l}
\readf \s\a\f\K &= \ap\\ 
    ~~\mathit{if}~~ &\s(\a) = \obj\C{\a_i \dots ~\ap~ \a_j \dots}\\
    ~~\mathit{and}~~ &\Class\C {\fd_i \dots ~\Fdef{\f}{\t}~ \fd_j \dots}{\md \dots}\in\K \\
\end{array} 
\)

\subsection{Field write}

The function \setf\s\a\f\ap\K denotes writing of value \ap to the field \f of
the object stored at \a in \s.


\(
\begin{array}{r@{~}l}
\setf \s\a\f\ap\K &= \Map\s{\Bind{\a}{\obj\C{\a_i\dots ~\ap~ \a_j\dots}}}\\
  ~~\mathit{if}~~ &\s(\a) = \obj\C{\a_i\dots ~\app~ \a_j\dots} \\
  ~~\mathit{and}~~&\Class\C{\fd_i \dots ~\Fdef{\f}{\t}~ \fd_j\dots}{\md \dots}\in\K
\end{array}
\)

\subsection{Method overloading}

The function $\xt{overloading}(\b\md ~ \b\fd)$ there are no overloaded method names in the
given method definitions.


\opdef{~\xt{overloading}$_{\cmd}$(\b\md ~\b\fd)}{Method overloading}
\begin{mathpar}
\IRule{MO1}{
}{
\xt{overloading}_{\cmd}(\emptyset)
}

\IRule{MO2}{
 \Mtype\m\any\any \notin \b\md \\
 \cmdp = \cmd, \Mtype\m\any\any \\
 \xt{overloading}_{\cmdp}(\b\md\,\b\fd)
}{
\xt{overloading}_{\cmd}(\Mdef\m\x\any\any\e~\b\md~\b\fd)
}

\IRule{MO3}{
 \Mtype\m\t\t \in \b\md \implies \t = \any \\
 \cmdp = \cmd, \Mtype\m\t\t \\
 \xt{overloading}_{\cmdp}(\b\md\,\b\fd)
}{
\xt{overloading}_{\cmd}(\Mdef\m\x\C\Cp\e~\b\md~\b\fd)
}
\end{mathpar}

\opdef{~\xt{overloading}$_{\cmd}$(\b\fd)}{field overloading}
\begin{mathpar}
\IRule{FO1}{
 \f \notin \xt{names}(\cmd) \\
 \cmdp = \cmd, \Fdef\f\t \\
 \xt{overloading}_{\cmdp}(\b\fd)
}{
\xt{overloading}_{\cmd}(\Fdef\f\t ~ \b\fd)
}
\end{mathpar}

\subsection{Behavioural cast dynamics}

\begin{figure}[!ht]
\vspace{-2mm}

{  
  \begin{mathpar}
  
\IRule{BC1}{
  \App\s\a = \obj\C{\b{\a_1}}  \\
  \fresh\D \\
  \fresh\ap \\
  \fresh\that \\
  \cload{\classoff\C\K} \\
  \names{\classoff\Cp\K} \subseteq \names{\classoff\C\K} \\
  \k = \wrap\C{\classoff\C\K}{\classoff\Cp\K}\D\that \\
  \sp = \Map \s{\Bind\ap{\obj\D{\a}}} \\  
}{
  \behcast\a\Cp\s\K {\K\,\k}\ap\sp
}

\IRule{BC2}{
  \App\s\a = \obj\C{\b{\a_1}}  \\
  \fresh\D \\
  \fresh\ap \\
  \fresh\that \\
  \k = \wrapAny\C{\classoff\C\K}\D\that\\
  \sp = \Map \s{\Bind\ap{\obj\D{\a}}} \\  
}{
  \behcast\a\any\s\K {\K\,\k}\ap\sp
}
\end{mathpar}}  

\vspace{-2mm}
\caption{Behavioural casts.}\label{behaves}
\end{figure}


\subsection{Class wrapper for Behavioural semantics}\label{wrap}

The \xt{wrap} function is used by the Type Racket language to generate the wrapper classes
for the behavioral cast semantics. The \xt{wrap} function takes two class types and the two
sets of method typing. The class type $\C$ is the type of the expression being casted, also known 
as the source type and represented by $\tp$ in the typing rule \xt{WB}.
The class type $\D$ is a fresh type, and represents the type of the wrapper class.
The method typing $\bmt$ corresponds to the typing definition of every method in $\C$.
The method typing $\bmtp$ is the set of method typing for the casting type. The casting
type is also known as the target type, shown by $\t$ in \xt{WB}. \\
 
\opdef{\mt ~~::= \Mtype\m\t\t \B  \Mtype\f\t\t  \B \Mtype\f{}\t 
}{ method typing
} \\

Every wrapper class has a \xt{that} field pointing to the source type.


The last three cases is for when the methods are in the source type but not the 
target type. For each of these method, their method call is redirected 
to its corresponding method in the source type.


\renewcommand{\bscast}[2]{\EM{\BehCast{#1}{{#2}}}}

\vspace{4mm}
%%%%%%%%%%%%%%%%%%%%%% WRAP %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\IGNOREUNLESSNEEDED{
\[\begin{array}{@{}ll@{}l@{}r@{~}c@{~}r}
    \wrap\C\bmt\bmtp\D\that = \\
\SP \class ~\D ~ \{\\
\SPP \Fdef\that\C \\
\\
\SPP \Mdef\m\x\Dp\Dpp {~\bscast\Dpp{{\KCall{\this.\that()_{\C}} \m {\bscast{\Cp}\x}\Cp\Cpp }}~}
&     if\,\,\,\,\,\, \Mtype\m\Cp\Cpp\in\bmt ~\wedge~ \Mtype\m\Dp\Dpp\in\bmtp ~\wedge~ \\
&     \multicolumn{5}{l}{\qquad \Mtype\m\any\any\not\in\bmt ~\wedge~ \Mtype\m\any\any\not\in\bmtp} \\
\\
\SPP \Mdef\m\x\Dp\Dpp{~\bscast\Dpp{\KCall{\this.\that()_{\C}} \m {\bscast\any\x}\any\any }~}
&    if\,\,\,\,\,\, \Mtype\m\any\any\in\bmt ~\wedge~ \Mtype\m\Dp\Dpp\in\bmtp ~\wedge~  \\
&     \multicolumn{5}{l}{\qquad \Mtype\m\Cp\Cpp\not\in\bmt ~\wedge~  \Mtype\m\any\any\not\in\bmtp } \\
\\
\SPP \Mdef\m\x\any\any{~\bscast\any{\KCall{\this.\that()_{\C}}\m{\bscast{\Cp}\x}\Cp\Cpp}~}
&    if\,\,\,\,\,\, \Mtype\m\Cp\Cpp\in\bmt ~\wedge~ \Mtype\m\any\any\in\bmtp ~\wedge~   \\
&     \multicolumn{5}{l}{\qquad \Mtype\m\any\any\not\in\bmt ~\wedge~  \Mtype\m\Dp\Dpp\not\in\bmtp } \\
\\
\SPP \Mdef\m\x\any\any{~{\KCall{\this.\that()_{\C}}\m{\x}\any\any}~}
&    if\,\,\,\,\,\, \Mtype\m\any\any\in\bmt ~\wedge~ \Mtype\m\any\any\in\bmtp ~\wedge~ \\
&     \multicolumn{5}{l}{\qquad \Mtype\m\Cp\Cpp\not\in\bmt ~\wedge~ \Mtype\m\Dp\Dpp\not\in\bmtp} \\
\\
\SPP \Mdef\m\x{\t}{\tp}{~\KCall{\this.\that()_{\C}}\m{\x}\t\tp~}
&    if\,\,\,\,\,\, \Mtype\m\t\tp\in\bmt ~\wedge~ \Mtype\m\tpp\tppp\not\in \bmtp \\
\\
\SP \}
\\
\end{array}\]

\[\begin{array}{@{}ll@{}l@{}r@{~}c@{~}r}
\wrapAny\C\bmt\D\that = \\
\SP \class~\D~\{\\
\SPP \Fdef \that \C\\ 
\SPP   \Mdef\m\x\any\any {~\bscast\any{\Call{\FRead\that\C}{\m_}{\bscast{\t}\x} }~}
&  \Mtype\m\t\t\in\b\mt \\
\SP \}\\
\end{array}\]


\subsection{Mtype function}

The \texttt{mtypes} function takes a class name $\C$ and the class table
$\K$, and outputs a list of typing signatures $\b\mt$ for every method in
class $\C$, which includes the implicit getter and setter methods for every
field in the definition of class $\C$.  (\textbf{Note}: An user cannot
define a getter or setter method for any field that already exists in the
class. Similarly, a field cannot be declared in a class that already has a
getter or setter method for that field. This is enforced by the
\texttt{overloading} function in class well-formedness.) \\

\begin{equation*}
\classoff\C\K = \b\mt ~~\mathit{if}~~ \begin{cases}

 \Class \C {\b{\Ftype\f\t}}{\b\md} \in \K\\
 \b\mt = \sign{\b\md} 
%  \oplus \forall ~\Ftype\f\t \in \b{\Ftype\f\t} ~|~ \f \notin \names{\b\md} ~\wedge~ \f\neq\that ~.~ \typez{\Ftype\f\t}

\end{cases}
\end{equation*}

\subsection{getmds function}

The function $\getmds\C\K$ denotes the function that returns the method definitions inside the class \C.

\begin{equation*}
\getmds\C\K = \b\md ~~\mathit{if}~~ \Class\C{\b{\fd}}{\b\md} \in \K
\end{equation*}

\subsection{Dynamic function}

The \xt{dyn} function returns all the methods with $\star$ type for a particular set of 
signatures of method typing.

\begin{mathpar}
\IRule{DYNE}{
}{
  \dyn{\cdot} = \cdot
}

\IRule{DYN}{
 \dyn{\b\mt} = \b{\mtp} \\
}{
  \dyn{\Mtype{\m}{\t}{\t} ~\,\b\mt} = \Mtype{\m}{\any}{\any}~\,\b\mtp
}
\end{mathpar}

\subsection{Signature function}

The \xt{signature} function returns method typing signatures ($\mt$) of method definitions ($\md$).

\begin{mathpar}
\IRule{SGE}{
}{
  \sign{\cdot} = \cdot
}

\IRule{SG}{
  \md = \Mdef\m\x\t\t\e \\
  \sign{\b\md} = \b\mt \\
}{
  \sign{\md\,\b\md} = \Mtype\m\t\t~~\b\mt
}
\end{mathpar}

\subsection{Names function}

The \xt{Names} function takes either a field definition, method definition, or method typing, and returns the name of the respective
field/method.

\begin{mathpar}
\IRule{NE}{
}{
\names{\emptyset} = \emptyset
}
\end{mathpar}

\opdef{~\names{\b\fd}}{field naming}
\begin{mathpar}
\IRule{NF}{
 \b\x = \f, ~\names{\b\fd}
}{
\names{\Fdef\f\t, ~\b\fd} = \b\x
}
\end{mathpar}

\opdef{~\names{\b\md}}{method naming}
\begin{mathpar}
\IRule{NM}{
 \b\x = \m, ~\names{\b\md}
}{
\names{\Mdef\m\x\t\t\e, ~\b\md} = \b\x
}
\end{mathpar}

\opdef{~\names{\b\mt}}{type naming}
\begin{mathpar}
\IRule{NMT}{
 \b\x = \m, ~\names{\b\md}
}{
\names{\Mtype\m\t\t, ~\b\mt} = \b\x
}

\end{mathpar}

\subsection{Duplicated method names}


\begin{mathpar}
\IRule{CMTE}{
}{
\cload{\emptyset}
}
\end{mathpar}


\opdef{\cload\mt}{Duplicated method name over $\mt$}
\begin{mathpar}
\IRule{CMT}{
 \m \not\in \names\bmt \\
 \cload\bmt
}{
\cload{\Mtype\m\t\t \,\, \b\mt}
}
\end{mathpar}

\opdef{\cload\md}{Duplicated method name over $\md$}
\begin{mathpar}

\IRule{CMT}{
 \m \not\in \names\bmd \\
 \cload{\bmd}
}{
\cload{\Mdef\m\x\t\t\e \,\, \bmd}
}
\end{mathpar}

\clearpage



\section{Source language syntax and semantics}

\subsection{Syntax}

\begin{figure}[!h]\hrulefill

\hspace{0.1cm}
\begin{minipage}{5.9cm}\begin{tabular}{@{}l@{~}l@{}l@{}l@{}ll}
\e &::=  \x          &\B \this          \\
   &\B \New\C{\b\e}  &\B \FRead\f       \\
   &\B \FWrite\f\e   &\B \Call\e\m\e \\ 
\end{tabular}\end{minipage}
\begin{minipage}{5.9cm}\begin{tabular}{l@{~}l@{}l@{}l}
   ~ \k &::= \Class \C {\b\fd}{\b\md}
\end{tabular}
\begin{tabular}{l@{~}l@{}l@{}l}
\md &::= \Mdef\m\x\t\t\e \\
%\mt &::= \Mtype\m\t\t &\B~  \Mtype\f\t\t  &\B \Mtype\f{}\t  \\ 
~ \t&::= ~ \any   \B   \C   \B   \CW \\ 
~\fd&::= ~ \Fdef\f\t \\ 
\end{tabular}\end{minipage}

\hrulefill
\caption{Source language syntax.}\label{sou-syn}
\end{figure}

\subsection{Thorn subtyping}

% \dt\C~\src\Sub~\dt\D and \C~\src\Sub~\dt\D both hold if \C~\src\Sub~\D

\begin{mathpar}
\IRule{TSWeak}{
  \ThorSub \M\K\C\D
}{
  \ThorSub \M\K{\dt\C}{\dt\D}
}

\IRule{TSLow}{
  \ThorSub \M\K\C\D
}{
  \ThorSub \M\K{\C}{\dt\D}
}
\end{mathpar}

\begin{mathpar}
\IRule{TSRef}{
}{
 \ThorSub\M\K \t \t
}

\IRule{TSAss}{
\C \Sub_t \D \in \M
}{
 \ThorSub\M\K \C \D
}

\IRule{TSRec}{
 \M' = \M~\C\Sub_t\D\\
\mt \in \classoff\D\K \implies \mtp \in \classoff\C\K ~.~ \ThorSub{\M'}\K\mt{\mtp}
}{
 \ThorSub\M\K \C \D 
}
\end{mathpar}

\begin{mathpar}
\IRule{TSMet}{
  \ThorSub \M\K {\t[1]} {\t[2]} \\
  \ThorSub \M\K {\tp[2]} {\tp[1]}
}{
 \ThorSub \M\K {\Mtype\m{\t[1]}{\tp[1]}} {\Mtype\m{\t[2]}{\tp[2]}}
}
\end{mathpar}



\subsection{Thorn well-formedness}

\opdef{~\WFpW{\e}{\K}}{Well-formed programs}
\opdef{\WFW{}\s\K {\Class\C{\b\fd}{\b\md}}}{Well-formed classes}
\opdef{~\WFW \Env\s\K \md}{Well-formed methods}
\opdef{~\WFtypeW \K {\Fdef\f\t}}{Well-formed fields}
\opdef{~\WFtypeW\K\t}{Well-formed types}

\begin{mathpar}
\IRule{WP}{
  \k \in \K \implies \WFW{}\K\k \\
  \EnvTypeW\Env\K\e\t
}{
  \WFpW\e\K
}

\IRule[width=25em]{WCL}{
 \xt{overloading}_{\emptyset}(\b\fd,\b\md) \\
 \fd\in\b\fd\implies \WFW {}\K \fd \\
 \md\in\b\md\implies \WFW {\text{this}:\C~}\K \md 
}{
 \WFW {}\K {\Class \C {\b\fd}{\b\md}}
}

\IRule[width=18em]{WT}{
 \EnvTypeW {\Env{~\Ftype\x\C}~}\K\e\D\\
 \WFtypeW\K\C \\
 \WFtypeW\K\D \\
}{
 \WFW \Env\K {\Mdef\m\x\C\D\e}
}

\IRule[width=18em]{WWT}{
 \EnvTypeW {\Env{~\Ftype\x\t}~}\K\e\tp\\
 \WFtypeW\K\t \\
 \WFtypeW\K\tp \\
 \kty\t = \kty\tp = \any
}{
 \WFW \Env\K {\Mdef\m\x\t\tp\e}
}

\IRule{WF}{
 \WFtypeW\K\t 
}{
 \WFtypeW\K{\Fdef\f\t}
}

\\

\IRule{WA}{
}{
 \WFtypeW\K\any
}

\IRule{WC}{
 \C \in \K
}{
 \WFtypeW\K\C
}

\IRule{WW}{
 \C \in \K
}{
 \WFtypeW\K{\CW}
}
\end{mathpar}

\subsection{Thorn expression typing}


\opdef{\ConvertE\K{th}\t\tp}{type convertibility between \t and \tp.}
\begin{mathpar}

\IRule{STHC-SUB}{
  \ThorSub\cdot\K\t\tp
}{
  \ConvertE\K{th}\t\tp
}

\IRule{STHC-TOANY}{
}{
  \ConvertE\K{th}\t\any
}

\IRule{STHC-OPTCONC}{
  \ThorSub\cdot\K\C\D
}{
  \ConvertE\K{th}\CW\D
}

\IRule{STHC-ANYCONC}{
}{
  \ConvertE\K{th}\any\tp
}

\end{mathpar} \\

\opdef{\EnvType\Env\s\K\e\t}{\e has type \t in environment \Env against heap \s and class table \K}
\begin{mathpar}
\IRule{STH-VAR}{
   \HasType \Env\x\t
 }{
   \EnvTypeW \Env\K\x\t
}

\IRule{STH-GET}{
  \HasType \Env\this\C \\
  \Fdef\f\t \in \App\K\C
}{
  \EnvTypeW \Env\K{\FRead\f}\t
}    

\IRule[width=20em]{STH-SET}{
  \HasType \Env\this\C \\
  \Fdef\f\t \in \App\K\C \\
  \EnvTypeW \Env\K\e\tp \\
  \ConvertE\K{th}\tp\t
}{
  \EnvTypeW \Env\K{\FWrite\f\e}\t
}    

\IRule[width=20em]{STH-CALL}{
  \EnvTypeW \Env\K\e\C ~~\vee~~ \EnvTypeW \Env\K\e\CW \\
  \Mtype \m{\t}\tp\in \classoff{\C}\K  \\
  \EnvTypeW \Env\K\ep\tpp \\
  \ConvertE\K{th}\tpp\t
}{
  \EnvTypeW \Env\K{\Call\e\m\ep}\tp
}    

\IRule[width=20em]{STH-DCALL}{
  \EnvTypeW \Env\K\e\any \\
  \EnvTypeW \Env\K\ep\tpp \\
  \ConvertE\K{th}\tpp\any
}{
  \EnvTypeW \Env\K{\Call\e\m\ep}\any
}    

\IRule{STH-NEW}{
 \EnvTypeW \Env\K{\e_1}{\tp_1} ~~\dots~~ \EnvTypeW \Env\K{\e_n}{\tp_n} \\
 \ConvertE\K{th}{\tp[1]}{\t[1]} ~~\dots~~ \ConvertE\K{th}{\tp[n]}{\t[n]} \\
 \b\fd=\Fdef{\f_1}{\t_1}~\dots~\Fdef{\f_n}{\t_n} \\ 
  \Class \C {\b\fd}{\b\md} \in \K
}{
  \EnvTypeW \Env\K{\New\C{\e_1\dots\e_n}}\C
}
\end{mathpar}

\subsection{Non-thorn well-formedness}

We use $x$ as a placeholder to mean either $s$ (for the basic source typing, used by Typed Racket and Typescript) or $tr$ (transient, used by the transient semantics).

\opdef{~$\WFpx{\e}{\K}$}{Well-formed programs}
\opdef{\WFx{}\s\K {\Class\C{\b\fd}{\b\md}}}{Well-formed classes}
\opdef{~\WFx \Env\s\K \md}{Well-formed methods}
\opdef{~\WFtypex \K {\Fdef\f\t}}{Well-formed fields}
\opdef{~\WFtypex\K\t}{Well-formed types}

\begin{mathpar}
\IRule{SWF-PROG}{
  \k \in \K \implies \WFx{}\cdot\K\k \\
  \EnvTypex\Env\cdot\K\e\t
}{
  \WFpx\e\K
}

\IRule[width=25em]{SWF-CLASS}{
 \xt{overloading}_{\emptyset}(\b\fd,\b\md) \\
 \fd\in\b\fd\implies \WFx {}{}\K \fd \\
 \md\in\b\md\implies \WFx {\text{this}:\C~}{}\K \md 
}{
 \WFx {}{}\K {\Class \C {\b\fd}{\b\md}}
}

\IRule[width=18em]{SWF-TYMETH}{
 \EnvTypex {\Env{~\Ftype\x\C}~}\K\e\D\\
 \WFtypex\K\C \\
 \WFtypex\K\D \\
}{
 \WFx \Env\K {\Mdef\m\x\C\D\e}
}

\IRule[width=18em]{SWF-DYMETH}{
 \EnvTypex {\Env{~\Ftype\x\any}~}\K\e\any\\
 \WFtypex\K\any \\
 \WFtypex\K\any
}{
 \WFx \Env\K {\Mdef\m\x\any\any\e}
}

\IRule{SWF-FIELD}{
 \WFtypex\K\t 
}{
 \WFtypex\K{\Fdef\f\t}
}

\\

\IRule{SWT-ANY}{
}{
 \WFtypex\K\any
}

\IRule{SWT-TYPE}{
 \C \in \K
}{
 \WFtypex\K\C
} 
\end{mathpar}

\subsection{Typescript and Typed Racket expression typing}

\opdef{\ConvertE\K{s}\t\tp}{type convertibility between \t and \tp.}
\begin{mathpar}

\IRule{STGC-SUB}{
  \StrSub\cdot\K\t\tp
}{
  \ConvertE\K{s}\t\tp
}

\IRule{STGC-TOANY}{
}{
  \ConvertE\K{s}\t\any
}

\IRule{STGC-ANYCONC}{
}{
  \ConvertE\K{s}\any\tp
}

\end{mathpar} \\


\opdef{\EnvTypeS\Env\K\e\t}{\e has type \t in environment \Env against heap  and class table \K}
\begin{mathpar}

\IRule{STG-VAR}{
   \HasType \Env\x\t
 }{
   \EnvTypeS \Env\K\x\t
} 

\IRule{STG-GET}{
   \HasType \Env\this\C \\
  \Fdef\f\t \in \App\K\C
}{
  \EnvTypeS \Env\K{\FRead\f}\t
}    

\IRule{STG-SET}{
  \HasType \Env\this\C \\
  \Fdef\f\t \in \App\K\C \\
  \EnvTypeS \Env\K\e\tp \\
  \ConvertE\K{s}\tp\t
}{
  \EnvTypeS \Env\K{\FWrite\f\e}\t
}    

\IRule[width=20em]{STG-CALL}{
  \EnvTypeS \Env\K\e\C \\
  \Mtype \m\t\tp\in \classoff\C\K  \\
  \EnvTypeS \Env\K\ep\tpp \\
  \ConvertE\K{s}\tpp\t
}{
  \EnvTypeS \Env\K{\Call\e\m\ep}\tp
}    

\IRule[width=20em]{STG-DCALL}{
  \EnvTypeS \Env\K\e\any \\
  \EnvTypeS \Env\K\ep\tpp \\
  \ConvertE\K{s}\tpp\any
}{
  \EnvTypeS \Env\K{\Call\e\m\ep}\any
}    

\IRule{STG-NEW}{
 \EnvTypeS \Env\K{\e_1}{\tp[1]}~~\dots~~ 
 \EnvTypeS \Env\K{\e_n}{\tp[n]}\ \\  
 \ConvertE\K{s}{\tp[1]}{\t[1]} ~~\dots~~ \ConvertE\K{s}{\tp[n]}{\t[n]} \\
 \b\fd=\Fdef{\f_1}{\t_1}~\dots~\Fdef{\f_n}{\t_n} \\ 
  \Class \C {\b\fd}{\b\md} \in \K
}{
  \EnvTypeS \Env\K{\New\C{\e_1\dots\e_n}}\C
}
\end{mathpar}

\subsection{Transient expression typing}

\opdef{\ConvertE\K{tr}\t\tp}{type convertibility between \t and \tp.}
\begin{mathpar}

\IRule{STTC-SUB}{
  \ConSub\cdot\K\t\tp
}{
  \ConvertE\K{tr}\t\tp
}

\IRule{STTC-TOANY}{
}{
  \ConvertE\K{tr}\t\any
}

\IRule{STTC-ANYCONC}{
}{
  \ConvertE\K{tr}\any\tp
}

\end{mathpar} \\

\opdef{\EnvTypeT\Env\K\e\t}{\e has type \t in environment \Env against heap  and class table \K}
\begin{mathpar}

\IRule{STT-VAR}{
   \HasType \Env\x\t
 }{
   \EnvTypeT \Env\K\x\t
}

\IRule{STT-GET}{
   \HasType \Env\this\C \\
  \Fdef\f\t \in \App\K\C
}{
  \EnvTypeT \Env\K{\FRead\f}\t
}    

\IRule{STT-SET}{
  \HasType \Env\this\C \\
  \Fdef\f\t \in \App\K\C \\
  \EnvTypeT \Env\K\e\tp \\
  \ConvertE\K{tr}\tp\t
}{
  \EnvTypeT \Env\K{\FWrite\f\e}\t
}    

\IRule[width=20em]{STT-CALL}{
  \EnvTypeT \Env\K\e\C \\
  \Mtype \m\t\tp\in \classoff\C\K  \\
  \EnvTypeT \Env\K\ep\tpp \\
  \ConvertE\K{tr}\tpp\tp
}{
  \EnvTypeT \Env\K{\Call\e\m\ep}\tp
}    

\IRule[width=20em]{STT-DCALL}{
  \EnvTypeT \Env\K\e\any \\
  \EnvTypeT \Env\K\ep\tpp \\
  \ConvertE\K{tr}\tpp\any
}{
  \EnvTypeT \Env\K{\Call\e\m\ep}\any
}    

\IRule{STT-NEW}{
 \EnvTypeT \Env\K{\e_1}{\tp[1]}~~\dots~~ 
 \EnvTypeT \Env\K{\e_n}{\tp[n]}\ \\ 
 \ConvertE\K{tr}{\tp[1]}{\t[1]} ~~\dots~~ \ConvertE\K{tr}{\tp[n]}{\t[n]} \\ 
 \b\fd=\Fdef{\f_1}{\t_1}~\dots~\Fdef{\f_n}{\t_n} \\ 
  \Class \C {\b\fd}{\b\md} \in \K
}{
  \EnvTypeT \Env\K{\New\C{\e_1\dots\e_n}}\C
}
\end{mathpar}

\section{Translations}

\subsection{Thorn}

\begin{tabular}{@{}l@{~ ~ ~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}ll}
\small
  \hspace{-.5cm}\begin{minipage}{8cm}  
\begin{tabbing}
\TR{\Class \C{\fds 1..}{\mds 1 .. }}\= = \src{ \Class \C{ \fdsp 1..}{\mdsp 1..~ \mdspp 1..}} 
\HS \WHERE~\= \fdsp 1 = \src{\Ftype\f{\kty\t}} .., \HS\HS\HS\HS\HS \=\fds 1 = \Ftype\f\t ..   \\
\> \mdsp 1 = \src{\Mdef\m\x{\kty{\t_1}}{\kty{\t_2}}{\ep}} .., \HS \> \mds 1 = \Mdef\m\x{\t_1}{\t_2}\e ..,\HS\HS\> \ep = \TAG{\e}{\this:\C\,\x:{\t_1}}{\t_2} ..,\\
\> \mdspp 1 = \src{\Mdef\m\x\any\any{\SubCast\any{\KCall\this\m{\SubCast{\t_1}\x}{\t_1}{\t_2}}}}
\HS \IF \kty{\t_1} = \D \OR \kty{\t_2} = \D\\
          \>\hspace{1cm} empty \HS  {\bf otherwise}  ..   \\
\TR{\k .. \e} \>= \TR{\k} .. \TRG{\e}\cdot \\
\TR{\x:\t~\Env} \>= \x : \kty{\t} ~ \TR\Env
\end{tabbing}
\begin{tabbing}
TTR1 \TRG{\x}\Env \hspace{1.4cm}\= = \src \x
\\[1mm]       
TTR2 \TRG{\FRead\f}\Env \> = \src{\FRead\f} 
\\[1mm]
TTR3 \TRG{\FWrite\f\e}\Env \> = \src{\FWrite\f\ep} \hspace{.5cm} \=
\WHERE\HS\= \TypeCk{\K, \Env}\this\C, \HS  \Ftype\f\t\In\App\K\C, \HS \ep = \TAG\e\Env{\kty\t}
\\[1mm]
TTR4 \TRG{\Call{\e_1}\m{\e_2}}\Env \>= \src{\DynCall{\eps 1}{\m}{\eps 2}} 
\HS  \>\WHERE\HS \TypeCk{\K,\Env}{\e_1}\t, \HS \kty\t=\any, \HS
 \eps 1= \TRG{\e_1}\Env, \HS \eps 2=\TAG{\e_2}\Env\any
\\[1mm]
TTR5 \TRG{\Call{\e_1}\m{\e_2}}\Env \>= \src{\KCall{\eps 1}{\m}{\eps 2}{\t[2]}{\tp[2]}} 
\>\WHERE\HS   \TypeCk{\K,\Env}{\e_1}\C, \HS  \eps 1 = \TRG{\e_1}\Env, \HS
 \Mtype\m{\t[1]}{\tp[1]}\In\App\K\C, \HS  \eps 2 = \TAG{\e_2}\Env{\t[2]}, \\
 \> \> \> \t[2] = \kty{\t[1]}, \HS \tp[2] = \kty{\tp[1]}
\\[1mm]
TTR6 \TRG{\New\C{\e_1..}}\Env\> = \src{\New\C{\eps 1..}} 
     \>\WHERE\HS    \Ftype{\f_1}{\t_1}\In\C, \HS  \eps 1 = \TAG{\e_1}\Env{\t_1} ..
\\[1mm]
TTR7 \TAG\e\Env\t\> = \src\ep \> \WHERE\HS  \EM{\K\vdash\kty\tp \Sub \kty\t}, \TypeCk{\K,\Env}\e\tp, \ep = \TRG\e\Env
\\[1mm]
TTR8 \TAG\e\Env\t \>= \src{\SubCast{\kty\t}\ep}
\>\WHERE\HS  \EM{\K\vdash\kty\tp \not\Sub \kty\t}, \TypeCk{\K,\Env}\e\tp, \ep = \TRG\e\Env
\end{tabbing}
\end{minipage}
\end{tabular}
\clearpage

\subsection{TypeScript}

\begin{figure}[!h]
\begin{tabular}{@{}l@{~ ~ ~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}ll}
\small
 \begin{minipage}{8cm}  
\begin{tabbing}
\TR{\Class \C{\fds 1..}{\mds 1 .. } } = \src{ \Class \C{ \fdsp 1..}{\mdsp 1..}}\HS \WHERE\HS
  \=\fds 1 = \Ftype\f\t ..,\HS\HS\=\fdsp 1 = \src{\Ftype\f\any} .., \HS\HS\=\mds 1 = \Mdef\m\x{\t_1}{\t_2}\e \\
  \>\mdsp 1 = \src{\Mdef\m\x\any\any\ep},\HS\HS \>\>\ep = \TR{\e}
\end{tabbing}
\begin{tabbing}
TTS1 \TR{\FRead\f}\HS\HS\HS\HS\= = \src{\FRead\f}
\\[1mm]
TTS2 \tr e{\FWrite\f\e} \> = \src{\FWrite\f\ep} \HS\HS\HS\HS\HS\=\WHERE~\ep=\TR\e
\\[1mm]
TTS3 \TR\this           \>= \src{\SubCast\any\this}
\\[1mm]
TTS4 \TR\x \> = \src \x
\\[1mm]       
TTS5 \TR{\Call{\e_1}\m{\e_2}} \> = \src{\DynCall{\eps 1}{\m}{\eps 2}} \HS\>\WHERE\HS\eps 1 = \TR{ \e_1}, \HS \eps 2 = \TR{\e_2}
\\[1mm]
TTS6 \TR{\New\C{\e_1..}} \> = \src{\SubCast\any{\New\C{\eps 1..}}} \HS \>\WHERE \HS   \eps 1 = \TR{\e_1} ..
\end{tabbing}
\end{minipage}
\end{tabular}
\caption{TypeScript}
\end{figure}



\subsection{Typed Racket}

\begin{figure}[!h]
\begin{tabular}{@{}l@{~ ~ ~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}ll}
 \small
\begin{minipage}{8cm}  
\begin{tabbing}
\TR{\Class\C{\fds 1..}{\mds 1.. }} =  \src{\Class \C {\fds 1..}{\mdsp 1.. } }\\
\hspace{.7cm} \WHERE\HS 
\mdsp 1 = \src{\Mdef\m\x\t\tp{\eps 1}} ..,\HS\HS
\mds 1 = \Mdef\m\x\t\tp{\e_1} ..,\HS\HS
\eps 1 = \TRG{\e_1}{\x:\t\,\this:\C}
\end{tabbing}
\begin{tabbing}
TTK1 \TRG\x\Env = \src{\x}
\\[1mm]
TTK2 \TRG{\FRead\f}\Env  = \src{\FRead\f}
\\[1mm]
TTK3 \TRG{\FWrite\f\e}\Env =  \src{\FWrite\f\ep} \hspace{.5cm}
\=\WHERE
\= \TypeCk\K{\e_1}\C, \HS\HS
\= \Ftype\f\t\In\App\K\C, \hspace{1cm}
\=  \eps 1 = \TRG{\e_1}\Env,\HS\HS\HS
\= \eps 2 = \TAG\e\Env\t
\\[1mm]
TTK4 \TRG{\Call{\e1_1}\m{\e_2}}\Env = \src{\DynCall{\eps 1}\m{\eps 2}}
\>\WHERE \> \TypeCk{\K,\Env}{\e_1}\any, \HS
\> \eps 1 = \TRG{\e_1}\Env,\HS
\> \eps 2 = \TAG{\e_2}\Env\any
\\
TTK5 \TRG{\Call{\e1_1}\m{\e_2}}\Env = \src{\KCall{\eps 1}{\m}{\eps 2}{\D_1}{\D_2}}
\>\WHERE \> \TypeCk{\K,\Env}{\e_1}\C, \HS
\> \Mtype\m{\D_1}{\D_2}\In\App\K\C, \HS
\> \eps 1 = \TRG{\e_1}\Env,\HS
\> \eps 2 = \TAG{\e_2}\Env{\D_1}
\\[1mm]
TTK6 \TRG{\New\C{\e_1..}}\Env =  \src{\New\C{\eps 1..}}
   \>\WHERE \> \Ftype{\f_1}{\t_1}\In\App\K\C ~..
   \>       \>  \eps 1 = \TAG{\e_1}\Env{\t_1} ~..
\\[1mm]
TTK7 \TAG\e\Env\t = \src\ep
\> \WHERE\> \TypeCk{\K,\Env}\e\tp, \HS
\> \EM{\K\vdash \t \Sub \tp},
\>  \ep = \TRG\e\Env
\\[1mm]
TTK8 \TAG\e\Env\t = \src{\BehCast\t\e}
\>\WHERE\> \TypeCk{\K,\Env}\e\tp, \HS
   \> \EM{\K\vdash \t \not \Sub \tp}
   \>     \ep = \TRG\e\Env
\end{tabbing}
\end{minipage}
\end{tabular}
\caption{Typed Racket}\end{figure}

\clearpage
\subsection{Transient}

\begin{figure}[!h]
\begin{tabular}{@{}l@{~ ~ ~}ll}
 \small
\begin{minipage}{8cm}  
\begin{tabbing}
\TR{\Class\C{\fds 1..}{\mds 1.. }} =  \src{\Class \C {\fdsp 1..}{\mdsp 1.. } }\\
\hspace{.5cm}  \WHERE\HS \=
  \fdsp 1 = \src{\Ftype\f\any} .., \HS
  \fds 1 = \Ftype\f\t ..,\HS\HS
  \mdsp 1 = \src{\Mdef\m\x\any\any{\SubCast\t\x ~; ~\eps 1}} .., \HS
  \mds 1 = \Mdef\m\x\t\tp\e ..,\HS\HS
   \eps 1 = \TAG\e{\x:\t\,\this:\C}\tp~ ..
\end{tabbing}
\begin{tabbing}
\TRG\this\Env \hspace{1cm} \= = \src\this
\\[1mm]
\TRG\x\Env \>= \src{\SubCast\t\x} \hspace{1.5cm} \=\WHERE \HS \TypeCk{\K,\Env}\x\t
\\[1mm]
\TRG{\FRead\f}\Env \>= \src{\SubCast\t{\FRead\f}} \>\WHERE\HS  \TypeCk{\K,\Env}\this\C,\HS\HS\=\Ftype\f\t\In\App\K\C
\\[1mm]
\TRG{\FWrite\e}\Env \>=  \src{\SubCast\t{\FWrite\f\ep}}
  \>\WHERE\HS
  \TypeCk\K\this\C,
  \> \Ftype\f\t\In\App\K\C, \hspace{.7cm}
  \= \ep = \TAG\e\Env\any
\\[1mm]
  \TRG{\Call{\e1_1}\m{\e_2}}\Env \>= \src{\DynCall{\eps 1}\m{\eps 2}}
  \>\WHERE \HS 
  \TypeCk{\K,\Env}{\e_1}\any, \HS
  \> \eps 1 = \TRG{\e_1}\Env, 
  \> \eps 2 = \TAG{\e_2}\Env\any
\\[1mm]
\TRG{\Call{\e1_1}\m{\e_2}}\Env \>= \src{\SubCast\tp{\KCall{\eps 1}\m{\eps 2}\t\tp}}
   \>\WHERE\HS
   \TypeCk{\K,\Env}{\e_1}\C,
   \> \Mtype\m\t\tp\In\App\K\C,\HS
   \> \eps 1 = \TRG{\e_1}\Env, \HS\HS
   \eps 2 = \TAG{\e_2}\Env\any
\\[1mm]
\TRG{\New\C{\e_1..}}\Env \>=  \src{\New\C{\eps 1..}} \>\WHERE\HS
\Ftype{\f_1}{\t_1}\In\App\K\C,
  \>\eps 1 = \TAG{\e_1}\Env{\t_1} ~..
\\[1mm]
\TAG\e\Env\t \>= \src{\SubCast\t\e}
    \>\WHERE\HS \TypeCk{\K,\Env}\e\tp, \> (\t = \any \OR \tp = \any),\HS \> \ep = \TRG\e\Env
\\[1mm]
\TAG\e\Env\t \>= \src\ep \>\WHERE\HS  \TypeCk{\K,\Env}\e\tp, \HS\>(\EM{\ConSub{}\K\t\tp}),\HS \> \ep = \TRG\e\Env
\end{tabbing}
\end{minipage}
\end{tabular}
\caption{Transient}\end{figure}


\section{Proofs of Related Theorems}

\subsection{Accessory Lemmas}

\paragraph{Evaluation Extends Class Tables}

If $\Reduce \K\e\s \Kp\ep\sp$ then $\Kp = \K~\Kpp$ for some $\Kpp$.

\paragraph{Weakening of Expression Typing}

If $\EnvType\Env\s\K\e\t$ then $\EnvType{\Env~\Envp}\s\K\e\t$. \\ 
If $\EnvType\Env\s\K\e\t$ then $\EnvType\Env{\s~\s'}\K\e\t$. \\ 
If $\EnvType\Env\s\K\e\t$ then $\EnvType\Env\s{\K~\Kp}\e\t$. \\ 

\paragraph{Weakening of Well-formedness}

If $\WFtype\K\t$ then $\WFtype{\K~\Kp}\t$. \\
If $\WF\Env\s\K\md$ then $\WF{\Env~\Envp}\s\K\md$.\\
If $\WF\Env\s\K\md$ then $\WF\Env{\s~\s'}\K\md$.\\
If $\WF\Env\s\K\md$ then $\WF\Env\s{\K~\Kp}\md$.\\
If $\WFtype\K{\Fdef\f\t}$ then $\WFtype{\K~\Kp}{\Fdef\f\t}$.\\
If $\WFtype\K\t$ then $\WFtype{\K~\Kp}\t$.\\

\paragraph{Weakening of Subtyping}

If $\StrSub\M{\K}\t\tp$ then $\StrSub\M{\K~\Kp}\t\tp$. \\
If $\StrSub{\M}{\K}\t\tp$ then $\StrSub{\M~\M'}{\K}\t\tp$.

\paragraph{Weakening of $\xt{mtypes}$}

If $\Mtype\m{\HT\x\t}\tp \in \classoff{\C}{\K}$, then $\Mtype\m{\HT\x\t}\tp \in \classoff{\C}{\K~\Kp}$ for some $\Kp$.

\paragraph{Substitution}

If $\EnvType{\b{\HT\x\tp}}\s\K\e\t$ and $\b{\EnvType\cdot\s\K\a\tp}$, then $\EnvType\cdot\s\K{[\a/\x]\e}\t$

\paragraph{Correctness of \classoff{\C}{\K}}

If $\Mtype\m{\t}\tp \in \classoff{\C}{\K}$, $\EnvType\cdot\s\K\a\C$ and 
$\EnvType\cdot\s\K\ap\t$, then $\Reduce \K{\KCall\a\m{\ap}{\t}{\tp}}\s \K\epp\s$ where $\EnvType\cdot\s\K\epp\tp$. 

\paragraph{Canonical forms}

If $\WFp\K{\e~\s}$ and $\EnvType\cdot\s\K\a\C$, then $\s[\a\mapsto{\obj\C{\b\a}}]$.

\paragraph{Evaluation retains typing} \label{lem:ert}

If $\EnvType\cdot\s\K\e\t$, $\EnvType\cdot\s\K\ep\tp$, and $\WFp\K{\ep~\s}$, then if $\Reduce\K\ep\s\Kp\epp\sp$, it follows that $\EnvType\cdot\sp\Kp\e\t$ and $\Kp = \K~\Kpp$.

\subsection{Reduction preserves Well-formedness}

If $\Reduce \K\e\s \Kp\ep\sp$ and $\WFp\K{\e~\s}$, then $\WFp\Kp{\ep~\sp}$. 

\subsection{Consistent Class Table}

If $\WFp\K{\e~\s}$, then $\forall~\Class\C{\b{\fd}}{\b\md}~.~\WFtype\K{\b\fd}~\wedge~\WF\cdot\s\K{\b\md}$

\subsection{Correctness of $\xt{wrap}$}

If $\WFp \K$ (TODO), if $\C \in \K$, $\Cp \in \K$, $\D$ free, $\b\md = \getmds\C\K$, $\bmt = \classoff\C\K$, $\bmtp = \classoff\Cp\K$, and $\k = \wrap\C\bmt\bmtp\D\that$, then $\StrSub\cdot{\K~\k}\D\Cp$ and $\WFp \k$.

\subsection{Type Soundness of Core \kafka Typing}

Given that $\WFp\K{\e~\s}$ and $\EnvType\cdot\s\K\e\t$, then either there is some $\ep$ and $\Kpp$ (with $\Kp = \K~\Kpp$) 
such that $\Reduce \K\e\s \Kp\ep\sp$ and $\WFp\Kp{\ep~\sp}$ and $\EnvType\cdot\sp\Kp\ep\t$ hold, 
or $\e$ is stuck in one of the following forms:
\begin{itemize} 
\item $\a$
\item $\EE[\DynCall\a\m{\ap}]$
\item $\EE[\SubCast\tp\a]$
\item $\EE[\BehCast\tp\a]$
\end{itemize}

We proceed with rule induction on the judgement used to conclude $\EnvType\Env\s\K\e\t$. 
Note that we refer to rule preconditions from left to right.

\begin{itemize}
  \item \RuleRef{KT-VAR}
        Not applicable, since $\Gamma = \cdot$ and therefore contains no variables.
  \item \RuleRef{KT-SUB}
        We apply the IH to the first precondition. If we get stuck in the IH, then the entire
        expression gets stuck or terminates, trivially. Therefore, the interesting case is when
        $\Reduce \K\e\s \Kp\ep\sp$, $\WFp\Kp{\ep~\sp}$ and $\EnvType\cdot\sp\Kp\ep\tp$. Since, by the
        second precondition, we know that $\StrSub \M\K \tp \t$, it follows by weakening of subtyping $\StrSub\M\Kp\tp\t$.
        We can then apply \RuleRef{W2} to find that $\EnvType\cdot\sp\Kp\ep\t$, and therefore $\Reduce\K\e\s\Kp\ep\sp$, $\WFp\Kp{\ep~\sp}$, and $\EnvType\cdot\sp\Kp\ep\t$, and the theorem holds.
  \item \RuleRef{KT-READ}
        Since $\Gamma = \cdot$ by assumption, \RuleRef{KT-READ} cannot have applied.
  \item \RuleRef{KT-REFREAD}
        By inversion of $\RuleRef{KT-REFREAD}$, we know that the expression is of form $\FReadR\a\f$. It follows from $\Fdef\f\t \in \App\K\C$ that $\Class\C{\fd_i \ldots~\Fdef\f\t ~ \fd_j \ldots}{\md~\ldots}$ and from well-formedness of heaps that $\App\sigma\a = \Map\s{\Bind{\a}{\obj\C{\a_i\dots ~\ap~ \a_j\dots}}}$ that $\EnvType\cdot\s\K\ap\t$. Therefore, $\Reduce\K{\FReadR\a\f}\s\K\ap\s$ and $\WFp\K{\ap~\s}$, so the theorem holds.
  \item \RuleRef{KT-WRITE}
        Since $\Gamma = \cdot$ by assumption, \RuleRef{KT-WRITE} cannot have applied.
  \item \RuleRef{KT-REFWRITE}
        By inversion of $\RuleRef{KT-REFWRITE}$, we know that the expression is of form $\FWriteR\a\f\e$. Applying the IH to the third precondition, we find that either $\e$ is a value $\ap$, $\e$ is stuck, or $\Reduce\K\e\s\Kp\ep\sp$, $\WFp\Kp{\ep~\sp}$, and $\EnvType\cdot\sp\Kp\ep\C$. 

        If $\e$ steps to some $\ep$, we can trivially apply $\RuleRef{KT-REFWRITE}$ again, with weakening of typing over class tables and heaps, to conclude that $\EnvType\cdot\sp\Kp{\FWriteR\a\f\ep}\t$.

        If $\e$ is a value $\ap$, then it follows from $\Fdef\f\t \in \App\K\C$ that $\Class\C{\fd_i \ldots~\Fdef\f\t ~ \fd_j \ldots}{\md~\ldots}$ and from well-formedness of heaps that $\App\sigma\a = \Map\s{\Bind{\a}{\obj\C{\a_i\dots ~\app~ \a_j\dots}}}$. Therefore, we can apply the definition of $\xt{write}$ to find that $\setf\s\a\f\K\ap = \Map\s{\Bind{\a}{\obj\C{\a_i\dots ~\ap~ \a_j\dots}}}$, which we then define as $\sp$. Since we know that $\EnvType\cdot\s\K\ap\t$, and we know that $\forall \a \in \sigma, \Map\s{\Bind{\a}{\obj\C{\ldots}}} \implies \Map\sp{\Bind\a{\obj\C{\ldots}}}$, it follows that $\EnvType\cdot\sp\K\ap\t$, and from there that $\WFp\K{\ap~\sp}$ and $\EnvType\cdot\sp\K\ap\t$, so the theorem holds.

        If $\e$ is a stuck state of the form $\EE[\ep]$, define $\EE' = \Call{\EE[\ep]}\f{}$, and then the theorem holds.

  \item \RuleRef{KT-CALL}

      We apply the IH to the first precondition, finding that either $\e$ is a value $\a$, $\e$ is a stuck state, or $\Reduce\K\e\s\Kp\ep\sp$, $\WFp\Kp{\ep~\sp}$, and $\EnvType\cdot\sp\Kp\ep\C$, then case analyze.
      \begin{itemize}
        \item $\Reduce\K\e\s\Kp\epp\sp$, $\WFp\Kp{\epp~\sp}$, and $\EnvType\cdot\sp\Kp\epp\C$. Apply \ref{lem:ert} to the second precondition to find that $\EnvType\Kp\sp\ep\t$, and apply \RuleRef{KT-CALL} to find that $\EnvType\cdot\sp\Kp{\KCall\epp\m\ep\t\tp}\tp$.
        \item $\e$ is $\a$: Apply the IH to $\e'$. Then, either $\e'$ is a value $\ap$, $\e'$ is stuck, or $\Reduce\K\ep\s\Kp\epp\sp$, $\WFp\Kp{\ep~\sp}$, and $\EnvType\cdot\sp\Kp\epp\t$. 
        \begin{itemize}
          \item $\Reduce\K\ep\s\Kp\epp\sp$, $\WFp\Kp{\epp~\sp}$, and $\EnvType\cdot\sp\Kp\epp\C$. Then, $\Reduce\K{\KCall\a\m\ep\t\tp}\s\Kp{\KCall\a\m\epp\t\tp}\sp$ by the definition of evaluation contexts. Apply \ref{lem:ert} to the first precondition to find that $\EnvType\cdot\sp\Kp\a\C$, then use \RuleRef{KT-CALL} to conclude that $\EnvType\cdot\sp\Kp{\KCall\a\m\epp\t\tp}\tp$.
          \item $\e' = \ap$. In this case, apply correctness of $\xt{mtypes}$ to find that $\Reduce\K{\KCall\a\m\ap\t\tp}\s\K\epp\s$, where $\EnvType\cdot\s\K\epp\tp$.
          \item $\e'$ is stuck at one of the three stuck states, of the form $\EE[\epp]$, then we can construct $\EE'[\epp] = \KCall\a\m{\EE[\epp]}\t\tp$, which is stuck.
        \end{itemize}
        \item If $\e$ is stuck at one of the three stuck states of the form $\EE[\epp]$, then we can construct $\EE'[\epp] = \KCall{\EE[\epp]}\m{\ep}\t\tp$, which is stuck.
      \end{itemize}
  
  \item \RuleRef{KT-DYNCALL}
  
      We apply the IH to the first precondition, finding that either $\e$ is a value $\a$, $\e$ is a stuck state, or $\Reduce\K\e\s\Kp\ep\sp$, $\WFp\Kp{\ep~\sp}$, and $\EnvType\cdot\sp\Kp\ep\any$, then case analyze.
      \begin{itemize}
        \item $\Reduce\K\e\s\Kp\epp\sp$, $\WFp\Kp{\epp~\sp}$, and $\EnvType\cdot\sp\Kp\epp\any$. Apply \ref{lem:ert} to the second precondition to find that $\EnvType\Kp\sp\ep\any$, and apply \RuleRef{KT-DYNCALL} to find that $\EnvType\cdot\sp\Kp{\DynCall\epp\m\ep}\any$.
        \item $\e$ is $\a$: Apply the IH to $\e'$. Then, either $\e'$ is a value $\ap$, $\e'$ is stuck, or $\Reduce\K\ep\s\Kp\epp\sp$, $\WFp\Kp{\ep~\sp}$, and $\EnvType\cdot\sp\Kp\epp\any$. 
        \begin{itemize}
          \item $\Reduce\K\ep\s\Kp\epp\sp$, $\WFp\Kp{\epp~\sp}$, and $\EnvType\cdot\sp\Kp\epp\any$. Then, $\Reduce\K{\KCall\a\m\ep\t\tp}\s\Kp{\KCall\a\m\epp\t\tp}\sp$ by the definition of evaluation contexts. Apply \ref{lem:ert} to the first precondition to find that $\EnvType\cdot\sp\Kp\a\any$, then use \RuleRef{KT-DYNCALL} to conclude that $\EnvType\cdot\sp\Kp{\DynCall\a\m\epp}\any$.
          \item $\e' = \ap$. If $\sigma(a) = \C\{\b{\app}\}$, and if $\Mdef\m\x\any\any\e \in \K(\C)$, then $\Reduce\K{\DynCall\a\m\ap}\s\K{[\a/\this ~ \ap/\x]\e}\any$, by the definition of evaluation. Then, since $\WFp\K{\e~\s}$, it follows that $\WFq\C$, and then that $\EnvType{\HT{\this}{\C}~\HT{\x}{\any}}\s\K\e\any$. Then, since we have that $\EnvType\cdot\s\K\a\C$ (by application of \RuleRef{KT-REFTYPE}), and that $\EnvType\cdot\s\K\ep\any$, we can use the substitution lemma to find that $\EnvType\cdot\s\K{[\a/\this ~ \ap/\x]\e}\any$, and the theorem holds.


          If the precondition does not apply, and $\C$ does not contain $\m$ under type $\any$, then the expression gets stuck, and the theorem holds.
          \item $\e'$ is stuck at one of the three stuck states, of the form $\EE[\epp]$, then we can construct $\EE'[\epp] = \DynCall\a\m{\EE[\epp]}$, which is stuck.
        \end{itemize}
        \item If $\e$ is stuck at one of the three stuck states of the form $\EE[\epp]$, then we can construct $\EE'[\epp] = \DynCall{\EE[\epp]}\m{\ep}$, which is stuck.
      \end{itemize}
      
  \item \RuleRef{KT-NEW}
  
  We apply the IH to the preconditions $\e_{1} \cdots \e_{n}$, finding that either $\e_{i}$ is a value $\a$, $\e_{i}$ is a stuck state, 
  or $\Reduce\K{\e_i}\s\Kp{\ep_i}\sp$, $\WFp\Kp{\ep_i~\sp}$, and $\EnvType\cdot\sp\Kp{\ep_i}\C_i$, then case analyze.
    
  \begin{enumerate}
   \item $\EnvType\cdot\s\K{\New\C{\e_1\dots\e_n}}\C$ 
   \item $\WFp\K{\e~\s}$  by case  
   \item $\Class \C {\b\fd}{\b\md} \in \K$  
   \item $\EnvType \cdot\s\K{\e_1}{\t_1}\dots \EnvType \cdot\s\K{\e_n}{\t_n}$
   \item $\b\fd=\Fdef{\f_1}{\t_1}\dots\Fdef{\f_n}{\t_n}$ by inversion lemma on (1)
   \item $\EnvType \cdot\s\K{\a_1}{\t_1}\dots \EnvType \dot\s\K{\a_n}{\t_n}$ by Inductive hypo on (2)
   \item $\Kp~{\New\C{\b\a}~\s}$ by Inductive hypo and (6)
   \item $\Kp=\K$
   \item $\sp=\Map\s{\Bind\ap{\obj\C{\b\a}}}$
   \item $\ap$ fresh
   \item $\ep=\ap$ by semantics on (7)
   \item $\EnvType \cdot\sp\Kp{\ap}{\C}$ by W10 on (8) and (9)
   \item $\k \in \K \implies \WF{}\cdot\K\k$ by (2)
   \item $\WFtype{\K}\s$ by premise of WF (2)
   \item $\WFtype{\K}\sp$ by (14), (2), (4)
   \item $\WFtype{\Kp}\sp$ by (15), (8)
   \item $\WFp\Kp{\ap~\sp}$ by (13), (8), (16), (12)
   \item done by (17) and (12)
  \end{enumerate}

  \item \RuleRef{KT-SUBCAST}
  
      Apply the IH to the precondition, finding that either $\e$ is a value $\a$, $\e$ is a stuck state, or $\Reduce\K\e\s\Kp\ep\sp$, $\WFp\Kp{\ep~\sp}$, and $\EnvType\cdot\sp\Kp\ep\any$. If it gets stuck at one of the three stuck states, or steps to a new expression, then the case is trivial.

      Consider the $\a$ case. Case analyze on $\t$:
      \begin{itemize}
        \item $\t = \any$. Trivially, $\Reduce\K{\SubCast\t\a}\s \K\a\s$.
        \item $\t = \C$. Define $\D$ such that $\sigma(\a) = \D\{\b{\ap}\}$. Case analyze on if $\StrSub \M\K \D \C$.
        \begin{itemize}
          \item If $\StrSub \M\K \D \C$, then $\Reduce\K{\SubCast\t\a}\s \K\a\s$. Moreover, $\HasType\cdot\K\s\a\t$, via \RuleRef{W2} and \RuleRef{W10}.
          \item Otherwise, $\SubCast\t\a$ is stuck, and the theorem holds.
        \end{itemize}
      \end{itemize}
      
  \item \RuleRef{KT-BEHCAST}
\begin{proofy}
\stepp[base] $\EnvType\cdot\s\K\e\tp$ \basis By assumption.
\stepp[progform] $\WFp \K{\e~\s}$ \basis By assumption
\stepp[inpswf] $\WFq \s$ \basis By inversion of \refby{progform}
\stepp Apply IH to \refby{base} and case analyze.
\begin{casel}
  \caseof{ \begin{iknown}
    \stepp[kred] $\Reduce\K\e\s\Kp\ep\sp$
    \stepp[kbase] $\WFp\Kp{\ep~\sp}$
    \stepp $\EnvType\cdot\sp\Kp\ep\tp$
    \end{iknown}} 
  \begin{proofy}
  \stepp $\Reduce\K{\BehCast{\t}{\e}}\s\Kp{\BehCast{\t}{\ep}}\sp$ \basis By defn. of evaluation environments on \refby{kred}
  \stepp[ktype] $\EnvType\cdot\sp\Kp{\BehCast\t\ep}\t$ \basis By \RuleRef{KT-BEHCAST}
  \stepp $\WFp\Kp{\ep~\sp}$ \basis By \refby{kbase, ktype}
  \end{proofy}
  \caseof{$\e$ is stuck in one of the allowed stuck states $\EE[\ep]$}
  \begin{proofy}
    \stepp $\BehCast\t\e = \EE'[\ep]$ \basis By case analysis and defn. of $\EE$.
    \stepp $\EE'[\ep]$ stuck \basis As $\ep$ stuck.
  \end{proofy}
  \caseof{$\e = \a$}
  \begin{proofy}
    \stepp Let $\C$ and $\b{\ap}$ be such that $\s(\a) = \C\{\b\ap\}$
    \stepp Case analyze on $\t$.
    \begin{casel}
      \caseof{$\t = \Cp$}
      \begin{proofy}
        \stepp Let $\D$ be fresh.
        \stepp Let $\ap$ be fresh.
        \stepp[wcorr] Let $\k$ be $\k = \wrap\C{\classoff\C\K}{\classoff\Cp\K}\D\that$.
        \stepp Let $\sp = \s[\ap \mapsto \D\{\a\}]$.
        \stepp[b2] $\EnvType\cdot{\K\k}\sp\ap\D$ \basis \RuleRef{W9}
        \stepp[b1] $\StrSub\cdot{\K\k}\D\Cp$ \basis correctness of $\xt{wrap}$ on \refby{wcorr}
        \stepp[wth] $\EnvType\cdot{\K\k}\sp\ap\Cp$ \basis \RuleRef{W2} on \refby{b1,b2}
        \stepp $\WFp{\K ~ \k}{\ap~\sp}$ \basis \RuleRef{WP} on \refby{wth, inpswf}
      \end{proofy}
      \caseof{$\t = \any$}
      \begin{proofy}
        \stepp Let $\D$ be fresh.
        \stepp Let $\ap$ be fresh.
        \stepp[wcorr2] Let $\k$ be $\k = \wrapAny\C{\classoff\C\K}\D\that$.
        \stepp Let $\sp = \s[\ap \mapsto \D\{\a\}]$.
        \stepp[b21] $\EnvType\cdot{\K\k}\sp\ap\any$ \basis \RuleRef{W10}
        \stepp $\WFp{\K ~ \k}{\ap~\sp}$ \basis \RuleRef{WP} on \refby{b21,wcorr2}
      \end{proofy}
    \end{casel}
  \end{proofy}
\end{casel}
\end{proofy}
  
  \item \RuleRef{KT-REFTYPE}
  
      Trivial, as $\e=\a$.
  
  \item \RuleRef{KT-REFANY}
  
      Trivial, as $\e=\a$.
\end{itemize}


\subsection{Type Soundness of \kafka Behavioral Cast}

Given that $\WFp\K{\e~\s}$ and $\EnvType\cdot\s\K\e\t$, then either there is some $\ep$ 
such that $\Reduce \K\e\s \Kp\ep\sp$ and $\WFp\Kp{\ep~\sp}$ and $\EnvType\cdot\sp\Kp\ep\t$ hold, 
or $\e$ is stuck in one of the following forms:
\begin{itemize} 
\item $\a$
\item $\EE[\DynCall\a\m{\ap}]$
\item $\EE[\SubCast\tp\a]$
\item $\EE[\BehCast\tp\a]$
\end{itemize}

Note that the majority of the proof is identical to that seen in the above proof
for soundness of the \kafka core, and is therefore elided. We will only cover
the case for the \kafka behavioural cast, \RuleRef{WB1}.

\subsection{Wrap function creates well-formed classes}

  \begin{theorem}{Wrap function creates well-formed classes}{WFun-WFC}
  
  \begin{conds}
   \cond{\WFq{\K~\e~\s}}\lbl{cond1}
%    \cond{\names{\classoff\Cp\K} $\subseteq$ \names{\classoff\C\K}}\lbl{cond2}
%    \cond{\fresh\D}\lbl{cond3}
   \cond{\bmt = \classoff\C\K}\lbl{cond3a}
   \cond{\bmtp = \classoff\Cp\K}\lbl{cond3b}
   \cond{k = \wrap\C{\bmt}{\bmtp}\D\that}\lbl{cond4}
   \cond{\App\s\a = \obj\C{\b{\a_1}}}\lbl{cond5}
   \cond{\sp = \Map \s{\Bind\ap{\obj\D{\a}}}}\lbl{cond6}
   \cond{\cload{\bmt}}\lbl{cond7}
   \cond{\fresh\that}\lbl{cond8}
  \end{conds}
  
  \then\axiom{\WF{}\sp{\K~\k}{\k}}
  
    \begin{proof} \innatE{on the definition of the \xt{wrap} function}
     \step{\WFtype{\K~\k}{\Fdef\that\C}}{\byjdg{WF}\trf{cond5},~\trf{cond1}}\lbl{1}

     \begin{case}{\t = \Cpp, \tp = \Cppp, \Mtype\m\tpp\tppp $\not\in$ \bmtp \textbf{for} \Mdef\m\x{\t}{\tp}{~\KCall{\this.\that()_{\C}}\m{\x}\t\tp~}}\lbl{E}
      \step{\Mtype\m\Cpp\Cppp $\in$ \bmt }{\trf{cond1}, \trf{cond4}, defintion of case}\lbl{E1}
      \step{\Cpp $\in$ \Kk}{\trf{E1}}\lbl{E2}
      \step{\Cppp $\in$ \Kk}{\trf{E1}}\lbl{E3}
      \step{\WFtype\Kk\Cpp}{\byjdg{WC}{\trf{E2}}}\lbl{E4}
      \step{\WFtype\Kk\Cppp}{\byjdg{WC}{\trf{E3}}}\lbl{E5}
      \slet{\Envp}{\Env, ~\namet{\x}{\Cpp}}\lbl{E7}
      \step{\EnvType \Env\sp\Kk{\this.\that()_{\C}}\C }{\byjdg{W3}{\trf{1}, \textbf{this} variable, definition of \textbf{mtypes}}}\lbl{E6}     
      \step{\EnvType {\Envp}\sp\Kk{\x}\Cpp}{\byjdg{W1}{\trf{E7}}}\lbl{E8}  
      \step{\EnvType {\Envp}\sp\Kk{\KCall{\this.\that}\m{\x}\Cpp\Cppp}\Cppp}{\byjdg{W5}{\trf{E6}, \trf{E8}, \trf{E1}}}\lbl{E9}
      \step{\WF{\Envp}{\sp}{\Kk}{\Mdef\m\x{\Cpp}{\Cppp}{~\KCall{\this.\that}\m{\x}\Cpp\Cppp~}}}{\byjdg{WT2}{\trf{E9},~\trf{E4}, ~\trf{E5}}} \lbl{E10}                 
      \end{case}

     \begin{case}{\t = \any, \tp = \any, \Mtype\m\tpp\tppp $\not\in$ \bmtp \textbf{for} \Mdef\m\x{\t}{\tp}{~\KCall{\this.\that}\m{\x}\t\tp~}}\lbl{F}
      \statem{Same as $\t$ = \Cpp, $\t$ = \Cppp by defintion of case, \trf{cond1}, \trf{cond4}, and with WT1 and WA instead of WT2 and WC 
      respectively.}\lbl{F1}      
     \end{case}

     \begin{case}{\Mdef\m\x\Dp\Dpp {~\bscast\Dpp{\KCall{\this.\that()_{\C}}\m{\bscast\Cp\x}\Cp\Cpp}~}}\lbl{K}
      \step{\Mtype\m\Dp\Dpp $\in$ \bmtp }{\trf{cond1}, \trf{cond4}, defintion of case}\lbl{K1}
      \step{\WFtype\Kk\Dp}{\byjdg{WC}{\trf{K1}}}\lbl{K1a}      
      \step{\WFtype\Kk\Dpp}{\byjdg{WC}{\trf{K1}}}\lbl{K1b}      
      \step{\Mtype\m\Cp\Cpp $\in$ \bmt }{\trf{cond1}, \trf{cond4}, defintion of case}\lbl{K2}
      \slet{\Envp}{\Env, ~\namet{\x}{\Dp}}\lbl{K3}
      \step{\EnvType\Envp\sp\Kk{\x}{\Dp}}{\byjdg{W1}{\trf{K3}}}\lbl{K4}
      \step{\EnvType\Envp\sp\Kk{\bscast\Cp\x}{\Cp}}{\byjdg{WB}{\trf{K4}}}\lbl{K5}
      \step{\EnvType \Envp\sp\Kk{\this.\that()_{\C}}\C }{\byjdg{W3}{\trf{1}, \textbf{this} variable, definition of \textbf{mtypes}}}\lbl{K6}
      \step{\EnvType \Envp\sp\Kk{\KCall{\this.\that()_{\C}} \m {\bscast{\Cp}\x}\Cp\Cpp }\Cpp }{\byjdg{W4}{\trf{K6},~\trf{K2},~\trf{K5},~\trf{cond3a}}}\lbl{K7}
      \step{\EnvType \Envp\sp\Kk{\bscast\Dpp{\KCall{\this.\that()_{\C}}\m{\bscast\Cp\x}\Cp\Cpp}}{\Dpp}}{\byjdg{WB}{\trf{K7}}}\lbl{K8}
      \longstepB{\WF{\Envp}{\sp}{\Kk}{\Mdef\m\x\Dp\Dpp {~\bscast\Dpp{\KCall{\this.\that()_{\C}}\m{\bscast\Cp\x}\Cp\Cpp}~}}}{\byjdg{WT2}{\trf{K8},~\trf{K1a},~\trf{K1b}}}\lbl{K9}
      
     \end{case}

     \begin{case}{\Mdef\m\x\Dp\Dpp {~\bscast\Dpp{\KCall{\this.\that()_{\C}}\m{\bscast\any\x}\any\any}~}}\lbl{L}
      \step{\Mtype\m\Dp\Dpp $\in$ \bmtp }{\trf{cond1}, \trf{cond4}, defintion of case}\lbl{L1}
      \step{\WFtype\Kk\Dp}{\byjdg{WC}{\trf{L1}}}\lbl{L2}      
      \step{\WFtype\Kk\Dpp}{\byjdg{WC}{\trf{L1}}}\lbl{L3}      
      \step{\Mtype\m\any\any $\in$ \bmt }{\trf{cond1}, \trf{cond4}, defintion of case}\lbl{L4}
      \slet{\Envp}{\Env, ~\namet{\x}{\Dp}}\lbl{L5}
      \step{\EnvType\Envp\sp\Kk{\x}{\Dp}}{\byjdg{W1}{\trf{L5}}}\lbl{L6}
      \step{\EnvType\Envp\sp\Kk{\bscast\any\x}{\any}}{\byjdg{WB}{\trf{L6}}}\lbl{L7}
      \step{\EnvType \Envp\sp\Kk{\this.\that()_{\C}}\C }{\byjdg{W3}{\trf{1}, \textbf{this} variable}, definition of \textbf{mtypes}}\lbl{L8}      
      \step{\EnvType \Envp\sp\Kk{\KCall{\this.\that()_{\C}} \m {\bscast{\any}\x}\any\any }\any }{\byjdg{W4}{\trf{L8},~\trf{L4},~\trf{L7},~\trf{cond3a}}}\lbl{L9}
      \step{\EnvType \Envp\sp\Kk{\bscast\Dpp{\KCall{\this.\that()_{\C}}\m{\bscast\any\x}\any\any}}{\Dpp}}{\byjdg{WB}{\trf{L9}}}\lbl{L10}
      \longstepB{\WF{\Envp}{\sp}{\Kk}{\Mdef\m\x\Dp\Dpp {~\bscast\Dpp{\KCall{\this.\that()_{\C}}\m{\bscast\any\x}\any\any}~}}}{\byjdg{WT2}{\trf{L10},~\trf{L2},~\trf{L3}}}\lbl{L11}
     \end{case}

     \begin{case}{\Mdef\m\x\any\any {~\bscast\any{\KCall{\this.\that()_{\C}}\m{\bscast\Cp\x}\Cp\Cpp}~}}\lbl{M}
      \step{\Mtype\m\any\any $\in$ \bmtp }{\trf{cond1}, \trf{cond4}, defintion of case}\lbl{M1}
      \step{\Mtype\m\Cp\Cpp $\in$ \bmt }{\trf{cond1}, \trf{cond4}, defintion of case}\lbl{M2}
      \step{\WFtype\Kk\any}{\byjdg{WA}{\any}}\lbl{M3}      
      \slet{\Envp}{\Env, ~\namet{\x}{\any}}\lbl{M4}
      \step{\EnvType\Envp\sp\Kk{\x}{\any}}{\byjdg{W1}{\trf{M4}}}\lbl{M5}
      \step{\EnvType\Envp\sp\Kk{\bscast\Cp\x}{\Cp}}{\byjdg{WB}{\trf{M5}}}\lbl{M6}
      \step{\EnvType \Envp\sp\Kk{\this.\that()_{\C}}\C }{\byjdg{W3}{\trf{1}, \textbf{this} variable}, definition of \textbf{mtypes}}\lbl{M7}
      \step{\EnvType \Envp\sp\Kk{\KCall{\this.\that()_{\C}} \m {\bscast{\Cp}\x}\Cp\Cpp }\Cpp }{\byjdg{W4}{\trf{M7},~\trf{M6},~\trf{M2},~\trf{cond3a}}}\lbl{M8}
      \step{\EnvType \Envp\sp\Kk{\bscast\any{\KCall{\this.\that()_{\C}}\m{\bscast\Cp\x}\Cp\Cpp}}{\any}}{\byjdg{WB}{\trf{M8}}}\lbl{M9}
      \longstepC{\WF{\Envp}{\sp}{\Kk}{\Mdef\m\x\any\any {~\bscast\any{\KCall{\this.\that()_{\C}}\m{\bscast\Cp\x}\Cp\Cpp}~}}}{\byjdg{WT1}{\trf{M9},~\trf{M3}}}\lbl{M10}
     \end{case}
    
     \step{$\Class \D {\b\fd}{\b\md} \in \K~\k$}{\trf{cond7}}\lbl{N2}
     \step{\cload{\classoff\D{\K~\k}}}{\trf{cond8}, \bylemm{\ref{lem:DM-WR}}{DupMeth over wrappers}{\trf{cond7}, \trf{cond4}}}\lbl{N1}
     \step{\xt{overloading}$_{\cmd}$(\b\md~\b\fd) \textbf{for} \k}{\bylemm{\ref{lem:DM-OL}}{DupMeth gives overloading}{\trf{cond7}}, \trf{N2}, \trf{N1}}\lbl{N3}   
     \done{\trf{1}, \trf{N3}, and \textbf{Case}}
    \end{proof}
   \end{theorem}

\begin{lemma}{Extending dupMeth with wrappers}{DM-WR}

  \begin{conds}
   \cond{k = \wrap\C{\classoff\C\K}{\classoff\Cp\K}\D\that}\lbl{cond4}
   \cond{\cload{\classoff\C\K}}\lbl{cond1}
  \end{conds}
  
  \then\axiom{\cload{\classoff\D{\K~\k}}}

   \begin{proof} \innatE{on the construction of \k}
    \step{\names{\classoff\D{\K~\k}} $\subseteq$ \names{\classoff\C{\K}}.}{\trf{cond4}, \textbf{wrap} function (ensures all methods in \D must be in \C).}\lbl{1}
    \step{\cload{\classoff\D{\K~\k}}}{\trf{1}, \trf{cond1}, \textbf{dupMeth} function}\lbl{2}
    \done{\trf{2}}
   \end{proof}
\end{lemma}
 
    
\begin{lemma}{dupMeth of wrapper class gives overloading}{DM-OL}

  \begin{conds}
   \cond{k = \wrap\C{\classoff\C\K}{\classoff\Cp\K}\D\that}\lbl{cond1}
   \cond{$\Class \D {\b\fd}{\b\md} \in \K~\k$}\lbl{cond2}
   \cond{\bmt = \classoff\D{\K~\k}}\lbl{cond3}
   \cond{\cload{\bmt}}\lbl{cond4}
   \cond{\fresh{\textbf{that}}}\lbl{cond5}
  \end{conds}
  
  \then\axiom{\xt{overloading}$_{\emptyset}$(\b\md~\b\fd)}

   \begin{proof} \indana{\trf{cond4}}
     \begin{case}{FO1}\lbl{A}
      \step{\xt{overloading}$_{\cmd}$(\namet{\that}{\C})}{\trf{cond5}, \trf{cond1}}\lbl{A1}
      \done{\trf{A1}}
     \end{case}
     
     \begin{case}{MO1}\lbl{B}
      \statem{Trivial, axiom.}\lbl{B1}
      \done{\trf{B1}}
     \end{case}

     \begin{case}{MO2}\lbl{C}
      \step{\xt{overloading}$_{\cmd}$(\Mdef\m\x\any\any\e ~ \b\mdp ~\b\fd)}{def of \textbf{case}}\lbl{C1}
      \step{\m $\not\in$ \names{\b\mtp}}{\trf{cond4} on \textbf{case}}\lbl{C2}
      \step{\Mdef\m\x\any\any\e $\not\in$ \b\mdp}{\trf{C1}, \trf{C2}}\lbl{C3}
      \slet{\cmdp}{\cmd,~\Mdef\m\x\any\any\e}\lbl{C4}
      \step{\xt{overloading}$_{\cmdp}$(\b\mdp~\b\fd)}{Ind Hyp on \textbf{case}, \trf{C1}, \trf{C3}, \trf{C4}}\lbl{C5}
      \done{\trf{C3}, \trf{C4}, \trf{C5}}
     \end{case}

     \begin{case}{MO3}\lbl{D}
      \step{\xt{overloading}$_{\cmd}$(\Mdef\m\x\C\Cp\e ~ \b\mdp ~\b\fd)}{def of \textbf{case}}\lbl{D1}
      \step{\m $\not\in$ \names{\b\mtp}}{\trf{cond4} on \textbf{case}}\lbl{D2}
      \step{\Mdef\m\x\C\Cp\e $\not\in$ \mdp}{\trf{D1}, \trf{D2}}\lbl{D3}
      \slet{\cmdp}{\cmd, ~\Mdef\m\x\C\Cp\e}\lbl{D4}
      \step{\xt{overloading}$_{\cmdp}$(\b\mdp~\b\fd)}{Ind Hyp on \textbf{case}, \trf{D1}, \trf{D3}, \trf{D4}}\lbl{D5}
      \done{\trf{D3}, \trf{D4}, \trf{D5}}      
     \end{case}
   \end{proof}
\end{lemma}

\subsection{Type Soundness of TypeScript Translation}
\begin{lemma}{Soundness of TypeScript convertibility}{THTS-COMP}
  \begin{conds}
    \cond{$\ConvertE\K{s}\t\tp$}\lbl{cond1}
    \cond{$\EnvTypeS\Env\K\e\t$}\lbl{cond2}
    \cond{$\ep = \TRG{\e}\Env$}\lbl{cond3}
    \cond{$\TR\K = \Kp$}\lbl{cond4}
    \cond{$\TR\Env = \Envp$}\lbl{cond5}
    \cond{$\EnvType\Envp\cdot\Kp{\ep}{\any}$}\lbl{cond6}
  \end{conds}
  \then\axiom{$\EnvType\Envp\cdot\Kp{\TAG\e\Env{\any}}{\any}$}

  \begin{proof}{ \indmsg{$\ConvertE\K{s}\t\tp$}}

  \begin{case}{STGC-SUB}
    \begin{case}{$\StrSub\cdot\Kp{\any}{\any}$}
    \end{case}

    \begin{case}{$\StrNotSub\cdot\Kp{\any}{\any}$}
    \end{case}
  \end{case}

  \begin{case}{STGC-TOANY}
  \end{case}

  \begin{case}{STGC-ANYCONC}
  \end{case}

  \end{proof}
\end{lemma}

\begin{lemma}{Type correctness of TypeScript translation}{THTS-TRANS}
  \begin{conds}
    \cond{$\WFpX\K\e{s}$}\lbl{cond1}
    \cond{$\WFtypeX \K{s}\t$}\lbl{cond2}
    \cond{$\HT\x\tp \in \Env \implies \WFtypeX\K{s}\tp$}\lbl{cond3}
    \cond{\EnvTypeE\Env\K{s}\e\t}\lbl{cond4}
    \cond{$\TR\K = \Kp$}\lbl{cond5}
    \cond{$\TR\Env = \Envp$}\lbl{cond6}
  \end{conds}

  \then\axiom{$\EnvType\Envp\cdot\Kp{\TRG{\e}\Env}{\any}$}

  \begin{proof} \indmsg{\EnvTypeE\Env\K{s}\e\t}

    \begin{case}{STG-VAR}    
    \end{case}

    \begin{case}{STG-GET}
    \end{case}

    \begin{case}{STG-SET}
    \end{case}

    \begin{case}{STG-CALL}
    \end{case}

    \begin{case}{STG-DCALL}
    \end{case}

    \begin{case}{STG-NEW}
    \end{case}
  \end{proof}
\end{lemma}
\subsection{Type Soundness of Typed Racket Translation}
\begin{lemma}{Soundness of Typed Racket convertibility}{THTR-COMP}
  \begin{conds}
    \cond{$\ConvertE\K{s}\t\tp$}\lbl{cond1}
    \cond{$\EnvTypeS\Env\K\e\t$}\lbl{cond2}
    \cond{$\ep = \TRG{\e}\Env$}\lbl{cond3}
    \cond{$\TR\K = \Kp$}\lbl{cond4}
    \cond{$\TR\Env = \Envp$}\lbl{cond5}
    \cond{$\EnvType\Envp\cdot\Kp{\ep}{\t}$}\lbl{cond6}
  \end{conds}
  \then\axiom{$\EnvType\Envp\cdot\Kp{\TAG\e\Env{\tp}}{\tp}$}

  \begin{proof}{ \indmsg{$\ConvertE\K{s}\t\tp$}}

  \begin{case}{STGC-SUB}
  \end{case}

  \begin{case}{STGC-TOANY}
  \end{case}

  \begin{case}{STGC-ANYCONC}
  \end{case}

  \end{proof}
\end{lemma}

\begin{lemma}{Type correctness of Typed Racket translation}{THTR-TRANS}
  \begin{conds}
    \cond{$\WFpX\K\e{s}$}\lbl{cond1}
    \cond{$\WFtypeX \K{s}\t$}\lbl{cond2}
    \cond{$\HT\x\tp \in \Env \implies \WFtypeX\K{s}\tp$}\lbl{cond3}
    \cond{\EnvTypeE\Env\K{s}\e\t}\lbl{cond4}
    \cond{$\TR\K = \Kp$}\lbl{cond5}
    \cond{$\TR\Env = \Envp$}\lbl{cond6}
  \end{conds}

  \then\axiom{$\EnvType\Envp\cdot\Kp{\TRG{\e}\Env}{\t}$}

  \begin{proof} \indmsg{\EnvTypeW\Env\K\e\t}

    \begin{case}{STG-VAR}    
    \end{case}

    \begin{case}{STG-GET}
    \end{case}

    \begin{case}{STG-SET}
    \end{case}

    \begin{case}{STG-CALL}
    \end{case}

    \begin{case}{STG-DCALL}
    \end{case}

    \begin{case}{STG-NEW}
    \end{case}
  \end{proof}
\end{lemma}
\subsection{Type Soundness of Thorn Translation}

\begin{lemma}{Soundness of compatibility}{THT-COMP}
  \begin{conds}
    \cond{$\Convertible\K\t\tp$}\lbl{cond1}
    \cond{$\EnvTypeW\Env\K\e\t$}\lbl{cond2}
    \cond{$\ep = \TRG{\e}\Env$}\lbl{cond3}
    \cond{$\TR\K = \Kp$}\lbl{cond4}
    \cond{$\TR\Env = \Envp$}\lbl{cond5}
    \cond{$\EnvType\Envp\cdot\Kp{\ep}{\kty\t}$}\lbl{cond6}
  \end{conds}
  \then\axiom{$\EnvType\Envp\cdot\Kp{\TAG\e\Env{\tp}}{\kty\tp}$}

  \begin{proof}{ \indmsg{$\Convertible\K\t\tp$}}

  \begin{case}{STHC-SUB}
    \begin{case}{$\StrSub\cdot\Kp{\kty\t}{\kty\tp}$}
      \step{$\TAG\e\Env\tp = \ep$}{TTR7 on \trf{cond6}, case}\lbl{CS2}
      \step{$\EnvType\Envp\cdot\Kp{\TAG\e\Env{\tp}}{\kty\tp}$}{\RuleRef{KT-SUB} on case, \trf{CS2}, \trf{cond6}}
    \end{case}

    \begin{case}{$\StrNotSub\cdot\Kp{\kty\t}{\kty\tp}$}
      \step{$\TAG\e\Env\tp = \SubCast{\kty\tp}\ep$}{TTR8 on \trf{cond6}, case}\lbl{CS2}
      \step{$\EnvType\Envp\cdot\Kp{\SubCast{\kty\tp}\ep}{\kty\tp}$}{\RuleRef{KT-SUBCAST} on case, \trf{CS2}, \trf{cond6}}
    \end{case}
  \end{case}

  % WTS: \EnvType\Envp\cdot\Kp{\ep}{\any}
  \begin{case}{STHC-TOANY}
    \step{$\TAG\e\Env\any = \SubCast\any\ep$}{TTR8 on case}
    \step{$\EnvType\Envp\cdot\Kp{\SubCast\any\ep}{\any}$}{\RuleRef{KT-SUBCAST} on \trf{cond6}}
  \end{case}

  % WTS: \EnvType\Envp\cdot\Kp{\ep}{\C}
  \begin{case}{STHC-OPTCONC}
    \step{$\TAG\e\Env\C = \SubCast\C\ep$}{TTR8 on case}
    \step{$\EnvType\Envp\cdot\Kp{\SubCast\C\ep}{\C}$}{\RuleRef{KT-SUBCAST} on \trf{cond6}}
  \end{case}

  \begin{case}{STHC-ANYCONC}
    \step{$\TAG\e\Env{\t} = \SubCast{\kty\t}\ep$}{TTR8 on case}
    \step{$\EnvType\Envp\cdot\Kp{\SubCast{\kty\t}\ep}{\kty\t}$}{\RuleRef{KT-SUBCAST} on \trf{cond6}}
  \end{case}

  \end{proof}
\end{lemma}

\begin{lemma}{Type correctness of Thorn translation}{THT-TRANS}
  \begin{conds}
    \cond{$\WFpW\K\e$}\lbl{cond1}
    \cond{$\WFtypeW \K\t$}\lbl{cond2}
    \cond{$\HT\x\tp \in \Env \implies \WFtypeW\K\tp$}\lbl{cond3}
    \cond{\EnvTypeW\Env\K\e\t}\lbl{cond4}
    \cond{$\TR\K = \Kp$}\lbl{cond5}
    \cond{$\TR\Env = \Envp$}\lbl{cond6}
  \end{conds}

  \then\axiom{$\EnvType\Envp\cdot\Kp{\TRG{\e}\Env}{\kty\t}$}

  \begin{proof} \indmsg{\EnvTypeW\Env\K\e\t}

    \begin{case}{STH-VAR}
      \step{$\TRG{\x}\Env = \x$}{TTR1}\lbl{TSSL1}
      \step{$\EnvType\Envp\cdot\Kp\x{\kty\t}$}{\trf{cond6}, \RuleRef{KT-VAR}}\lbl{TSSL2}
      \done{\trf{TSSL2}}      
    \end{case}

    \begin{case}{STH-GET}
      \step{$\TRG{\FRead\f}\Env = \FRead\f$}{TTR2}\lbl{TSSL3}
      \step{$\EnvType\Envp\cdot\Kp\x{\kty\t}$}{\trf{cond5}, \RuleRef{KT-READ}}\lbl{TSSL4}
    \end{case}

    \begin{case}{STH-SET}
      \step{$\EnvTypeW\Env\K{\FWrite\f\e}\t$}{case}\lbl{TSSL5}
      \step{$\Convertible\K\tp\t$}{case}\lbl{TSSLC}
      \step{$\EnvTypeW\Env\K\e\tp$}{inversion on \trf{TSSL5}}\lbl{TSSL6}
      \slet{\ep}{\TRG\e\Env}\lbl{TSSA1}
      \step{$\EnvType\Envp\cdot\Kp\ep{\kty\tp}$}{IH on \trf{TSSL6}}\lbl{TSSL7}
      \slet{\epp}{{\TAG\e\Env{\t}}}\lbl{TSSA2}
      \step{$\EnvType\Envp\cdot\Kp\epp{\kty\t}$}{lemma \ref{lem:THT-COMP} on \trf{TSSL7}}\lbl{TSSL8}
      \step{$\TRG{\FWrite\f\e}\Env = \FWrite\f\epp$}{TTR3 on \trf{TSSA2},\trf{TSSL5},\trf{cond5}}\lbl{TSSL8}
      \step{$\EnvType\Envp\cdot\Kp{\FWrite\f\epp}{\kty\t}$}{\trf{TSSL8},\trf{TSSL5},\trf{cond5}, \RuleRef{KT-READ}}\lbl{TSSL9}
    \end{case}

    \begin{case}{STH-CALL}
      \step{$\EnvTypeW\Env\K{\Call{\e_1}\m{\ep_1}}\t$}{case}\lbl{THCA1}
      \step{$\EnvTypeW\Env\K{\e_1}{\t[a]}$}{case}\lbl{THCA2}
      \step{$\t[a] = \C \vee \t[a] = \CW$}{case}\lbl{TSSA5}
      \step{$\Mtype\m\tp\t \in \classoff\C\K$}{case}\lbl{THCA3}
      \step{$\EnvTypeW\Env\K{\ep_1}\tpp$}{case}\lbl{THCA4}
      \step{$\Convertible\K\tpp\tp$}{case}\lbl{THCA5}
      \slet{$\e_2$}{${\TRG{\e_1}\Env}$}\lbl{TSSA1}
      \slet{$\ep_2$}{${\TRG{\ep_1}\Env}$}\lbl{TSSA2}
      \step{$\EnvType\Envp\cdot\Kp{\e_2}{\kty{\t[a]}}$}{IH on \trf{THCA2}, \trf{TSSA1}}\lbl{THCA6}
      \step{$\EnvType\Envp\cdot\Kp{\ep_2}{\kty\tpp}$}{IH on \trf{THCA4}, \trf{TSSA2}}\lbl{THCA7}
      \slet{$\epp_2$}{${\TAG{\ep_1}\Env{\t[a]}}$}\lbl{TSSA3}
      \step{$\EnvType\Envp\cdot\Kp{\epp_2}{\kty\tp}$}{lemma \ref{lem:THT-COMP} on \trf{THCA5}, \trf{THCA7}}\lbl{THCA8}

      \begin{case}{$\t[a] = \C$}
        \step{$\TRG{\Call{\e_1}\m{\ep_1}}\Env = \KCall{\e_2}\m{\epp_2}{\kty\tp}{\kty\t}$}{TTR5 on \trf{THCA2},\trf{THCA8},\trf{THCA3}}
        \step{$\EnvType\Envp\cdot\Kp{\KCall{\e_2}\m{\epp_2}{\kty\tp}{\kty\t}}{\kty\t}$}{\trf{THCA6},\trf{THCA8},\trf{cond5},\RuleRef{KT-CALL}}\lbl{TSSL9}
      \end{case}

      \begin{case}{$\t[a] = \CW$}
        \step{$\TRG{\Call{\e_1}\m{\ep_1}}\Env = \DynCall{\e_2}\m{\epp_2}$}{TTR4 on \trf{THCA2},\trf{THCA8}}
        \step{$\EnvType\Envp\cdot\Kp{\KCall{\e_2}\m{\epp_2}{\kty\tp}{\kty\t}}{\kty\t}$}{\trf{THCA2},\trf{THCA8},\RuleRef{KT-DYNCALL}}\lbl{TSSL10}
      \end{case}
    \end{case}

    \begin{case}{STH-DCALL}
      \step{$\EnvTypeW\Env\K{\Call{\e_1}\m{\ep_1}}\t$}{case}\lbl{THCD1}
      \step{$\EnvTypeW\Env\K{\e_1}\any$}{case}\lbl{THCD2}
      \step{$\EnvTypeW\Env\K{\ep_1}\any$}{case}\lbl{THCD3}
      \slet{$\e_2$}{${\TRG{\e_1}\Env}$}\lbl{TSSD1}
      \slet{$\ep_2$}{${\TRG{\ep_1}\Env}$}\lbl{TSSD2}
      \step{$\TRG{\Call{\e_1}\m{\ep_1}}\Env = \DynCall{\e_2}\m{\ep_2}$}{TTR4 on \trf{TSSD1},\trf{THCD2},\trf{TSSD2}}\lbl{THCD4}
      \step{$\EnvType\Envp\cdot\Kp{\e_2}\any$}{IH on \trf{THCD2}}\lbl{THCD5}
      \step{$\EnvType\Envp\cdot\Kp{\ep_2}\any$}{IH on \trf{THCD3}}\lbl{THCD6}
      \step{$\EnvType\Envp\cdot\Kp{\DynCall{\e_2}\m{\ep_2}}{\kty\t}$}{\trf{THCD5},\trf{THCD6},\RuleRef{KT-DYNCALL}}\lbl{THCD9}
    \end{case}

    \begin{case}{STH-NEW}
      \step{$\EnvTypeW\Env\K{\New\C{\e_1,\ldots}}\t$}{case}\lbl{THCN1}
      \step{$\EnvTypeW\Env\K{\e_1}\tp_1 ~ \ldots$}{case}\lbl{THCN2}
      \step{$\Convertible\K{\tp_1}{\t_1} ~ \ldots$}{case}\lbl{THCN3}
      \slet{$\ep_i$}{${\TRG{\e_i}\Env}$ for all $i$}\lbl{TSSN1}
      \step{$\EnvType\Envp\cdot\Kp{\ep_i}{\kty{\tp_i}}$}{IH on \trf{THCN2}}\lbl{THCN4}
      \slet{$\epp_i$}{${\TAG{\ep_i}\Env{{\t_i}}}$ for all $i$}\lbl{TSSN2}
      \step{$\EnvType\Envp\cdot\Kp{\epp_i}{\kty{\t_i}}$}{lemma \ref{lem:THT-COMP} on \trf{TSSN2}, \trf{THCN2}}\lbl{THCN5}
      \step{$\TRG{\New\C{\e_1,\ldots}}\Env = \New\C{\epp_1,\ldots}$}{TTR6 on \trf{TSSD1},\trf{THCD2},\trf{TSSD2}}\lbl{THCN6}
      \step{$\EnvType\Envp\cdot\Kp{\New\C{\epp_1,\ldots}}{\kty\t}$}{\trf{THCN5},\RuleRef{KT-NEW}}\lbl{THCN7}
    \end{case}
  \end{proof}
\end{lemma}


\subsection{Type Soundness of Transient Translation}

\begin{lemma}{Consistent Subtyping Implies Kafka Subtyping}{THTA-SUB}
  \begin{conds}
    \cond{$\ConSub\cdot\K{\t}{\tp}$}\lbl{cond1}
    \cond{$\ConSub\cdot\K {\Mtype\m{\t[1]}{\tp[1]}} {\Mtype\m{\t[2]}{\tp[2]}}$}\lbl{cond2}
    \cond{$\TR\K = \Kp$}\lbl{cond3}
  \end{conds}
  \then\axiom{$\StrSub\cdot\Kp{\t[1]}{\tp[1]} \wedge \StrSub \cdot\Kp {\Mtype\m{\t[1]}{\tp[1]}} {\Mtype\m{\t[2]}{\tp[2]}}$}

  \begin{proof}{ mutual induction on the derivation of {$\ConSub\cdot\K\t\tp$} and $\ConSub\cdot\K {\Mtype\m{\t[1]}{\tp[1]}} {\Mtype\m{\t[2]}{\tp[2]}}$}

    \begin{case}{CSCons}
    \end{case}
    
    \begin{case}{CSAss}
    \end{case}
    
    \begin{case}{CSRec}
    \end{case}
    
    \begin{case}{CSMet}
    \end{case}
  \end{proof}
\end{lemma}

\begin{lemma}{Soundness of Transient convertibility}{THTA-COMP}
  \begin{conds}
    \cond{$\ConvertE\K{tr}\t\tp$}\lbl{cond1}
    \cond{$\EnvTypeS\Env\K\e\t$}\lbl{cond2}
    \cond{$\ep = \TRG{\e}\Env$}\lbl{cond3}
    \cond{$\TR\K = \Kp$}\lbl{cond4}
    \cond{$\TR\Env = \Envp$}\lbl{cond5}
    \cond{$\EnvType\Envp\cdot\Kp{\ep}{\t}$}\lbl{cond6}
  \end{conds}
  \then\axiom{$\EnvType\Envp\cdot\Kp{\TAG\e\Env{\tp}}{\kty\tp}$}

  \begin{proof}{ \indmsg{$\Convertible\K\t\tp$}}

  \begin{case}{STC-SUB}
  \end{case}

  \begin{case}{STC-TOANY}
  \end{case}

  \begin{case}{STC-OPTCONC}
  \end{case}

  \end{proof}
\end{lemma}

\begin{lemma}{Type correctness of Transient translation}{THTA-TRANS}
  \begin{conds}
    \cond{$\WFpX\K\e{tr}$}\lbl{cond1}
    \cond{$\WFtypeX \K{tr}\t$}\lbl{cond2}
    \cond{$\HT\x\tp \in \Env \implies \WFtypeX\K{tr}\tp$}\lbl{cond3}
    \cond{\EnvTypeE\Env\K{tr}\e\t}\lbl{cond4}
    \cond{$\TR\K = \Kp$}\lbl{cond5}
    \cond{$\TR\Env = \Envp$}\lbl{cond6}
  \end{conds}

  \then\axiom{$\EnvType\Envp\cdot\Kp{\TRG{\e}\Env}{\t}$}

  \begin{proof} \indmsg{\EnvTypeW\Env\K\e\t}

    \begin{case}{STT-VAR}    
    \end{case}

    \begin{case}{STT-GET}
    \end{case}

    \begin{case}{STT-SET}
    \end{case}

    \begin{case}{STT-CALL}
    \end{case}

    \begin{case}{STT-DCALL}
    \end{case}

    \begin{case}{STT-NEW}
    \end{case}
  \end{proof}
\end{lemma}
\end{document}
