\documentclass[acmlarge, anonymous, authordraft]{acmart}
% can add review if you want line numbers
\usepackage{stmaryrd}


% get rid of acm noise
\settopmatter{printacmref=false}
\renewcommand\footnotetextcopyrightpermission[1]{}
%\pagestyle{plain}

%\usepackage{booktabs} % For formal tables
\usepackage{xspace,listings,url,framed,amssymb,
            mathpartir,hyperref,doi, mathtools,wrapfig,
            stmaryrd, graphicx, tikz, colortbl, xparse, etoolbox, pgffor, makecell} % double brackets llbracket
\usepackage[customcolors,norndcorners]{hf-tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{shapes.multipart}
\usetikzlibrary{positioning}
\usetikzlibrary{calc}
\usetikzlibrary{backgrounds}
\usepackage[inline]{enumitem}

% \usepackage{prelude}
\usepackage{epigraph}
%\setlength{\epigraphwidth}{0.75\linewidth}
\setlength{\epigraphrule}{0pt}
\renewcommand*{\textflush}{flushright}
%\renewcommand*{\epigraphsize}{\normalsize\itshape}
\setlength{\epigraphwidth}{4in}

\newcommand{\code}[1]{{\tt #1}\xspace}

\newcommand{\FZ}[1]{\textbf{FZ: #1}}

\input{macros}

\definecolor{Gray}{gray}{0.9}
\definecolor{vlightgray}{gray}{0.93}

\lstdefinelanguage{JavaScript}{
  keywords={typeof,new,true,false,instanceof,catch,function,return,null, 
    catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{darkgray},
  ndkeywords={class,def,interface,export,boolean,throw,extends,implements,import,this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,  comment=[l]{//},  morecomment=[s]{/*}{*/},
  commentstyle=\color{gray}\ttfamily,  stringstyle=\color{gray}\ttfamily,
  morestring=[b]',  morestring=[b]",
  %backgroundcolor=\color{vlightgray},
  aboveskip=\medskipamount, %0em,
  belowskip=\medskipamount, %0em
  escapeinside={(*@}{@*)}
}
\lstset{
  language=JavaScript,  extendedchars=true,  basicstyle=\small\ttfamily,
  showstringspaces=false,   showspaces=false,  numberstyle=\small,
  numbersep=9pt,  tabsize=2, breaklines=true,  showtabs=false, captionpos=b
}

\renewcommand{\u}[1]{\underline{#1}\xspace}

\usepackage[textsize=tiny]{todonotes}



%
%\usepackage[ruled]{algorithm2e} % For algorithms
%\renewcommand{\algorithmcfname}{ALGORITHM}
%\SetAlFnt{\small}
%\SetAlCapFnt{\small}
%\SetAlCapNameFnt{\small}
%\SetAlCapHSkip{0pt}
%\IncMargin{-\parindent}

%
%% Metadata Information
%\acmJournal{POMACS}
%\acmVolume{9}
%\acmNumber{4}
%\acmArticle{39}
%\acmYear{2010}
%\acmMonth{3}
%\acmArticleSeq{11}

%\acmBadgeR[http://ctuning.org/ae/ppopp2016.html]{ae-logo}
%\acmBadgeL[http://ctuning.org/ae/ppopp2016.html]{ae-logo}

% Copyright
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}

\setcopyright{none}

% DOI
%\acmDOI{0000001.0000001}

% Paper history
%\received{February 2007}
%\received{March 2009}
%\received[accepted]{June 2009}
%



% Document starts
\begin{document}
% Title portion
\title{Gradual Types for Objects Redux}
\author{No Author}
%\orcid{1234-5678-9012-3456}
%\affiliation{%
 % \institution{Myself}
 % }
%  \streetaddress{104 Jamestown Rd}
 % \city{Williamsburg}
 % \state{VA}
 % \postcode{23185}
 % \country{USA}}
%\author{Chengdu Huang}
%\author{John A. Stankovic}
%\author{Tarek F. Abdelzaher}
%\affiliation{%
%  \institution{University of Virginia}
%  \department{School of Engineering}
%  \city{Charlottesville}
%  \state{VA}
%  \postcode{22903}
%  \country{USA}
%}


\begin{abstract}
The enduring popularity of dynamically typed languages has given rise to a
cottage industry of static type systems, \emph{gradual type systems}, that
let developers annotate legacy code piecemeal. Soundness for a program which
mixes typed and untyped code means that some errors will caught at type
checking time, while other will be caught as the program executes. After a
decade of research it is clear that the combination of mutable state, self
references and subtyping presents serious challenges to implementers.  This
paper reviews the state of the art in gradual typing for objects. We
introduce \kafka, a class-based object calculus with a static type system,
dynamic method dispatch, transparent wrappers and dynamic class
generation. We model key features of several gradual type systems by
translation to \kafka and discuss the implications of the respective
designs.
\end{abstract}


\maketitle

\section{Introduction}

\epigraph{\small ``Because half the problem is seeing the problem''}

\vspace{-5mm}

\noindent A decade ago Siek and Taha~\cite{SiekTaha07} presented a gradual type
system for a variant of Abadi and Cardelli's object-based
calculus~\cite{cardelli:1996:theory-of-objects}. Their system featured a dynamic
type, denoted \any, and a subtype relation that combined structural subtyping
with a consistency relation between terms that differ in dynamic type
annotations.  Soundness at the boundaries between typed and untyped code is
ensured by inserting casts as shown in their previous work for functional
languages~\cite{SiekTaha06}.  Ten years later, many systems support the gradual
addition of types to untyped object-oriented programs.\footnote{Languages which
allow mixing typed and untyped with objects include
%%
C\#~\cite{Bierman10},
Dart~\cite{dart13}, 
DRuby~\cite{FurrAF2009},
Hack~\cite{hack13}, 
Gradualtalk~\cite{GS13},
Reticulated Python~\cite{siek14}, 
Safe Typescript~\cite{safe-typescript},
StrongScript~\cite{ecoop15}, 
Thorn~\cite{oopsla09}, 
Typed Racket~\cite{Takikawa:2012}, 
TypeScript~\cite{BAT14}.}
%%

Despite its age and popularity, faithful realizations of Siek and Taha's
elegant idea have proved to be surprisingly elusive, one possible reason
being that the original paper did not consider state. The combination of
mutable state, aliasing and subtyping complicates enforcement strategies as
one must consider situations where an object is being accessed at different
types. While several solutions have been proposed to address this, the
performance implications of the implementation strategies of these solutions
seem daunting.\footnote{\emph{Sound} type systems reports order of magnitude
  pathologies, e.g.~5x for Gradualtalk~\cite{allende13}, 10x Reticulated
  Python~\cite{siek14}, 22x Safe Typescript~\cite{safe-typescript}, and 121x
  Typed Racket~\cite{popl16}. These numbers merely indicate the existence of
  configurations that hurt performance.  Most systems lack rigorous
  evaluations. } Predictably, developers of industrial languages have chosen
to compromise on soundness to avoid degrading performance.\footnote{Dart,
  Typescript and Hack use unchecked modes for production, all type errors
  will not be reported.}

This paper explores the design space of gradual type systems for object-oriented
languages. We aim to expose some of the forces that have influenced existing
systems and discuss the implication of key design decisions. While there are
significant challenges that, in the end, may prevent adoption of some of the
more ambitious type systems, there are are also opportunities for improving on
existing techniques.  This paper also aims to lay the agenda for future
investigations.

To capture the essence of gradual typing for objects and to highlight the
challenges implementers face, we present translations of representative subsets
of gradually typed languages into a common target language. Targeting the same
language lets us reason about the type systems in the same framework and allows
for comparison. But which language should we target? The language should avoid
linguistic clutter while expressing key object-oriented features directly rather
than by encoding. We propose to target a typed object-oriented language
inspired by modern language runtime such as the Java Virtual Machine and the
CLR in .Net. They have a static type system with classes and subtyping but they
also allow for dynamic resolution of method dispatch.\footnote{Both runtime
support reflective invocation based on method names. Dynamic resolution was
added to C\# in version 4.0~\cite{BAT14}. In Java, \xt{invokedynamic} allows for
custom method dispatch.} As well as reasonably efficient implementations, and in
both environments, primitive types can be unboxed.

A contribution of this work is the design of \kafka, a statically typed object
calculus.  \kafka is class based (with an explicit class table \K), with mutable
state (a heap address \a refers to an object, each field \f is reified into a
pair of getter and setter methods), and allows the dynamic generation of wrapper
classes (by update of the class table \K and allocation of new objects \a).
Methods can be statically resolved, denoted by a simple call \Call\a\m\x, or can
be dynamically resolved, denoted by a dynamic call \DynCall\a\m\x. The \kafka
type system has two types, a structural type \C, allow for recursive typing 
and stored in a class table \K, and the dynamic
type \any. Types in general are referred to as \t.

The heart of any gradual type system implementation is the explicit casts
that are inserted at type boundaries.  Two different \emph{structural} casts
are built-in to \kafka; they only inspect the structure of objects.  The
subtype cast \SubCast\t\a is a structural cast that checks if the object
references by \a is a subtype of type \t. 
To support some of the more complex type systems,
\kafka is extended by \emph{generative} casts which create new wrapper
classes.  The behavioral cast \BehCast\t\a generates a wrapper object that
monitors that methods invoked on \a abide by the interface of type \t. 

Another contribution is the translation of five type systems representative
of the main strains of gradual typing for objects. Each gradually typed
expression \HT{\u\e}{\u\T} in the source is translated to a well-typed
\kafka term, \HT\e\T, each type \u\T has a corresponding \kafka type \T,
and, similarly, each expression \u\e has an equivalent \e. While soundness
in \kafka is straightforward (except for generative casts), soundness of the
source gradual type systems is more interesting.  In \kafka, a well-typed
program can only get stuck at a cast or a dynamically resolved call.  With
gradual types, an expression \Call{\u\x}\m{\u{\x'}} where \u\x is declared
to be of class \u\C can have significantly different behavior depending on
choices made while designing the gradual type system. TypeScript has
\emph{optional types}; a well-typed program can get stuck at any method call
as \u\C translates to \any. Thorn has \emph{concrete types}; a well-typed
program will not get stuck at statically resolved method calls, and \u\C
maps to itself \C. Typed Racket has \emph{promised types}; a well-typed
program will not get stuck at a call to \m, because \u\x refers to an
object, or wrapper, that implements \m.  Wrappers may fail if their target
does not behave like a \u\C. Finally we describe the 
%monotonic and 
transient variant of Reticulated Python which has somewhat surprising
semantic properties. \FZ{Does it?}

%\newpage %% Sanity check.  If you see it, then something went wrong.

\section{Background}

\vspace{-5mm}

\epigraph{\small ``If you know the enemy and know yourself...''}

\vspace{-5mm}

\noindent The intellectual lineage of gradual types can be traced back to
attempts to add types to Smalltalk and LISP. A highlight on the Smalltalk
side is the Strongtalk optional type system~\cite{Bracha93} which led to
Bracha's notion of pluggable types~\cite{pluggabletypes}. For him, types are
solely to catch errors at compile-time, they should never affect the
runtime behavior of programs. The rationale for this is that types are
viewed as an add-on that can be turned off without affecting semantics.  In
the words of Richards~\emph{et al.}~\cite{ecoop15}, an optional type system
is \emph{trace preserving}, which means that if a term \e reduces to value
\a, adding type annotations will never cause \e to get stuck. This property
is valuable to developers as it prevents type annotations from introducing
errors, and it follows that type annotations do not effect performance. The
optional type systems currently in wide use include Hack~\cite{hack13},
TypeScript~\cite{BAT14} and Dart~\cite{dart13}. 

On the functional side, the ancestry is dominated by the work of Felleisen
and his students.  The Typed Scheme~\cite{tf-popl08} design that later
became Typed Racket is strongly influenced by earlier work on higher-order
contracts~\cite{ff-icfp02}. Typed Racket was envisioned as a vehicle for
teaching programming, thus being able to explain the source of errors was an
important design constraint, another constraint was to prevent surprises --
a variable annotated as a \C should behave as a \C. Any change in behavior must be
reported at the first discrepancy. The Typed Racket approach to gradual
typing is thus quite different from optional types. Whenever a value crosses
a boundary between typed and untyped code, it is wrapped in a contract that
monitors its behavior. This ensures that the type of mutable values remains
consistent with their declared type and that functions respect their
declared interface. When a value misbehaves, blame can be assigned to the
boundary the value crossed. The granularity of typing is the module, thus a
module is either entirely typed or entirely untyped. This means that a
compilation unit only deals with uniform code (typed or untyped) and that
closely coupled functions co-located in a module will not incur
boundary crossing costs.

Siek and Taha coined the term gradual typing in~\cite{SiekTaha06} as ``any
type system that allows programmers to control the degree of static checking
for a program by choosing to annotate function parameters with types, or
not.'' Their contribution was a formalization of the idea in a lambda
calculus with references and a proof of soundness. They defined the type
consistency relation $\t \sim \tp$ which states that types that agree on
non-\any position are compatible.  In~\cite{SiekTaha07} they extended their
result to a stateless object calculus and combined consistency with
structural subtyping. Extending the approach to mutable objects proved
challenging. Reticulated Python~\cite{siek14} attempts to find a compromise
between soundness and efficiency.  The language has three modes:
\emph{guarded} mode behaves as Racket with contracts applied to values,
\emph{transient} mode performs first order checks before each call, and
\emph{monotonic} mode is similar to the guarded mode except in there are no
wrapper chains and casts only remove occurrences of \any from an object's
type.

Other noteworthy systems include Gradualtalk~\cite{GS13}, C\#
4.0~\cite{Bierman10}, Thorn~\cite{oopsla09},
StrongScript~\cite{ecoop15}. Gradualtalk is a variant of Smalltalk with
Felleisen-style contracts and mostly nominal type equivalence (structural
equivalence can be specified on demand, but it is, in practice, rarely
used). C\# 4.0 adds the type {\sf dynamic} (i.e.~\any) to the C\# language
and adds dynamically resolved method invocation when the receiver of method
call is with type \any.  This means C\# has a dynamic sublanguage that allows
developer to write unchecked code, but it also has a strongly type
sublanguage in which values are guaranteed to be of their declared type.
The implementation of C\# in the~.Net framework replaces \any by the type
{\sf object} and adds casts where needed. A dynamically resolved method call
operation is supported as part of the reflective interface of~.Net.  Thorn
and StrongScript extend the C\# approach with the addition of optional types
(called {\em like types} in Thorn).  Thorn is implemented by translation to
the JVM.\footnote{The translation strategy is surprisingly close to what we
  present later in the paper. The main difference is that the JVM does not
  have a type \any so, like in C\#, \code{Object} is used.} The presence of
concrete types means that the compiler can optimize code (unbox data and
in-line methods) and programmers are guaranteed that type errors will not
occur within concretely typed code. 

%\subsection{Surveying the design space}

%\newcommand{\rot}[1]{\begin{rotate}{80} #1 \end{rotate}}
\newcommand{\rot}[1]{\rotatebox{80}{#1}}
%\newcommand{\rot}[1]{ #1 }
\newcommand{\X}{\EM{\bullet}}
\newcommand{\XX}{\EM{\bullet^{(2)}}}
\newcommand{\XY}{\EM{\bullet^{(1)}}}

\begin{figure}[!ht]
  \center
~ \\[2cm]
  {\small
\begin{tabular}{r|lllllllllllllr}
 & & \rot{Nominal}
  & \rot{Optional types}
  & \rot{Concrete types}
  & \rot{Promised types}
  & \rot{Class based}
  & \rot{First-class Class}
  & \rot{Soundness claim}
  & \rot{Unboxed prim.}
  & \rot{Subtype cast}
  & \rot{Shallow cast}
  & \rot{Generative cast}
  & \rot{Blame}
  & \rot{Pathologies}
  \\
Dart         &&\X &\X &   &   &\X &   &    &    &\X &   &   &   &  - 
\\\hline
Hack         &&\X &\X &   &   &\X &   &    &    &\X &   &   &   &  -  
\\\hline
TypeScript   &&   &\X &   &   &\X &   &    &    &   &   &   &   &  -  
\\\hline
C\#          &&\X &\X &\X &   &\X &   &\XX & \X &\X &   &   &   &  -  
\\\hline
Thorn        &&\X &\X &\X &   &\X &   &\XX & \X &\X &   &   &   & 0.8x
\\\hline
StrongScript &&\X &\X &\X &\X &\X &   &\XX &    &\X &   &\X &   & 1.1x   
\\\hline
Gradualtalk  &&\XY&   &   &\X &\X &   & \X &    &   &   &\X &\X &  5x
\\\hline
Typed Racket &&   &   &   &\X &\X &\X &\X  &    &   &\X &\X &\X & 121x 
\\\hline
Reticulated Python    \\
\it Transient&&   &\X &   &   & \X &  & \X &    &   &\X &   &\X & 10x \\
\it Monotonic&&   &   &   &\X & \X &  & \X &    &   &   &\X &\X &  27x\\
\it Guarded  &&   &   &   &\X & \X &  & \X &    &   &   &\X &\X &  21x\\
\end{tabular}}
  \caption{Overview of implemented systems. (1) Gradualtalk has optional
    structural constraints. (2) Concretely typed expressions are sound in
    C\#, Thorn and StrongScript.}\label{over}
\end{figure}

%\noindent
\figref{over} reviews gradual type systems with publicly available
implementations. All languages here are class-based, except TypeScript which
has both classes and plain JavaScript objects. Most languages base subtyping
on explicit name-based subtype declarations, rather than on structural
similarities.  TypeScript uses structural subtyping, but does not implement
a runtime check; this is likely due to the JavaScript roots of the language,
anecdotal evidence suggests that structural subtyping is rarely
needed~\cite{ecoop15}. StongScript extends TypeScript but changes subtyping
back to nominal.  The consistency relation used in Reticulated Python is
fundamentally structural.  For Racket, the heavy use of first-class classes
and class generation naturally leads to structural subtyping as many of the
classes being manipulated have no names.  Optional types are the default
execution mode for Dart, Hack and TypeScript.  Transient Python is, in some
senses, optionally typed as any value can flow into a variable regardless of
its type annotation, leading to its ``open world'' soundness
guarantee~\cite{siek14}.  In Thorn and C\#, primitives are concretely
typed they can be unboxed without tagging.  The choice of casts follows from
other design decisions. Languages with concrete types naturally tend to use
subtype casts to establish the type of values. For nominal systems there are
highly optimized algorithms. Shallow casts are casts that only check the
presence of methods, but not their signature. These are used by Racket and Python
to ensure some basic form of type conformance. Generative casts are used
when information such as a type or a blame label must be associated with a
reference or an object.

Blame assignment is a topic of investigation in its own right. Anecdotal
evidence suggests that the context provided by blame helps developers
pinpoint the provenance of the ill-typed values. A fitting analogy are the
stack traces printed by Java when a program terminates abruptly. Developers
working in, e.g, C++ must run their program in a debugger to obtain the same
information. Stack traces have little run-time cost because they piggyback
on another feature, namely precise exceptions, which does come at a price as
it inhibits some compiler optimizations. It is likely that recording blame
is costly, but there is no data on how much implementations pay for it.

The last column of \figref{over} lists self-reported performance pathologies.
These numbers are not comparable as they refer to different programs and
different configurations of type annotations. They are not worst case scenarios
either; most languages lack a sufficient corpus of code to conduct a thorough
evaluation.  Nevertheless, one can observe that for optional types no overhead
is expected, as the type annotations are erased during compilation. Concrete
types insert efficient casts, and lead to code that can be optimized.  The
performance of the transient semantics for Reticulated Python can be viewed as a
worst case scenario for concrete types -- i.e. there is a shallow cast at almost
every call. Finally, languages with generative casts tend to suffer prohibitive
slow downs in pathological cases.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \newpage
\section{KafKa: A Core Calculus}\label{kafkacore}


%\vspace{-2mm}

\epigraph{\hspace{-1cm}\small ``Aux chenilles du monde entier et aux papillons qu'elles renferment''}

\vspace{-3mm}

\noindent
The basis of our formal approach \kafka, a class-based, statically typed
object-oriented language. The distinctive features of the calculus are its
support for both typed and untyped method innovation, as well as that
dynamic class generation by explicit class tables.  The features of \kafka
are modeled on common compilation targets for object-oriented language such
as the JVM's Java Bytecode or the .NET CLR's Common Intermediate
Language. Both of which have typed intermediate language with support for
untyped method call (through their reflection API) and class generation (by
dynamic loading).  Our design is guided by the intuition that the semantics
of object-oriented languages with gradual types can be translated to a
common representation by the introduction of \emph{casts} and
\emph{wrappers}.

\begin{figure}[!h]\hrulefill

\vspace{4mm}

\small\begin{tabular}{@{}lll}

\begin{minipage}{9cm}\begin{tabular}{@{}l@{~}l@{}l@{}l@{}l@{}l@{}l@{}l}
\e\hspace{.1cm} ::= & \hspace{.2cm} \x        
    &\B \this         
   &\B \that      
   &\B \FRead\f     
   &\B \FWrite\f\e   
   &\B \KCall\e\m\e\t\t \\
   & &
   &\B \SubCast\t\e 
   &\B \BehCast\t\e 
   &\B \New\C{\b\e}  
   &\B \DynCall\e\m\e 
\end{tabular}\end{minipage}&
\begin{minipage}{2.9cm}\begin{tabular}{l@{~}l@{}l@{}l}
   ~ \k &::= \Class \C {\b\fd}{\b\md} \\
~ \t&::= ~ \any  \B   \C  \\ 
\end{tabular}\end{minipage} &
\begin{minipage}{2.9cm}\begin{tabular}{l@{~}l@{}l@{}l}
\md &::= \Mdef\m\x\t\t\e \\
~\fd&::= ~ \Fdef\f\t \\ 
\end{tabular}\end{minipage}\end{tabular}

\vspace{4mm}

\noindent\hrulefill
\caption{\kafka Syntax.}\label{syn}
\end{figure}

\paragraph{Syntax}  
\kafka is an object calculus that satisfies the above design
requirement. Its syntax is given in \figref{syn}.  Types consist of class
names \C, \D and the dynamic type, written \any.  Class definitions have a
class name and (possibly empty) sequences of field and method definitions,
\Class\C{\fd_1..}{\md_1..}. Field definitions consist of a field and its
type, \Fdef\f\t. Method definitions have (for simplicity) a single argument
and an expression, denoted \Mdef\m\x\t\t\e.  \kafka supports a limited form
of overloading, allowing both a typed implementation and an untyped
(dynamically checked) implementation for each method.  Fields are private to
objects, and can be accessed only from the object scope; reading a field is
denoted \(\FRead\f\) and writing a field is denoted \(\FWrite\f\e \).  The
calculus supports both statically and dynamically resolved method invocation
(denoted \KCall\e\m\e\t\t and \DynCall\e\m\e).  The static dispatch resolves
overloading via the type tag on the method call.  We let meta-variables \x
ranges over variable names, \m and \f range over methods and fields
respectively; \this is a distinguished identifier representing a method
receiver, while \that is a distinguished field name that will be used in
wrapper classes.  Providing two different cast mechanisms is a key feature
of the calculus.  The former, the \emph{structural cast}, \(\SubCast\t\e\),
denotes the usual subtype cast that dynamically type-checks its argument.
The latter, the \emph{behavioural cast}, \(\BehCast\t\e\), rather that
type-checking the argument at run-time, builds a wrapper around it.  The
wrapper then ensures that all the successive requests to the object will be
understood (or raise an error). The design of the behavioural cast is
intricate, and deserves its own section below.
State is represented via a heap \s mapping addresses ranged over by \a
to objects denoted \hspace{-1mm}\obj\C{\a_1..}.


\paragraph{Static semantics}
A well-formed program, denoted \WFp\e\K, consists of an expression \e and a
class table \K where each class \k is well-formed and \e is well-typed with
respect to \K.  A class is well-formed if all its fields and methods are
well-typed and it has at most two definitions for any method \m, one typed
\Mdef\m\x\C\D\e and one untyped \Mdef\m\x\any\any\e.  The static semantics
of \kafka is mostly standard; the complete set of rules is in Appendix.  The
subtype relation, \StrSub\M\K\t\tp, shown in Fig.~\ref{sub}, allows for
recursive structural subtyping: for this the environment \M keeps track of
the set of subtype relations assumed.  The notation \md\In\App\K\C denotes
the method definition \md occurring in class \C and class table \K.  Recall
fields are hidden from the class type signature, so subtyping is limited to
method definitions.  Key type rules are in Fig.~\ref{f:staticsem}.  Method
calls use \emph{syntactic} disambiguation to select between typed and
untyped methods. The dynamically resolved call places no requirements on the
receiver or argument, and returns type \any.  The statically resolved call
has the usual type requirements on arguments. Statically, the two subtype
cast rules are similar; they ensure the value has the cast-to type. However,
the way their soundness is enforced at run-time is very different.
%References can be typed both as dynamic, or with the type of the object the
%point to in the current heap \(\sigma\). 


\begin{figure}[!t] \hrulefill\small

\vspace{-2mm}

\begin{mathpar}
\Rule{SAss}{
\C \Sub \D \in \M
}{
 \StrSub \M\K \C\D
}

\hspace{-8mm}

\Rule{SRec}{
 \M' = \M~\C\Sub\D\\\\
\md \in \App\K\D \implies \mdp \in \App\K\C ~.~ \StrSub{\M'}\K\md{\mdp}
}{
 \StrSub \M\K \C \D 
}

\hspace{-8mm}

\Rule{SMet}{
  \StrSub \M\K {\t[1]} {\tp[1]} \\\\
  \StrSub \M\K {\tp[2]} {\t[2]}
}{
 \StrSub \M\K {\Mdef\m\x{\t[1]}{\t[2]}\e} {\Mdef\m\x{\tp[1]}{\tp[2]}\ep}
}
\end{mathpar}

\hrulefill\caption{\kafka subtyping}\label{sub}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\hrulefill\small

\begin{mathpar}
\Rule{W6}{
  \EnvType \Env\s\K\e\C \\
  \Mdef\m\x\t\tp\epp \in \App\K\C  \\
  \EnvType \Env\s\K\ep\t
}{
  \EnvType \Env\s\K{\KCall\e\m\ep\t\tp}\tp
}    

\Rule{W7}{
  \EnvType \Env\s\K\e\any \\
  \EnvType \Env\s\K\ep\any
}{
  \EnvType \Env\s\K{\DynCall\e\m\ep}\any
}    

\\

\Rule{W9}{
  \EnvType \Env\s\K\e\tp
}{
  \EnvType \Env\s\K{\SubCast\t\e}\t
}

\Rule{WB}{
  \EnvType \Env\s\K\e\tp
}{
  \EnvType \Env\s\K{\BehCast\t\e}\t
}

\Rule{W9}{
  \s(\a) = \obj\C{\ap_1..}
}{
  \EnvType \Env\s\K\a\C
}

\Rule{W10}{
 }{
   \EnvType \Env\s\K\a\any
}
\end{mathpar}

\hrulefill
\caption{\kafka static semantics (excerpt)}\label{f:staticsem}
\end{figure}


\paragraph{Dynamic Semantics}
The small step operational semantics for \kafka is reported in
\figref{fig:semantics}.  To resolve the \this reference in field accesses,
the syntax of expressions is extended at runtime with forms
%
\[ \e  ::= \dots \B \a \B \FReadR\a\f \B \FWriteR\a\f\e \]
%
where \a is a reference.  The static typing of references
(Fig.~\ref{f:staticsem}) can be either the class of the object they map to
in the heap \s or the dynamic type \any.
We also use evaluation contexts, \EE, defined as follows
\[
\begin{tabular}{llllllllllllllllll}
\EE &::=& ~ \FWriteR\a\f\EE   &\B  
        \KCall\EE\m\e\t\t  &\B
        \KCall\a\m{\EE}\t\t &\B
        \DynCall\EE\m\e   &\B\\
&       & \DynCall\a\m\EE   &\B
       \SubCast\t\EE  &\B
      \BehCast\t\EE  &\B
       \New\C{\b \a\,\EE\,\b\e} &\B 
      \EM{\square}
\end{tabular}
\]
\noindent
The dynamic semantics is thus defined over \emph{configurations}: triples
\K\e\s, where \K is a class table, \e is an expression and \s is a heap.  A
configuration evaluates in one step to a new configuration, \Reduce
\K\e\s\Kp\ep\sp; the new configuration may include a new class table built
by extending the previous table with new classes.
Calling forms specify the typing of the method to resolve overloading; this
is always \(\any \to \any\) for dynamic calls, but can be either \(\C \to
\D\) or \(\any \to \any\) for static calls.  Structural casts to \any always
succeed while structural casts to \C check that the runtime object is an
instance of a subtype of \C.  Evaluation contexts are deterministic and
enforce a strict evaluation order.




%
\begin{figure}[!h]
\noindent\hrulefill


\medskip
\small

\begin{minipage}{\textwidth}
\small        
\begin{tabbing}
\K\HS \New\C{\b\a} \HS\HS\HS\= \s~ \HS\HS \=\Red\HS\HS \= \K \HS\= \ap \HS\HS\= \sp\HS\HS \= \WHERE\HS\= \fresh\ap \HS\HS\HS\HS\HS\HS\HS\HS\=  \sp = {\Map\s{\Bind\ap{\obj\C{\a_1..}}}}
\\
\K\HS \FReadR\a{\f_i} \> \s           \>\Red\>     \K \>$\a_i$ \> \s  \> \WHERE \>\App\s\a=\obj\C{\a_1..\a_i..}
\\
\K\HS {\FWriteR\a{\f_i}\ap} \> \s     \>\Red\>     \K \> \ap \> \sp \>  \WHERE \>\App\s\a=\obj\C{\a_1..\a_i..} \HS  \> \sp = \Map\s{\Bind\a{\obj\C{\a_1..\ap..}}}
\\
\K\HS{\KCall\a\m\ap\t\tp} \> \s    \>\Red\>     \K \>  \ep \> \s \> \WHERE\> \ep = {[\a/\this~{\ap/\x}]\e} \HS \> \Mdef\m\x\t\tp\e\In \App\K\C  \HS  \App\s\a=\obj\C{\a_1..}
\\
 \K\HS {\DynCall\a\m\ap}\> \s        \>\Red\>    \K \> \ep \> \s \>  \WHERE\> \ep = {[\a/\this~{\ap/\x}]\e}\HS \> \Mdef\m\x\any\any\e \In \App\K\C \HS \App\s\a=\obj\C{\a_1..}
\\
 \K\HS {\SubCast \any\a} \> \s       \>\Red\>   \K \> \a \> \s
\\
 \K\HS {\SubCast \D\a} \> \s        \>\Red\>    \K \> \a \> \s \>  \WHERE\> \StrSub {}\K\C \D \>\App\s\a=\obj\C{\a_1..} 
\\
 \K\HS {\BehCast \t\a} \> \s         \>\Red\>   \Kp \> \ap \> \sp \> \WHERE\> \behcast \a\t\s\K \Kp\ap\sp    
\\
\K\HS\e \>\s                         \>\Red\>   \Kp \> \ep \> \sp
\\
 \K \HS \EM{\EE[\e]} \> \s               \>\Red\>   \Kp \> \EM{\EE[\ep]} \> \sp \> \WHERE \> \K~\e~\s \Red~\Kp~\ep~\sp
\end{tabbing}
\end{minipage}

\medskip

\hrulefill
\caption{\kafka dynamic semantics}\label{fig:semantics}
\end{figure}



\paragraph{Behavioural Casts}
A cast \BehCast\t\a creates a wrapped object \ap which dynamically checks
that object \a behaves as if ot was of type \t.  We refer to the type of \a
as the \emph{source} type, and to the type \t as the \emph{target} type.
This cast is generative as it creates both a new class (for the wrapper
object) and a new instance of that class (the wrapper itself). Its dynamic
semantics is reported in \figref{behavetext} and \figref{w}.  When the
target type is a class, say \Cp, the bcast function wraps a reference \a
with an instance of a freshly generated wrapper class \D that obides by the
interface of \Cp. The function allocates the wrapper in the heap and updates
the class table.  The cast performs a semantic check that the source type
has at least all the method names requested by the target type.  Also the
cast is not define for classes with overloaded methods (\textsf{nodups}
checks that).  This prevents ambiguity when in method resolution in wrapped
objects. Similarly, when the target type is \any, the cast allows \a to
act like an instance of \any.

\newcommand{\bscast}[2]{\EM{\BehCast{#1}{{#2}}}}

\begin{figure}[!b]
\hrulefill
\small

\vspace{-4mm}

\begin{equation*}
  \behcastE\a\Cp\s\K \Kp\ap\sp \HS\HS\WHERE\HS\HS \begin{cases}
\HS  \App\s\a = \obj\C{\a_1..} \HS\HS
  \fresh{\D,\ap,\that} \HS\HS
  \mds 1.. \In \App\K\C \qquad \mdps 1.. \In \App\K\Cp \\\HS
  \names{\mds 1..} \subseteq \names{\mdps 1..} \HS\HS \cload{\mdps 1..} \\\HS
  \Kp = \K\,\wrap\C{\mds 1..}{\mdps 1..}\D\that \HS\HS
  \sp = \Map \s{\Bind\ap{\obj\D{\a}}} 
  \end{cases}
\end{equation*}

\begin{equation*}
  \behcastE\a\any\s\K \Kp\ap\sp  \HS\HS\WHERE\HS\HS\begin{cases}\HS
  \App\s\a = \obj\C{\a_1..} \HS\HS \mds 1.. = \App\K\C \HS\HS
  \fresh{\D,\ap,\that} \HS\HS \cload{\mdps 1..} \\\HS
  \Kp = \K\,\wrapAny\C{\mds 1..}\D\that \HS\HS
  \sp = \Map \s{\Bind\ap{\obj\D{\a}}} 
\end{cases}\end{equation*}


\hrulefill
\vspace{-2mm}\caption{Behavioural casts}\label{behavetext}

\hrulefill
\small

\begin{tabbing}\small
  \wrap\C{\mds 1..}{\mdps 1..}\D\that = \src{\Class\D{\Fdef\that\C}{\mdpps 1..}}\\
  \HS\HS\WHERE\HS\= \Mdef\m\x{\t_1}{\t_2}\e\In\mds 1.. \\
                 \> \mdpps 1 =\= \src{\Mdef\m\x{\tp_1}{\tp_2}{~\BehCast{\tp_2}{\KCall{\FRead\that}\m{\bscast{\tp_1}\x}{\t_1}{\t_2}}}} ..
    \HS \= \textbf{if} \HS \Mdef\m\x{\tp_1}{\tp_2}\ep\In\mdps 1.. \\
\\[-3mm]
\> \>  \src{\Mdef\m\x{\t_1}{\t_2}{~\KCall{\FRead\that}\m{\x}{\t_1}{\t_2}}} ..  \>\textbf{otherwise}
\\[3mm]
  \wrapAny{\C}{\mds 1..}{\D}{\that} = \src{\Class \D{ \Fdef\that\C}{ \mdps 1..}}\\
\HS\HS\WHERE\HS\=\mdps 1 = \src{ \Mdef\m\x{\any}{\any}{~\BehCast\any{ \KCall{\FRead\that} \m {\bscast{\t}\x}{\t}{\tp}} } }   ..
    \HS\HS\HS\HS \= \textbf{if} \HS \Mdef\m\x{\t}{\tp}\e\In\mds 1.. \\
\end{tabbing}

\vspace{-5mm}

\hrulefill
\vspace{-2mm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\caption{Wrapper class generation}\label{w}\end{figure}


Wrapper class generation is implemented by the \xt{W} and \xt{W\!\any}
functions. Their first three arguments \(\C\), \(\md_1..\), \(\mdp_1..\) are
the source type and its methods definitions, and the method definitions of
the target type. The fourth argument, \(\D\), is the class name of the
wrapper class being built; this is always a fresh name. The last argument is
the \that field name, which is also fresh.  The function builds a new
wrapper class \(\D\).  The field \that stores a reference to the target
object and has thus type \(\C\).  The invocation of a method that appears in
\(\mdps 1..\) is forwarded to the corresponding method invocation in \(\mds
1\), except that the arguments are protected by behavioural wrappers
following the interface in \(\mds 1..\) and the return type following the
interface in \(\mdps 1..\).  Methods defined in the source type but missing
from \(\mdps 1..\) are added to the wrapper class and simply redirected to
corresponding method in the wrapped object.  Wrapping an object so that it
behaves as \any is simpler, as the wrapper systematically protects the input
type and casts back the return type to \any.  The behavioural cast reduction
rule satisfies a property instrumental to our design: a wrapper class
generated for a target type \D, is always a subtype of \D.  This will allow
us to refer to both unwrapped and wrapped objects via the original, source
language, types. The wrapper generation function will always produce a
well-formed class for a target type $\D$. The reason being that the wrapper
class only contain methods from either the source or the target type. The
wrapper class will also never contain any duplicates as it can only contain
methods that exists in the source type.  Furthermore, at most the wrapper
class will contain every method of the source type.




\paragraph{Type soundness} 
Well-typed \kafka configurations satisfy a type-preservation theorem, and
either reduce to values or are stuck on a dynamic method invocation or on a
cast.  

\medskip\noindent{\bf Theorem 1: Type Soundness.} ~
Given that $\WFp\K{\e~\s}$ and $\EnvType\cdot\s\K\e\t$,
then either there is some $\ep$ such that $\Reduce \K\e\s \Kp\ep\sp$ and
$\WFp\Kp{\ep~\sp}$ and $\EnvType\cdot\sp\Kp\ep\t$ hold, or $\e$ is in one of
the following forms: $\a$, $\EE[\DynCall\a\m{\ap}]$, $\EE[\SubCast\tp\a]$,
or $\EE[\BehCast\tp\a]$.



\medskip\noindent{\bf Lemma 1: Well-formed Wrappers.} ~



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Translating Gradual Type Systems}

%\vspace{-2mm}

\epigraph{\small ``Was ist mit mir geschehen? dachte er. Es war kein Traum''}

\vspace{-5mm}


\noindent
We are now ready to give semantics to the four gradual type systems of interest, by translating them into \kafka. 
Four each source language, compilation into \kafka is realised by a translation function that maps well-typed source programs into well-typed \kafka terms, respecting a uniform mapping of source types to \kafka types.  The compilation makes explicit which type casts (and, in turn, \emph{dynamic type-checks}) are implicitly inserted and performed by the run-time of each language, highlighting the similarities and differences among them.   

To avoid unnecessary clutter, we represent the source languages using the common syntax reported in \figref{f:sourcesyntax}.  This defines a simple object calculus similar to \kafka, but without method overloading and, most importantly, cast operations.  When modelling the Thorn type system, the additional type \CW is added to the type grammar to denote Thorn like types. 



\begin{figure}[!h]\hrulefill
\hspace{2mm}

\begin{tabular}{lll}
\begin{minipage}{8cm}\begin{tabular}{@{}l@{~}l@{}l@{}l@{}l@{}l@{}l@{}l}
\e\hspace{.1cm} ::= & \hspace{.2cm} \x        
    &\B \this         
   &\B \FRead\f     
   &\B \FWrite\f\e   
   &\B \Call\e\m\e \\
   &
   &\B \that      
   &\B \New\C{\b\e}  
\end{tabular}\end{minipage}&
\begin{minipage}{2.9cm}\begin{tabular}{l@{~}l@{}l@{}ll}
   ~ \k &::= \Class \C {\b\fd}{\b\md} \\
~ \t&::= ~ \any  \B   \C  \B \src{\CW}  \\ 
\end{tabular}\end{minipage} &
\begin{minipage}{2.9cm}\begin{tabular}{l@{~}l@{}l@{}l}
\md &::= \Mdef\m\x\t\t\e \\
~\fd&::= ~ \Fdef\f\t \\ 
\end{tabular}\end{minipage}\end{tabular}

\hrulefill
\caption{Common syntax of source languages}\label{f:sourcesyntax}
\end{figure}




\subsection{TypeScript}

\begin{figure}
\hrulefill
\begin{mathpar}

\Rule{STGC-SUB}{
  \StrSub\cdot\K\t\tp
}{
  \ConvertE\K{s}\t\tp
}

\IRule{STGC-TOANY}{
}{
  \ConvertE\K{s}\t\any
}

\IRule{STGC-ANYCONC}{
}{
  \ConvertE\K{s}\any\tp
}


\IRule{STG-VAR}{
   \HasType \Env\x\t
 }{
   \EnvTypeS \Env\K\x\t
} 

\IRule{STG-GET}{
   \HasType \Env\this\C \\
  \Fdef\f\t \in \App\K\C
}{
  \EnvTypeS \Env\K{\FRead\f}\t
}    

\IRule{STG-SET}{
  \HasType \Env\this\C \qquad
  {\Fdef\f\t \in \App\K\C} \\
  \EnvTypeS \Env\K\e\tp \qquad
  \ConvertE\K{s}\tp\t
}{
  \EnvTypeS \Env\K{\FWrite\f\e}\t
}    

\IRule[width=20em]{STG-CALL}{
  \EnvTypeS \Env\K\e\C \\
  \Mtype \m\t\tp\in \classoff\C\K  \\
  \EnvTypeS \Env\K\ep\tpp \\
  \ConvertE\K{s}\tpp\t
}{
  \EnvTypeS \Env\K{\Call\e\m\ep}\tp
}    

\IRule{STG-NEW}{
 \EnvTypeS \Env\K{\e_1}{\tp[1]}~~\dots~~ 
 \EnvTypeS \Env\K{\e_n}{\tp[n]}\ \\  
 \ConvertE\K{s}{\tp[1]}{\t[1]} ~~\dots~~ \ConvertE\K{s}{\tp[n]}{\t[n]} \\
 \b\fd=\Fdef{\f_1}{\t_1}~\dots~\Fdef{\f_n}{\t_n} \\ 
  \Class \C {\b\fd}{\b\md} \in \K
}{
  \EnvTypeS \Env\K{\New\C{\e_1\dots\e_n}}\C
}
\end{mathpar}

\hrulefill
\caption{TypeScript type system}\label{f:typescriptts}
\end{figure}


Typescript~\cite{BAT14} is a backward compatible extension of JavaScript
with classes and type annotations. Type equivalence is structural and
subtyping of recursive types is supported (as in \kafka types arise from class
declarations). Missing annotations are treated as \any. The role of types is
to catch simple errors, such as misspelt method names, as well as assisting
IDEs.  A typical example is shown here. The first expression is ill-typed
because method \(o\) does not exist in class \C, while the second is erroneous as it
provides an instance of \C where \D is expected. The third
expression is statically correct as the instance of \C is cast to a
\D by the \n method.
%
%\[
%\begin{array}{l}

\medskip
\(
\Class \C {   \Mdef\m\x\D\C \this  ; \   \Mdef\n\x\any\D \x }
\)

\medskip
\( \Call {\New \C{}} o {\New \D{}} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \texttt{    // ERR wrong method } \)

\(\Call {\New \C{}} \m {\New \C{}} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \texttt{ // ERR wrong type } \)

\(\Call {\New \C{}} \m {\Call {\New \C{}} \n {\New \C{}}} \ \ \ \texttt{ // OK } \)


\medskip

%\FZ{fix typesetting of method name o}

%\begin{lstlisting}
% class A { 
%    m(x: C): A { this }
%    n(x: *): C { x } }
%
% new A().o(new C()) // ERR wrong method
% new A().m(new A()) // ERR wrong type
% new A().m(new A().n(new A())) // OK 
%\end{lstlisting}
%
\noindent
Our formalisation of the TypeScript type system is reported in \figref{f:typescriptts}.  We illustrate its design by focussing on the examples above and study how the \RuleRef{STG-CALL} rule enforces the expected outcome.  Since the receiver has type \C, the first expression is simply ruled out by the check that the called method must be part of the class signature.  The second is more interesting: the method exists but expects a \D argument while we are passing a \C.  The \emph{convertibility} relation, denoted   \ConvertE\K{s}\t\tp, captures precisely the allowed implicit type conversion.  For TypeScript, values can flow freely to and from \any, and it is also allowed to pass a subtype when a supertype is expected.  Since in our second example, the types \C and \D are incompatible, the convertibility check fails.

The TypeScript compiler then translates well-typed code to plain JavaScript, with all types erased and methods resolved dynamically. Of course, since convertibility allows arbitrary values can be passed whenever a \any value is expected, dynamically resolved calls may fail because the receiver need not have the requested method. The designers of TypeScript saw this unsoundness as a way to
ensure, ({\em a}) that types do not get in the way of running correct
programs, e.g. when importing a new library with type annotations
inconsistent with existing client code; and ({\em b}) an insurance for
backwards compatibility, as ignoring types means all browsers can run
TypeScript code -- with no additional overhead.


\newcommand{\TR}[1]{\EM{\llbracket    #1 \rrbracket}}
\newcommand{\TA}[1]{\EM{\llparenthesis 2 \rrparenthesis}}

\newcommand{\TRG}[2]{\EM{\llbracket    #1 \rrbracket_{#2}}}
\newcommand{\TAG}[3]{\EM{\llparenthesis #1 \rrparenthesis_{#2}^{#3}}}

The TypeScript dynamic semantics can be modelled in \kafka with a very simple translation mechanism, where every
type becomes \any  (including in method signatures) and every call becomes a dynamic call.  
For instance one would translate the class
definition and the last expression above as:

\medskip
\(
\Class \C {   \Mdef\m\x\any\any \this  ; \   \Mdef\n\x\any\any \x }
\)

\medskip

\(\DynCall {\New \C{}} \m {\DynCall {\New \C{}} \n {\New \C{}}} \)


\medskip
\noindent This  scheme can be implemented by the simple top-down algorithm in \figref{f:typescriptkafka}.  The translation function \(\TR{\dots}\) is applied to both class definitions and expression; to avoid confusion, the grey background is used to identify translated terms (that is \kafka terms).  


\begin{figure}[!h]
\hrulefill

\smallskip
\begin{tabular}{@{}l@{~ ~ ~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}ll}
\small
 \begin{minipage}{8cm}  
\begin{tabbing}
\TR{\Class \C{\fds 1..}{\mds 1 .. } } = \src{ \Class \C{ \fdsp 1..}{\mdsp 1..}}\HS \WHERE\HS
  \=\fds 1 = \Ftype\f\t ..,\HS\HS\=\fdsp 1 = \src{\Ftype\f\any} .., \HS\HS\=\mds 1 = \Mdef\m\x{\t_1}{\t_2}\e \\
  \>\mdsp 1 = \src{\Mdef\m\x\any\any\ep},\HS\HS \>\>\ep = \TR{\e}
\end{tabbing}
\begin{tabbing}
\TR{\FRead\f}\HS\HS\HS\HS\= = \src{\FRead\f}
\\[1mm]
\TR{\FWrite\f\e} \> = \src{\FWrite\f\ep} \HS\HS\HS\HS\HS\=\WHERE~\ep=\TR\e
\\[1mm]
\TR\this           \>= \src{\SubCast\any\this}
\\[1mm]
\TR\x \> = \src \x
\\[1mm]       
\TR{\Call{\e_1}\m{\e_2}} \> = \src{\DynCall{\eps 1}{\m}{\eps 2}} \HS\>\WHERE\HS\eps 1 = \TR{ \e_1}, \HS \eps 2 = \TR{\e_2}
\\[1mm]
\TR{\New\C{\e_1..}} \> = \src{\SubCast\any{\New\C{\eps 1..}}} \HS \>\WHERE \HS   \eps 1 = \TR{\e_1} ..
\end{tabbing}
\end{minipage}
\end{tabular}

\smallskip
\hrulefill
\caption{TypeScript to \kafka translation}\label{f:typescriptkafka}
\end{figure}


\noindent  All TypeScript types are represented with the dynamic \kafka type, \any, and all translated expressions have type \any.  This is a simple instance of a general property that all our translations into \kafka satisfy.  Let \(\kty\t\) be a mapping from source types to \kafka types -- for TypeScript the mapping is trivial: for all types \t, \kty\t = \src{\any}.  It then holds that if \e is a well-typed source expression with type \t, then \TR{\e} is a well-typed \kafka expression with type \kty{\t}.  The precise statement and proof are reported in the Appendix.

Observe that the TypeScript translations does insert some structural casts to \any, but these have no operational effect (a structural cast to \any always succeed at runtime) and are only needed to satisfy the constraints of the \kafka type system.  The unsoundness comes from discarding the type of the callee and systematically relying on  dynamic method invocation for method calls.

% \clearpage

\subsection{Thorn}

Thorn~\cite{oopsla09} is an object-oriented language with multiple inheritance,
nominal type equivalence, and a combination of \emph{dynamic}, \emph{optional} (aka.~\emph{like}), and \emph{concrete} types.  Concrete types (written \C) behave as one would expect: a variable {\x:\C} is
guaranteed to refer to an instance of \C or a subtype thereof.  Occurrences of optionally typed variables, denoted {\x:\dt\C}, are checked statically within their scope but may be bound to dynamic values and their usage is checked dynamically.  Analogously to TypeScript type annotations, optional types provide some of the benefits of static typing without decreasing the expressiveness and flexibility of the language.  Subtyping on optional types is inherited from the subtyping relation on concrete types, that is {\dt\C} \Sub {\dt\D} whenever \C \Sub \D; also, it always hold that \C \Sub  \dt\C. To get a glimpse of Thorn in action, consider a class definition with two methods, one optionally and one concretely typed:

\medskip
\(
 \Class \A {
    \Mdef \m\x{\dt\C} {\dt\C}  \x  ; \ 
    \Mdef \n\x\C\C  \x 
    }
\)
\medskip

\noindent Assume that \D is not a subtype of \C.  The following expressions illustrate the interesting cases of the interaction between the types of the arguments and the declared type of the method parameter, whenever the callee has a concrete type:

\medskip
\( \Call {\New \A{}}\n {\New \D{} } \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \texttt{// ERR -- D !|=> C} \)

\( \Call {\New \A{}}\m {\New \D{}} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \texttt{ // ERR -- D !|=> ?C }\)

\( \Call {\New \A{}} \m { \Call {\New \A {}} \n {\New \C{}} } \ \ \ \ \ \texttt{ // OK }\)

\( \Call {\New \A{}} \n { \Call {\New \A{}} \m {\New \C{}}} \ \ \ \ \ \texttt{ // OK \   -- Cast inserted} \)

\medskip


\begin{figure}
\hrulefill
\begin{mathpar}

\IRule{STHC-SUB}{
  \ThorSub\cdot\K\t\tp
}{
  \ConvertE\K{th}\t\tp
}

\IRule{STHC-TOANY}{
}{
  \ConvertE\K{th}\t\any
}

\IRule{STHC-OPTCONC}{
  \ThorSub\cdot\K\C\D
}{
  \ConvertE\K{th}\CW\D
}

\IRule{STHC-ANYCONC}{
}{
  \ConvertE\K{th}\any\tp
}

\\
\IRule{STH-VAR}{
   \HasType \Env\x\t
 }{
   \EnvTypeW \Env\K\x\t
}

\IRule{STH-GET}{
  \HasType \Env\this\C \\
  \Fdef\f\t \in \App\K\C
}{
  \EnvTypeW \Env\K{\FRead\f}\t
}    

\IRule[width=20em]{STH-SET}{
  \HasType \Env\this\C \\
  \Fdef\f\t \in \App\K\C \\
  \EnvTypeW \Env\K\e\tp \\
  \ConvertE\K{th}\tp\t
}{
  \EnvTypeW \Env\K{\FWrite\f\e}\t
}    

\IRule[width=20em]{STH-CALL}{
  \EnvTypeW \Env\K\e\C ~~\vee~~ \EnvTypeW \Env\K\e\CW \\
  \Mtype \m{\t}\tp\in \classoff{\C}\K  \\
  \EnvTypeW \Env\K\ep\tpp \\
  \ConvertE\K{th}\tpp\t
}{
  \EnvTypeW \Env\K{\Call\e\m\ep}\tp
}    

\IRule[width=20em]{STH-DCALL}{
  \EnvTypeW \Env\K\e\any \\
  \EnvTypeW \Env\K\ep\tpp \\
  \ConvertE\K{th}\tpp\any
}{
  \EnvTypeW \Env\K{\Call\e\m\ep}\any
}    

\IRule{STH-NEW}{
 \EnvTypeW \Env\K{\e_1}{\tp_1} ~~\dots~~ \EnvTypeW \Env\K{\e_n}{\tp_n} \\
 \ConvertE\K{th}{\tp[1]}{\t[1]} ~~\dots~~ \ConvertE\K{th}{\tp[n]}{\t[n]} \\
 \b\fd=\Fdef{\f_1}{\t_1}~\dots~\Fdef{\f_n}{\t_n} \\ 
  \Class \C {\b\fd}{\b\md} \in \K
}{
  \EnvTypeW \Env\K{\New\C{\e_1\dots\e_n}}\C
}
\end{mathpar}
\hrulefill
\caption{Thorn type system}\label{f:thornts}
\end{figure}

\noindent The first call is rejected by the static type system because the concretely typed method \n expects a value of type \C, while a value of type \D has been passed.  Formally, the Thorn type system (reported in~\figref{f:thornts}), rejects this because the \(\D\Mapsto\C\) convertibilty test required by the STH-CALL rule fails.  Similarly, the second call is rejected because \(\D\Mapsto\dt\C\) convertibilty fails as well.
In the third call it is a \C value that is passed where a \dt\C is expected: this is allowed as subtyping implies convertibility.  The last expression invokes \n passing an argument of type \dt\C where a \C is expected; although potentially unsound, this is allowed by Thorn to foster program evolution.  For this convertibility includes a \(\dt\C\Mapsto\C\) rule; at run-time, Thorn protects the call, and recovers soundness, by inserting a dynamic type cast to \C around the argument.

If the receiver object has an optional type, then method invocation is statically checked as in the concrete case above:
 optional types behave as contracts between variables and contexts, and whenever an object has type \dt\C a well-typed context uses it only as a variable pointing to an instance of the class \C.  Since in this case the run-time does not guarantee that the object actually accessed are instances of the class \C, the conformance of the value actually accessed will be checked individually at each method invocation, as if the received had type \any.  
 
 
\begin{figure}[!h]
\hrulefill

\begin{tabular}{@{}l@{~ ~ ~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}ll}
\small
  \hspace{-.5cm}\begin{minipage}{8cm}  
\begin{tabbing}
\TR{\Class \C{\fds 1..}{\mds 1 .. }}\= = \src{ \Class \C{ \fdsp 1..}{\mdsp 1..~ \mdspp 1..}} 
\HS \WHERE~\= \fdsp 1 = \src{\Ftype\f{\kty\t}} .., \HS\HS\HS\HS\HS \=\fds 1 = \Ftype\f\t ..   \\
\> \mdsp 1 = \src{\Mdef\m\x{\kty{\t_1}}{\kty{\t_2}}{\ep}} .., \HS \> \mds 1 = \Mdef\m\x{\t_1}{\t_2}\e ..,\HS\HS\> \ep = \TAG{\e}{\this:\C\,\x:{\t_1}}{\t_2} ..,\\
\> \mdspp 1 = \src{\Mdef\m\x\any\any{\SubCast\any{\KCall\this\m{\SubCast{\t_1}\x}{\t_1}{\t_2}}}}
\HS \IF \kty{\t_1} = \D \OR \kty{\t_2} = \D\\
          \>\hspace{1cm} empty \HS  {\bf otherwise}  ..                  
\end{tabbing}
\begin{tabbing}
\TRG{\x}\Env \hspace{1.4cm}\= = \src \x
\\[1mm]       
\TRG{\FRead\f}\Env \> = \src{\FRead\f} 
\\[1mm]
\TRG{\FWrite\f\e}\Env \> = \src{\FWrite\f\ep} \hspace{.5cm} \=
\WHERE\HS\= \TypeCk{\K, \Env}\e\C, \HS  \Ftype\f\t\In\App\K\C, \HS \ep = \TAG\e\Env{\kty\t}
\\[1mm]
\TRG{\Call{\e_1}\m{\e_2}}\Env \>= \src{\DynCall{\eps 1}{\m}{\eps 2}} 
\HS  \>\WHERE\HS \TypeCk{\K,\Env}{\e_1}\t, \HS \kty\t=\any
 \eps 1= \TRG{\e_1}\Env, \HS \eps 2=\TAG{\e_2}\Env\any
\\[1mm]
\TRG{\Call{\e_1}\m{\e_2}}\Env \>= \src{\KCall{\eps 1}{\m}{\eps 2}{\t_1}{\t_2}} 
\>\WHERE\HS   \TypeCk{\K,\Env}{\e_1}\C, \HS  \eps 1 = \TRG{\e_1}\Env, \HS
 \Mtype\m{\t_1}{\t_2}\In\App\K\C, \HS  \eps 2 = \TAG{\e_2}\Env{\t_1}
\\[1mm]
\TRG{\New\C{\e_1..}}\Env\> = \src{\New\C{\eps 1..}} 
     \>\WHERE\HS    \Ftype{\f_1}{\t_1}\In\C, \HS  \eps 1 = \TAG{\e_1}\Env{\t_1} ..
\\[1mm]
\TAG\e\Env\t\> = \src\ep \> \WHERE\HS  \EM{\K\vdash\kty\tp \Sub \kty\t}, \TypeCk{\K,\Env}\e\tp, \ep = \TRG\e\Env
\\[1mm]
 \TAG\e\Env\t \>= \src{\SubCast{\kty\t}\ep}
\>\WHERE\HS  \EM{\K\vdash\kty\tp \not\Sub \kty\t}, \TypeCk{\K,\Env}\e\tp, \ep = \TRG\e\Env
\end{tabbing}
\end{minipage}
\end{tabular}

\hrulefill
\caption{Thorn translation.  \kty\t = \any if  \t=?\C, \t otherwise. }\label{f:thorntokafka}
\end{figure}



 The translation of Thorn into \kafka is given in~\figref{f:thorntokafka}.  Contrarily to TypeScript, the compilation of method invocation must now perform different operations depending on the type of the receiver object. For this, the translation function \TRG{...}\Env takes in input a typing environment \Env, typechecks the callee, and distinguishes two cases.  If the receiver has a concrete type then method invocation is mapped to static method invocation; if instead it has optional or dynamic type, then method invocation is mapped to dynamically checked method invocation.  To complete the translation of method invocation we must translate the argument.  However it might now be necessary to insert the appropriate dynamic type check (that is, the appropriate structural cast) around the argument of the method to satisfy the type constraints imposed by the called method.  This is realised by the second translation function, \TAG{..}\Env\t.  This function first translates its argument; then it checks if its type is a subtype of the expected type \t, and if not it inserts the appropriate structural type cast.  This subtype test must be performed in the \kafka type system, and not in the source type system, and must respect the mapping from Thorn types to \kafka types.  This one is defined by the \kty\t function: Thorn optional and dynamic types are mapped to the \any type of \kafka, while Thorn concrete types are mapped to the equivalent Thorn concrete types.
 
We can now define the translation of classes: 

  -- we generate a method from kty(t1) to kty(t2), inserting a cast around the return value if needed. 

 --  but imagine the object is referred to as * or ?C...  we must ensure that it can be called via dynamic method invocation...   to ensure that the method is callable also if the object is in a * or ?C context,  an overloaded method is added, with *\(\to\)* signature, and argument and return protected by the relevant casts

(interesting because for the first time we see why we need overloading in kafka)

Finally, each field \f:\t is mapped to the corresponding \f:\kty\t field.
 
 

 
 \FZ{UNTIL HERE}


 

 \FZ{ANYCONC should go to be in synch with Fig.2 of the liketype paper}.

%
%The starting point for translating Thorn is fix a mapping for source to \kafka types.  Since variables with a concrete type \C are guaranteed to always point to an instance of the class \C, we can use statically checked method invocation on those, and we can map concrete types to \kafka classes.  On the other hand,  dynamic and the optional types must be are mapped to the \kafka dynamic type: invocation on methods on objects of these types must be resolved dynamically.  
%
%At runtime, in Thorn design there is a clear dichotomy between dynamic and optional types on the one side, and concrete types on the other.    We can mimick this by defining kty so that it maps \any and and the 
%


%
%how does the translation work:
%
%- types: * and ?C are mapped to * ; C are mapped to C
%
%- we use two functions [[ ]] and (( )):
%
%  -- [[ ]] translates terms (since we need to typecheck we carry an environment of free variables).  The interesting case is when we translate method invocation.  If, by typechecking, the callee has a dynamic or optional type (eg. kty( t ) = *, the we map it to dynamic method invocation.  Otherwise we compile to the static method invocation. 
%
%- The type of the method imposes a type for the methods.  This might / might not require casts to be inserted to satisfy this constraint.   the arguments are more interesting...  we know the type we must translate them to.  so we use a second function (()) to translate them, possibly inserting casts.  this second function translates the argument t with the usual [[]] function, but then checks the ktys types expected and obtained, and if needed inserts a structural cast to preserve the integrity of the method invocation (eg. if that was expecting a C).
%
%- translation of classes (interesting because for the first time we see why we need overloading in kafka): 
%  -- we generate a method from kty(t1) to kty(t2), inserting a cast around the return value if needed. 
%  --  but imagine the object is referred to as * or ?C...  we must ensure that it can be called via dynamic method invocation...   to ensure that the method is callable also if the object is in a * or ?C context,  an overloaded method is added, with *\(\to\)* signature, and argument and return protected by the relevant casts
%  
 

Summarising,
the translation of Thorn to \kafka turns optional types to \any and
inserts structural casts to \C when an expression of type \any, or of type
\dt\C is assigned to a \C.  Class \A would translate to:

\medskip
\(
 \Class \A {
    \Mdef \m\x\any \any  \x  ; \ 
    \Mdef \n\x\C\C  \x 
    }
\)

\medskip


\FZ{DONT FORGET COMMENT ON * SUBTYPING IN SEC 3!!!}

\subsection{Transient Python}

The Transient variant of Reticulated Python~\cite{siek14} aims for soundness
with a predictable cost model. The declared types of arguments are defensively
checked in every method, such as in method \m. Method \m expects an instance of
class \C, but it can be called with a value of type \any at any point, forcing
\m to check its arguments at every invocation.

\begin{lstlisting}
 class A {
    m(x: C): D { x.n(new C()) }
    n(x: *): * { x } }

 new A().m( new A().n( new C() ) ) // OK
 new A().m( new A().n( new D() ) ) // Runtime ERR
\end{lstlisting}

\noindent Transient Python deems both expressions well-typed. However, the
second is going to end up with a type error as a \code D is passed to a method
expecting a \code C.  When translating to \kafka, all types are erased and casts
are inserted on method entry and prior to returning.

...removed broken translation 

\begin{figure}
\hrulefill
\begin{mathpar}

\IRule{STTC-SUB}{
  \ConSub\cdot\K\t\tp
}{
  \ConvertE\K{tr}\t\tp
}

\IRule{STTC-TOANY}{
}{
  \ConvertE\K{tr}\t\any
}

\IRule{STTC-ANYCONC}{
}{
  \ConvertE\K{tr}\any\tp
}

\end{mathpar}
\hrulefill
\caption{Transient convertibility rules}\label{f:transientts}
\end{figure}

The expression typing rules for our Transient Racket source is identical to the 
typing rules, presented in figure \ref{f:typescriptts}, for our TypeScript source.

\noindent The translated class \code A has a check to validate that the
argument to \code m has all the methods defined by \code C.

...removed broken

\begin{figure}[!h]
\begin{tabular}{@{}l@{~ ~ ~}ll}
 \small
\begin{minipage}{8cm}  
\begin{tabbing}
\TR{\Class\C{\fds 1..}{\mds 1.. }} =  \src{\Class \C {\fdsp 1..}{\mdsp 1.. } }\\
\hspace{.5cm}  \WHERE\HS \=
  \fdsp 1 = \src{\Ftype\f\any} .., \HS
  \fds 1 = \Ftype\f\t ..,\HS\HS
  \mdsp 1 = \src{\Mdef\m\x\any\any{\SubCast\t\x ~; ~\eps 1}} .., \HS
  \mds 1 = \Mdef\m\x\t\tp\e ..,\HS\HS
   \eps 1 = \TAG\e{\x:\t\,\this:\C}\tp~ ..
\end{tabbing}
\begin{tabbing}
\TRG\this\Env \hspace{1cm} \= = \src\this
\\[1mm]
\TRG\x\Env \>= \src{\SubCast\t\x} \hspace{1.5cm} \=\WHERE \HS \TypeCk{\K,\Env}\x\t
\\[1mm]
\TRG{\FRead\f}\Env \>= \src{\SubCast\t{\FRead\f}} \>\WHERE\HS  \TypeCk{\K,\Env}\this\C,\HS\HS\=\Ftype\f\t\In\App\K\C
\\[1mm]
\TRG{\FWrite\e}\Env \>=  \src{\SubCast\t{\FWrite\f\ep}}
  \>\WHERE\HS
  \TypeCk\K\this\C,
  \> \Ftype\f\t\In\App\K\C, \hspace{.7cm}
  \= \ep = \TAG\e\Env\any
\\[1mm]
  \TRG{\Call{\e1_1}\m{\e_2}}\Env \>= \src{\DynCall{\eps 1}\m{\eps 2}}
  \>\WHERE \HS 
  \TypeCk{\K,\Env}{\e_1}\any, \HS
  \> \eps 1 = \TRG{\e_1}\Env, 
  \> \eps 2 = \TAG{\e_2}\Env\any
\\[1mm]
\TRG{\Call{\e1_1}\m{\e_2}}\Env \>= \src{\SubCast\tp{\KCall{\eps 1}\m{\eps 2}\t\tp}}
   \>\WHERE\HS
   \TypeCk{\K,\Env}{\e_1}\C,
   \> \Mtype\m\t\tp\In\App\K\C,\HS
   \> \eps 1 = \TRG{\e_1}\Env, \HS\HS
   \eps 2 = \TAG{\e_2}\Env\any
\\[1mm]
\TRG{\New\C{\e_1..}}\Env \>=  \src{\New\C{\eps 1..}} \>\WHERE\HS
\Ftype{\f_1}{\t_1}\In\App\K\C,
  \>\eps 1 = \TAG{\e_1}\Env{\t_1} ~..
\\[1mm]
\TAG\e\Env\t \>= \src{\SubCast\t\e}
    \>\WHERE\HS \TypeCk{\K,\Env}\e\tp, \> (\t = \any \OR \tp = \any),\HS \> \ep = \TRG\e\Env
\\[1mm]
\TAG\e\Env\t \>= \src\ep \>\WHERE\HS  \TypeCk{\K,\Env}\e\tp, \HS\>(\EM{\ConSub{}\K\t\tp}),\HS \> \ep = \TRG\e\Env
\end{tabbing}
\end{minipage}
\end{tabular}
\caption{Transient}\end{figure}

...Say: sequencing


... All type
annotations are erased and replaced by \any.  Every call, typed or untyped,
in Transient becomes untyped.  Every typed method call must be guarded with
a cast to ensure that the return type of the method is correct, as shown in
\RuleRef{TPG2}.  The lack of statically typable calls in the Transient
semantics means that a pure implementation of transient would entail no
fields ever being accessed using the setter or getter methods, as \kafka
forbids accessing fields through dynamic call sites. To overcome this, rule
\RuleRef{TPG4} is added, which allows the definition of self-referential
field access. In a transient system, the only type that is known is the type
of \this.  As a result, accesses to fields have to go through user-defined
field accessor methods.  Rule \RuleRef{TPR2} provides consistency for
Transient. In gradual type systems with consistency, consistency is used to
conclude an analytic judgment, as consistency allows the system to break
type guarantees, adding and removing types from sub-parts of  a
program. 

... Consistency within \kafka is...

...it is used in the transient system to allow typed and untyped code to
interact. When consistency is used, a check is inserted to ensure that all
the methods that are required are declared on the provided type, but the
types of the methods are ignored, as they are the responsibility of the
callee to check.




\subsection{Typed Racket}

Typed Racket~\cite{Takikawa:2012} is an extension of the Racket programming
language, supporting Racket's key functionality, including first
class classes. Our model of Typed Racket is not complete, missing several
features, including:

\begin{itemize}
  \item First-class classes, as they are not easily mapped to \kafka and 
  add substantially to the complexity of the translation.
  \item Protecting against externally ill-typed internal method calls. By
  default, Typed Racket ensures that the receiver of a method call abides
  by the externally asserted type of that receiver. This behavior is needed to 
  ensure soundness in the presence of inheritance, but is not needed for 
  \kafka.
  \item Our model does not enforce so-called ``macro'' gradual typing, as 
  Typed Racket does. In Typed Racket, types must be added one module at a 
  time, whereas in our system, individual methods can be typed inside
  untyped classes.
\end{itemize}

As a result of these changes, our model is very similar to Vitousek, Kent, and
Siek's  guarded Reticulated Python~\cite{siek14}, offering only the bare 
minimum of functionality expected of an object-oriented gradually typed 
language.

The core of any gradual typing system is its enforcement mechanism, ensuring
that values passing a typed/untyped boundary are consistent with their
declared types. Thorn handles this problem through the use of \emph{concrete}
typing, checking that the type tag on the value is statically known to be a subtype
of the required type. In contrast, Typed Racket ensures type correctness of 
untyped code through the insertion of wrapper contracts, protecting typed values
from untyped code and typed code from untyped values.

Our Typed Racket model differs from our Thorn representation most notably
in 

\begin{lstlisting}
 class A {
   m(x: *): * { new B().n(x) } }
 class B {
   n(x: B): C { x.n(x) } }

 new A().m( new A())
\end{lstlisting}

\noindent Class \code B expects \code x to be of type \code B, yet it will
be given an \code A. Typed Racket mediates at boundaries between typed and
untyped code by inserting wrappers around exchanged values. These wrappers
ensure that the values behave according to their \emph{promised} types. The
translation to \kafka is such that typed code remains untouched, untyped
code is extended with \emph{behavioral generative casts} at creation of
instances of typed classes. The body of \code m becomes {\tt ({\BehStart
    \any \BehEnd}new B())@n(x)}.  The instance of \code B is cast to \any,
and the call is dynamically resolved. The cast creates a new wrapper class
that has all of the methods of \code B accepting untyped arguments as well
as typed arguments. The wrapper generated by the cast is (roughly) as
follows:

\begin{lstlisting}
  class BW {
   that : B
   n(x: *): * { (*@\BehStart \any \BehEnd@*) that.n( (*@\BehStart B \BehEnd
     ShaStart B ShaEnd x@*) ) }
   n(x: B): C { that.n(x) } }
\end{lstlisting}

\noindent Class \code{BW}, a fresh name, is a subtype of
\code B (in \kafka, subtyping is defined only over typed methods).  The
wrapper has a field \that which refers to the instance of \code B. When it
is called from a typed context, all it does is forward calls to the
target. In an untyped context, the wrapper will cast the argument to the
promised type and cast results back to \any. Each of these casts introduces
new wrappers. A shallow structural cast is used to catch obvious mismatches
early.   \FZ{FIXME, we do not have shallow casts anymore.}
 The key properties of this translation are that typed code can rely
on the presence of methods of the right type (and thus use static method
resolution) but calls can still fail at casts within the wrapper. An easily
overlooked, but significant, feature of Racket is that the \this variable is
wrapped by any wrapper(s) applied at the call site.

The complete type system for our Typed Racket source is identical to the type
system of our TypeScript source presented in figure \ref{f:typescriptts}.

Our model of Typed Racket does not preserve the ``macro'' model of gradual
typing of the source language, as it does not effect the fundamental
semantics of the typing system.  Typed Racket requires a new cast, a
\emph{generative cast}, which is sufficiently different from what we have
seen so far that we will extend the syntax and semantics of \kafka to
support it.  For an expression \e and type \t, the cast \BehCast\t\e depicts
the behavioural cast, and the typing and semantic rules are next.


\begin{figure}[!h]
\begin{tabular}{@{}l@{~ ~ ~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}ll}
 \small
\begin{minipage}{8cm}  
\begin{tabbing}
\TR{\Class\C{\fds 1..}{\mds 1.. }} =  \src{\Class \C {\fds 1..}{\mdsp 1.. } }\\
\hspace{.7cm} \WHERE\HS 
\mdsp 1 = \src{\Mdef\m\x\t\tp{\eps 1}} ..,\HS\HS
\mds 1 = \Mdef\m\x\t\tp{\e_1} ..,\HS\HS
\eps 1 = \TRG{\e_1}{\x:\t\,\this:\C}
\end{tabbing}
\begin{tabbing}
\TRG\x\Env = \src{\x}
\\[1mm]
\TRG{\FRead\f}\Env  = \src{\FRead\f}
\\[1mm]
\TRG{\FWrite\f\e}\Env =  \src{\FWrite\f\ep} \hspace{.5cm}
\=\WHERE
\= \TypeCk\K{\e_1}\C, \HS\HS
\= \Ftype\f\t\In\App\K\C, \hspace{1cm}
\=  \eps 1 = \TRG{\e_1}\Env,\HS\HS\HS
\= \eps 2 = \TAG\e\Env\t
\\[1mm]
\TRG{\Call{\e1_1}\m{\e_2}}\Env = \src{\DynCall{\eps 1}\m{\eps 2}}
\>\WHERE \> \TypeCk{\K,\Env}{\e_1}\any, \HS
\> \eps 1 = \TRG{\e_1}\Env,\HS
\> \eps 2 = \TAG{\e_2}\Env\any
\\
\TRG{\Call{\e1_1}\m{\e_2}}\Env = \src{\KCall{\eps 1}{\m}{\eps 2}{\D_1}{\D_2}}
\>\WHERE \> \TypeCk{\K,\Env}{\e_1}\C, \HS
\> \Mtype\m{\D_1}{\D_2}\In\App\K\C, \HS
\> \eps 1 = \TRG{\e_1}\Env,\HS
\> \eps 2 = \TAG{\e_2}\Env{\D_1}
\\[1mm]
\TRG{\New\C{\e_1..}}\Env =  \src{\New\C{\eps 1..}}
   \>\WHERE \> \Ftype{\f_1}{\t_1}\In\App\K\C ~..
   \>       \>  \eps 1 = \TAG{\e_1}\Env{\t_1} ~..
\\[1mm]
\TAG\e\Env\t = \src\ep
\> \WHERE\> \TypeCk{\K,\Env}\e\tp, \HS
\> \EM{\K\vdash \t \Sub \tp},
\>  \ep = \TRG\e\Env
\\[1mm]
\TAG\e\Env\t = \src{\BehCast\t\e}
\>\WHERE\> \TypeCk{\K,\Env}\e\tp, \HS
   \> \EM{\K\vdash \t \not \Sub \tp}
   \>     \ep = \TRG\e\Env
\end{tabbing}
\end{minipage}
\end{tabular}
\caption{Typed Racket}\end{figure}




The other major concern when designing a wrapper-based protection system for
objects is that losing methods is a real possibility. If a wrapper zealously
enforces its type, then it will not wrap methods that do not appear on its
type, which can then be lost to later untyped or more-typed code that is
given that wrapper.
Our approach avoids this by inserting ``passthrough'' methods that retain their
original types and behaviors into the output wrappers, as illustrated in
figure~\ref{ctod}, where we make a \C into a \D and then back again. When we
reduce the set of required methods by casting a \C to a \D, we retain the method
\mp by adding it to the output class. Notably, this operation preserves existing
subtyping relationships, as the generated wrappers only appear as values, and
the operation only adds additional methods.


The Typed Racket translation demonstrates some of the key issues inherent in
a wrapper-based system, where wrapper-inserting casts build up very quickly
internally, leading to the potential for a wrapper explosion, as previously
noted by Takikawa et al~\cite{practical-gt}, a point that is further
highlighted by the number of casts inserted into the wrappers.




\begin{figure}[!t]
\small
\begin{tabular}{@{}cc}
  \begin{tabular}{|@{}cc@{\hspace{1mm}}|}\hline
  \begin{minipage}{4.6cm}
    \begin{lstlisting}
class A {
 m(x:A):A {this}}

class I {
 n(x:I):I {this}}

class T {
 s(x:I):T {this}
 t(x:*):* {this.s(x)}}
      \end{lstlisting}    
  \end{minipage}
&
  \begin{minipage}{4.6cm}
    \begin{lstlisting}
class A {
 m(x:A): A {this}}

class I {
 m(x:C):I {this}}

class T {
 s(x:I):T {this}
 t(x:*):* {this.s(x)}}
      \end{lstlisting}    
  \end{minipage}
\\[2mm]
(Litmus test 1) & (Litmus test 2)\\[3mm]
  \begin{minipage}{4.3cm}
    \begin{lstlisting}
class A {
 m(x:*):* {this}}

class I {
 m(x:C):C {x}}

class J {
 m(x:D):D {x}}

class E {f:I g:J}

class T {
 t(x:*):* {
   new E(x,x)}}
      \end{lstlisting}    
  \end{minipage}
&
  \begin{minipage}{4.6cm}
    \begin{lstlisting}
class A {
 f:*
 m(x:A):A {
  this.f(new A(new C()))}}


class I {
 f:D
 m(x:I):I {this}}


class T {
 s(x:I):I {x.m(x)}
 t(x:*):* {this.s(x)}}
      \end{lstlisting}    
  \end{minipage}
\\[2mm]
(Litmus test 3) &  (Litmus test 4)\\\hline
  \end{tabular}
  &
\begin{minipage}{4cm}
\begin{tabular}{|@{}c@{\hspace{1mm}}|}\hline
  \begin{minipage}{4cm}
    \begin{lstlisting}
class C { 
  n(x:C):C {this}}

class D {
  o(x:D):D {this}}
    \end{lstlisting}    
  \end{minipage}
 \\
  (Auxiliary classes)\\\hline
\end{tabular}
\\ \\ \\  
\begin{tabular}{|@{}c@{\hspace{1mm}}|}\hline
  \begin{minipage}{4cm}
    \begin{lstlisting}
new T()@t(new A())
    \end{lstlisting}    
  \end{minipage}
  \\
  (Program 1-3)\\\hline
\end{tabular}
\\ \\ \\  
\begin{tabular}{|@{}c@{\hspace{1mm}}|}\hline
  \begin{minipage}{4cm}
    \begin{lstlisting}
new T()@t(
    new A(new D()))
    \end{lstlisting}    
  \end{minipage}
  \\
  (Program 4)\\\hline
\end{tabular}
\end{minipage}
\end{tabular}


\center

\begin{tabular}{|r|l@{~}l@{~}l@{~}l|}\hline
                     & L1 & L2 & L3 & L4\\\hline\rowcolor{Gray}
Thorn                &    &    &    &   \\
Typed Racket         &    & \V & \V &  \\\rowcolor{Gray}
Monotonic  RetPy     &    & \V &    &   \\
Transient RetPy      &    & \V & \V & \V \\\rowcolor{Gray}
TypeScript           & \V & \V & \V & \V \\\hline
\end{tabular}  
  \caption{Semantic litmus tests.}\label{litmus}
\end{figure}


\subsection{Trace preservation}

One outcome of our work is showing how \emph{all} of the gradual type systems
are observationally distinct.  \figref{litmus} presents four litmus tests that
are sufficient to distinguish the five type systems being studied in this
paper.  Each litmus test is a program composed of a class table and a main
expression. The programs are written in \kafka syntax but equivalent
programs can be expressed in each of the target languages. All programs are
well-typed in each of the respective type systems and give raise to
different runtime errors. Under TypeScript semantics, all programs run to
completion without getting stuck. With Thorn, all litmus programs fail at a structural cast from \code A to \code I.  For the other languages the situation is
as follows:
\begin{itemize}
\item {\bf L1:} Fails because \code A is not a subtype of \code I, the
  failure is at a shallow cast because \code A does not have all the methods of
  \code I.   \FZ{CHECK, we do not have shallow casts, is this still relevant?}
\item{\bf L2:} Succeeds in Monotonic/Transient/Racket because shallow casts
  of \code A to \code I go through. \FZ{CHECK, we do not have shallow casts, is this still relevant?  Cite monotonic here?}
\item{\bf L3:} Fails in Monotonic because the same object is being cast to
  two different types, \code I and \code J.  \FZ{CHECK, cite monotonic or not?}
\item{\bf L4:} Fails in Monotonic because the object refereed to by \code x
  in method \code s is cast to \code I. This updates the effective type of field
  \code f to \code D. However, the assignment in method \code m tries to give it
  an \code A. This fails in Racket because the \this field is wrapped with an
  \code I type, and the assignment to \code f does not respect that type.
\end{itemize}

\section{Implementation} We designed \kafka to have a close correspondence to
the intermediate languages (ILs) used by common VMs, but by necessity the
correspondence is not exact; real ILs are far too complex to be easily
presented or formally reasoned about. To validate this aspect of \kafka's
design, we implemented a compiler from \kafka to C\#, alongside a runtime that
provides the key behavioral cast operation.

The key challenge that we encountered in the development of this compiler
relates to one of our earliest design choices: the use of a structural type
system. As previously mentioned, structural typing is common in gradually
typed languages, but is very uncommon in actual virtual machines, especially
those that already have static typing like the CLR or the JVM. In order to
implement \kafka by translation to C\#, we have to convert \kafka's structural
types to C\# nominal types, maintaining semantic equivalence.

\subsection{Structural to Nominal Translation} Our implementation of the
conversion of \kafka to C\# types is based on a whole program type analysis.
Consider a (structural) class table \K, and assume that $\StrSub{}\K\t\tp$ for
some $\t$ and $\tp$. C\# already handles the case where $\t$ or $\tp$ is
$\any$, via its \xt{dynamic} type, which has the same semantics, but if $\t$
and $\tp$ are classes $\C$ and $\D$, then we have to be more careful.

The approach works by introducing the interface \xt{ID}, which the translated
version of $\C$ implements. \xt{ID} has all of the same methods as $\D$ did,
allowing the same operations to be performed on its instances. We then refer
to $\D$ by \xt{ID} in the generated C\# type signatures and casts, which then
allows our translation of the class $\C$ to be used wherever a $\D$ is
expected, satisfying subtyping. If we apply this to every pair of types $\C$
and $\D$ where the subtyping relation holds, the C\# subtyping relation
mirrors the \kafka one exactly.

We chose C\# for this translation because it provides the natural
correspondence between our $\any$ and its \xt{dynamic}. However, C\# also
created a substantial problem for our implementation, for it does not allow
for covariance or contravariance in interface implementation, whereas \kafka's
subtyping mechanism does allow both. However, C\# does allow for
\emph{explicit implementations}, which we use to implement covariant and
contravariant interface implementation, by explicitly calling out the
interface method to implement and forwarding to the actual implementation.

\subsection{Proof of concept}

The goal of our implementation was to validate the choice of features to
include in \kafka by showing that they are similar to those provided in
modern, high performance VMs, and for most of \kafka's functionality, the
implementation was trivial. However, structural typing proved difficult, both
because of fundamental differences forcing the generation of a very large and
fixed inheritance hierarchy, and because of specific design choices made in
C\#. Even when making a major assumption - the closed-world restriction - our
implementation of structural typing on top of a nominal type system is
relatively non-trivial. While some practical, sound, implementations of
structurally typed languages exist (with Scala being the most notable),
structural typing creates fundamental difficulties in using off-the-shelf VMs.

What our implementation does not do is provide an accurate picture of the
performance of the gradual typing systems in question, rather focusing on
semantic differences. This limitation is due to a wide range of factors,
including having none of the commonly-cited performance optimizations, such as
threesomes~\cite{siek10}, combined with the severe inherent restrictions on
what programs can be reasonably written in \kafka. As a result, any
performance evaluation based on our \kafka implementation would not be
representative of the performance of a real implementation. %\clearpage


\section{Conclusion}

Gradual typing is no longer simply a popular research topic in academia.
Real-world applications are being written with gradual types and the tug of
war between soundness and performance is being played out in multiple
language designs.  It is the responsibility of language researchers to
present a clear understanding of each viable gradual typing idiom available.
We have introduced \kafka, a formal language that serves as the foundation
for deconstructing five existing gradual typing systems: Typescript, Thorn,
Transient Python, and Typed Racket.
%, and Monotonic Python. 
\kafka offers the
opportunity for comparing and contrasting these gradual typing systems
within an unified framework. The translations to \kafka for each gradual
typing system highlights the essences which makes each system unique.


\bibliographystyle{unsrturl}
\bibliography{../../bib/jv,../../bib/all}

\clearpage

\appendix
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Full \kafka Definition}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{appendix:kafka}



% \subsection{Semantics}

% \subsection{Subtyping}
% 
% The structural subtype relation, written \StrSub\M\K\t\tp, asserts that \t
% is a subtype of \tp in the environment \M composing a set of subtype relations and
% a class table \K.   The set of subtype relations can be omitted if its empty.
% 
% ~\\
% 
% \opdef{\StrSub\M\K\t\tp}{\t is a subtype of \tp}
% \begin{mathpar}
% \IRule{SRef}{
% }{
%  \StrSub\M\K \t \t
% }
% 
% \IRule{SAss}{
% \C \Sub \D \in \M
% }{
%  \StrSub \M\K \C\D
% }
% 
% \IRule{SRec}{
%  \M' = \M~\C\Sub\D\\
% \mt \in \classoff\D\K \implies \mtp \in \classoff\C\K ~.~ \StrSub{\M'}\K\mt{\mtp}
% }{
%  \StrSub \M\K \C \D 
% }
% \end{mathpar}
% 
% \opdef{\StrSub\M\K\mt\mtp}{\mt is a subtype of \mtp}
% \begin{mathpar}
% \IRule{SMet}{
%   \StrSub \M\K {\t[2]} {\t[1]} \\
%   \StrSub \M\K {\tp[1]} {\tp[2]}
% }{
%  \StrSub \M\K {\Mtype\m{\t[1]}{\tp[1]}} {\Mtype\m{\t[2]}{\tp[2]}}
% }
% \end{mathpar}

\subsection{Well-formedness}

The well-formedness judgments for \kafka are defined for programs, classes, methods, fields, and types.

~\\

\opdef{~\WFq{\K~\e~\s}}{Well-formed program}
\vspace{-3mm}
\begin{mathpar}
\IRule{WP}{
  \k \in \K \implies \WF{}\cdot\K\k \\
  \EnvType\Env\s\K\e\t \\
  \WFtype\K\s
}{
  \WFq{\K~\e~\s}
}
\end{mathpar}

\opdef{\WF{}\s\K {\Class\C{\b\fd}{\b\md}}}{Well-formed class}
\vspace{-2.5mm}
\begin{mathpar}
\IRule{WC}{
 \cload{\mds{1..}~\fds{1..}} \\
 \WF {}{}\K {\fds 1..} \\
 \WF {\text{this}:\C~}\s\K {\mds 1..} 
}{
 \WF {}\s\K {\Class \C {\fds 1..}{\mds 1..}}
}
\end{mathpar}

The \xt{nodups} function states that there are no overloaded 
field or method names within the given field and method definitions. \\

\opdef{~\WF \Env\s\K \md}{Well-formed methods}
\vspace{-3mm}
\begin{mathpar}
\IRule[width=18em]{WT1}{
 \Envp = \Env{~\Ftype\x\any} \\
 \EnvType \Envp\s\K\e\any\\
 \WFtype\K\any \\
}{
 \WF \Env\s\K {\Mdef\m\x\any\any\e}
}

% \IRule[width=18em]{WT2}{
\IRule{WT2}{
 \Envp = \Env{~\Ftype\x\C}\\ 
 \EnvType \Envp\s\K\e\Cp\\
 \WFtype\K\C \\
 \WFtype\K\Cp \\
}{
 \WF \Env\s\K {\Mdef\m\x\C\Cp\e}
}
\end{mathpar}

\opdef{~\WFtype \K {\fd}}{Well-formed fields}
\vspace{-3mm}
\begin{mathpar}
\IRule{WF}{
 \WFtype\K\t 
}{
 \WFtype\K{\Fdef\f\t}
}
\end{mathpar}
 
\opdef{~\WFtype\K\t}{Well-formed types}
\vspace{-3mm}
\begin{mathpar}
\IRule{WA}{
}{
 \WFtype\K\any
}

\IRule{WC}{
 \C \in \K
}{
 \WFtype\K\C
}
\end{mathpar}

\opdef{~\WFtype\K\s}{Well-formed heaps}
\begin{mathpar}
\IRule{WH}{
\Bind\ap{\obj\C{\a_1 \ldots}}~\in~\s \implies \Class\C{\fds 1..}{\mds 1..}\in\K ~~~\wedge~~~  
\EnvType\cdot\s\K{\a_1}{\t_1} ~\ldots
}{
 \WFtype\K\s
}
\end{mathpar}

\subsection{Expression typing}

The expression typing judgments for \kafka includes in ascending order as listed in the formalism:
variable, untyped address, subsumption, field assignment, field read, static method invocation, dynamic method invocation, object creation,
subtype cast, typed address.

~\\

\opdef{\EnvType\Env\s\K\e\t}{\e has type \t in environment \Env against heap \s and class table \K}
\vspace{-6mm}
\begin{mathpar}
\IRule{KT-VAR}{
   \HasType \Env\x\t
 }{
   \EnvType \Env\s\K\x\t
}

\IRule{KT-SUB}{ 
  \EnvType \Env\s\K\e\tp \\
 \StrSub \cdot\K \tp \t
 }{
  \EnvType \Env\s\K\e\t 
}   

\IRule[width=12em]{KT-READ}{
  \HasType\Env\this\C\\
  \Fdef\f\t \in \App\K\C
}{
  \EnvType \Env\s\K{\FRead\f}\t
}  

\IRule[width=12em]{KT-REFREAD}{
  \EnvType \Env\s\K\a\C \\
  \Fdef\f\t \in \App\K\C \\
  \EnvType \Env\s\K\e\t
}{
  \EnvType \Env\s\K{\FReadR\a\f}\t
}  

\IRule[width=12em]{KT-WRITE}{
  \HasType\Env\this\C\\
  \Fdef\f\t \in \App\K\C \\
  \EnvType \Env\s\K\e\t
}{
  \EnvType \Env\s\K{\FWrite\f\e}\t
}    

\IRule[width=12em]{KT-REFWRITE}{
  \EnvType \Env\s\K\a\C \\
  \Fdef\f\t \in \App\K\C \\
  \EnvType \Env\s\K\e\t
}{
  \EnvType \Env\s\K{\FWriteR\a\f\e}\t
}  

\IRule[width=16em]{KT-CALL}{
  \EnvType \Env\s\K\e\C \\
  \Mtype\m\t\tp \in \classoff\C\K \\
  \EnvType \Env\s\K\ep\t
}{
  \EnvType \Env\s\K{\KCall\e\m\ep\t\tp}\tp
}    

\IRule{KT-DYNCALL}{
  \EnvType \Env\s\K\e\any \\
  \EnvType \Env\s\K\ep\any
}{
  \EnvType \Env\s\K{\DynCall\e\m\ep}\any
}    

\IRule[width=20em]{KT-NEW}{
 \EnvType \Env\s\K{\e_1}{\t_1}\dots 
 \EnvType \Env\s\K{\e_n}{\t_n}\ \\ 
 \b\fd=\Fdef{\f_1}{\t_1}\dots\Fdef{\f_n}{\t_n} \\ 
  \Class \C {\b\fd}{\b\md} \in \K
}{
  \EnvType\Env\s\K{\New\C{\e_1\dots\e_n}}\C
}

\IRule{KT-SUBCAST}{
  \EnvType \Env\s\K\e\tp
}{
  \EnvType \Env\s\K{\SubCast\t\e}\t
}

\IRule{KT-BEHCAST}{
  \EnvType \Env\s\K\e\tp
}{
  \EnvType \Env\s\K{\BehCast\t\e}\t
}

\IRule{KT-REFTYPE}{
  \s(\a) = \obj\C{\b\ap}
}{
  \EnvType \Env\s\K\a\C
}

\IRule{KT-REFANY}{
 }{
   \EnvType \Env\s\K\a\any
}
\end{mathpar}

\subsection{Mtype function}

The \texttt{mtypes} function takes a class name $\C$ and the class table
$\K$, and outputs a list of typing signatures $\b\mt$ for every method in
class $\C$. \\


\begin{equation*}
\classoff\C\K = \b\mt ~~\mathit{if}~~ \begin{cases}

 \Class \C {\b{\Ftype\f\t}}{\b\md} \in \K\\
 \b\mt = \sign{\b\md} 
%  \oplus \forall ~\Ftype\f\t \in \b{\Ftype\f\t} ~|~ \f \notin \names{\b\md} ~\wedge~ \f\neq\that ~.~ \typez{\Ftype\f\t}

\end{cases}
\end{equation*}

\subsection{getmds function}

The function $\getmds\C\K$ denotes the function that returns the method definitions inside the class \C.

\begin{equation*}
\getmds\C\K = \b\md ~~\mathit{if}~~ \Class\C{\b{\fd}}{\b\md} \in \K
\end{equation*}

\subsection{Dynamic function}

The \xt{dyn} function returns all the methods with $\star$ type for a particular set of 
signatures of method typing.

\begin{mathpar}
\IRule{DYNE}{
}{
  \dyn{\cdot} = \cdot
}

\IRule{DYN}{
 \dyn{\b\mt} = \b{\mtp} \\
}{
  \dyn{\Mtype{\m}{\t}{\t} ~\,\b\mt} = \Mtype{\m}{\any}{\any}~\,\b\mtp
}
\end{mathpar}

\subsection{Signature function}

The \xt{signature} function returns method typing signatures ($\mt$) of method definitions ($\md$).

\begin{mathpar}
\IRule{SGE}{
}{
  \sign{\cdot} = \cdot
}

\IRule{SG}{
  \md = \Mdef\m\x\t\t\e \\
  \sign{\b\md} = \b\mt \\
}{
  \sign{\md\,\b\md} = \Mtype\m\t\t~~\b\mt
}
\end{mathpar}

\subsection{Names function}

The \xt{names} function (\names{\b\fd}, \names{\b\md}, \names{\b\mt}) takes either field definitions, method definitions, or 
method typings, and returns the name of the respective fields or methods.

\subsection{Duplicated method names}

The \xt{nodups} function (\cload{\b\mt}, \cload{\b\md}) takes either method definitions or method typings, and ensures there
are no duplicates.

\section{Source language syntax and semantics}

% \subsection{Syntax}
% 
% \begin{figure}[!h]\hrulefill
% 
% \hspace{0.1cm}
% \begin{minipage}{5.9cm}\begin{tabular}{@{}l@{~}l@{}l@{}l@{}ll}
% \e &::=  \x          &\B \this          \\
%    &\B \New\C{\b\e}  &\B \FRead\f       \\
%    &\B \FWrite\f\e   &\B \Call\e\m\e \\ 
% \end{tabular}\end{minipage}
% \begin{minipage}{5.9cm}\begin{tabular}{l@{~}l@{}l@{}l}
%    ~ \k &::= \Class \C {\b\fd}{\b\md}
% \end{tabular}
% \begin{tabular}{l@{~}l@{}l@{}l}
% \md &::= \Mdef\m\x\t\t\e \\
% %\mt &::= \Mtype\m\t\t &\B~  \Mtype\f\t\t  &\B \Mtype\f{}\t  \\ 
% ~ \t&::= ~ \any   \B   \C   \B   \CW \\ 
% ~\fd&::= ~ \Fdef\f\t \\ 
% \end{tabular}\end{minipage}
% 
% \hrulefill
% \caption{Source language syntax.}\label{sou-syn}
% \end{figure}

\subsection{Thorn subtyping}

% \dt\C~\src\Sub~\dt\D and \C~\src\Sub~\dt\D both hold if \C~\src\Sub~\D

\begin{mathpar}
\IRule{TSWeak}{
  \ThorSub \M\K\C\D
}{
  \ThorSub \M\K{\dt\C}{\dt\D}
}

\IRule{TSLow}{
  \ThorSub \M\K\C\D
}{
  \ThorSub \M\K{\C}{\dt\D}
}
\end{mathpar}

\begin{mathpar}
\IRule{TSRef}{
}{
 \ThorSub\M\K \t \t
}

\IRule{TSAss}{
\C \Sub_t \D \in \M
}{
 \ThorSub\M\K \C \D
}

\IRule{TSRec}{
 \M' = \M~\C\Sub_t\D\\
\mt \in \classoff\D\K \implies \mtp \in \classoff\C\K ~.~ \ThorSub{\M'}\K\mt{\mtp}
}{
 \ThorSub\M\K \C \D 
}
\end{mathpar}

\begin{mathpar}
\IRule{TSMet}{
  \ThorSub \M\K {\t[1]} {\t[2]} \\
  \ThorSub \M\K {\tp[2]} {\tp[1]}
}{
 \ThorSub \M\K {\Mtype\m{\t[1]}{\tp[1]}} {\Mtype\m{\t[2]}{\tp[2]}}
}
\end{mathpar}



\subsection{Thorn well-formedness}

\opdef{~\WFpW{\e}{\K}}{Well-formed programs}
\opdef{\WFW{}\s\K {\Class\C{\b\fd}{\b\md}}}{Well-formed classes}
\opdef{~\WFW \Env\s\K \md}{Well-formed methods}
\opdef{~\WFtypeW \K {\Fdef\f\t}}{Well-formed fields}
\opdef{~\WFtypeW\K\t}{Well-formed types}

\begin{mathpar}
\IRule{WP}{
  \k \in \K \implies \WFW{}\K\k \\
  \EnvTypeW\Env\K\e\t
}{
  \WFpW\e\K
}

\IRule[width=25em]{WCL}{
 \xt{overloading}_{\emptyset}(\b\fd,\b\md) \\
 \fd\in\b\fd\implies \WFW {}\K \fd \\
 \md\in\b\md\implies \WFW {\text{this}:\C~}\K \md 
}{
 \WFW {}\K {\Class \C {\b\fd}{\b\md}}
}

\IRule[width=18em]{WT}{
 \EnvTypeW {\Env{~\Ftype\x\C}~}\K\e\D\\
 \WFtypeW\K\C \\
 \WFtypeW\K\D \\
}{
 \WFW \Env\K {\Mdef\m\x\C\D\e}
}

\IRule[width=18em]{WWT}{
 \EnvTypeW {\Env{~\Ftype\x\t}~}\K\e\tp\\
 \WFtypeW\K\t \\
 \WFtypeW\K\tp \\
 \kty\t = \kty\tp = \any
}{
 \WFW \Env\K {\Mdef\m\x\t\tp\e}
}

\IRule{WF}{
 \WFtypeW\K\t 
}{
 \WFtypeW\K{\Fdef\f\t}
}

\\

\IRule{WA}{
}{
 \WFtypeW\K\any
}

\IRule{WC}{
 \C \in \K
}{
 \WFtypeW\K\C
}

\IRule{WW}{
 \C \in \K
}{
 \WFtypeW\K{\CW}
}
\end{mathpar}

\subsection{Thorn expression typing}


\opdef{\ConvertE\K{th}\t\tp}{type convertibility between \t and \tp.}
\begin{mathpar}

\IRule{STHC-SUB}{
  \ThorSub\cdot\K\t\tp
}{
  \ConvertE\K{th}\t\tp
}

\IRule{STHC-TOANY}{
}{
  \ConvertE\K{th}\t\any
}

\IRule{STHC-OPTCONC}{
  \ThorSub\cdot\K\C\D
}{
  \ConvertE\K{th}\CW\D
}

\IRule{STHC-ANYCONC}{
}{
  \ConvertE\K{th}\any\tp
}

\end{mathpar} \\

\opdef{\EnvType\Env\s\K\e\t}{\e has type \t in environment \Env against heap \s and class table \K}
\begin{mathpar}
\IRule{STH-VAR}{
   \HasType \Env\x\t
 }{
   \EnvTypeW \Env\K\x\t
}

\IRule{STH-GET}{
  \HasType \Env\this\C \\
  \Fdef\f\t \in \App\K\C
}{
  \EnvTypeW \Env\K{\FRead\f}\t
}    

\IRule[width=20em]{STH-SET}{
  \HasType \Env\this\C \\
  \Fdef\f\t \in \App\K\C \\
  \EnvTypeW \Env\K\e\tp \\
  \ConvertE\K{th}\tp\t
}{
  \EnvTypeW \Env\K{\FWrite\f\e}\t
}    

\IRule[width=20em]{STH-CALL}{
  \EnvTypeW \Env\K\e\C ~~\vee~~ \EnvTypeW \Env\K\e\CW \\
  \Mtype \m{\t}\tp\in \classoff{\C}\K  \\
  \EnvTypeW \Env\K\ep\tpp \\
  \ConvertE\K{th}\tpp\t
}{
  \EnvTypeW \Env\K{\Call\e\m\ep}\tp
}    

\IRule[width=20em]{STH-DCALL}{
  \EnvTypeW \Env\K\e\any \\
  \EnvTypeW \Env\K\ep\tpp \\
  \ConvertE\K{th}\tpp\any
}{
  \EnvTypeW \Env\K{\Call\e\m\ep}\any
}    

\IRule{STH-NEW}{
 \EnvTypeW \Env\K{\e_1}{\tp_1} ~~\dots~~ \EnvTypeW \Env\K{\e_n}{\tp_n} \\
 \ConvertE\K{th}{\tp[1]}{\t[1]} ~~\dots~~ \ConvertE\K{th}{\tp[n]}{\t[n]} \\
 \b\fd=\Fdef{\f_1}{\t_1}~\dots~\Fdef{\f_n}{\t_n} \\ 
  \Class \C {\b\fd}{\b\md} \in \K
}{
  \EnvTypeW \Env\K{\New\C{\e_1\dots\e_n}}\C
}
\end{mathpar}

\subsection{Non-thorn well-formedness}

We use $x$ as a placeholder to mean either $s$ (for the basic source typing, used by Typed Racket and Typescript) or $tr$ (transient, used by the transient semantics).

\opdef{~$\WFpx{\e}{\K}$}{Well-formed programs}
\opdef{\WFx{}\s\K {\Class\C{\b\fd}{\b\md}}}{Well-formed classes}
\opdef{~\WFx \Env\s\K \md}{Well-formed methods}
\opdef{~\WFtypex \K {\Fdef\f\t}}{Well-formed fields}
\opdef{~\WFtypex\K\t}{Well-formed types}

\begin{mathpar}
\IRule{SWF-PROG}{
  \k \in \K \implies \WFx{}\cdot\K\k \\
  \EnvTypex\Env\cdot\K\e\t
}{
  \WFpx\e\K
}

\IRule[width=25em]{SWF-CLASS}{
 \xt{overloading}_{\emptyset}(\b\fd,\b\md) \\
 \fd\in\b\fd\implies \WFx {}{}\K \fd \\
 \md\in\b\md\implies \WFx {\text{this}:\C~}{}\K \md 
}{
 \WFx {}{}\K {\Class \C {\b\fd}{\b\md}}
}

\IRule[width=18em]{SWF-TYMETH}{
 \EnvTypex {\Env{~\Ftype\x\C}~}\K\e\D\\
 \WFtypex\K\C \\
 \WFtypex\K\D \\
}{
 \WFx \Env\K {\Mdef\m\x\C\D\e}
}

\IRule[width=18em]{SWF-DYMETH}{
 \EnvTypex {\Env{~\Ftype\x\any}~}\K\e\any\\
 \WFtypex\K\any \\
 \WFtypex\K\any
}{
 \WFx \Env\K {\Mdef\m\x\any\any\e}
}

\IRule{SWF-FIELD}{
 \WFtypex\K\t 
}{
 \WFtypex\K{\Fdef\f\t}
}

\\

\IRule{SWT-ANY}{
}{
 \WFtypex\K\any
}

\IRule{SWT-TYPE}{
 \C \in \K
}{
 \WFtypex\K\C
} 
\end{mathpar}

\clearpage 

\subsection{Typescript and Typed Racket expression typing}

\opdef{\ConvertE\K{s}\t\tp}{type convertibility between \t and \tp.}
\begin{mathpar}

\IRule{STGC-SUB}{
  \StrSub\cdot\K\t\tp
}{
  \ConvertE\K{s}\t\tp
}

\IRule{STGC-TOANY}{
}{
  \ConvertE\K{s}\t\any
}

\IRule{STGC-ANYCONC}{
}{
  \ConvertE\K{s}\any\tp
}

\end{mathpar} \\


\opdef{\EnvTypeS\Env\K\e\t}{\e has type \t in environment \Env against heap  and class table \K}
\begin{mathpar}
\IRule{STG-VAR}{
   \HasType \Env\x\t
 }{
   \EnvTypeS \Env\K\x\t
} 

\IRule{STG-GET}{
   \HasType \Env\this\C \\
  \Fdef\f\t \in \App\K\C
}{
  \EnvTypeS \Env\K{\FRead\f}\t
}    

\IRule[width=20em]{STG-SET}{
  \HasType \Env\this\C \\
  \Fdef\f\t \in \App\K\C \\
  \EnvTypeS \Env\K\e\tp \\
  \ConvertE\K{s}\tp\t
}{
  \EnvTypeS \Env\K{\FWrite\f\e}\t
}    

\IRule[width=20em]{STG-CALL}{
  \EnvTypeS \Env\K\e\C \\
  \Mtype \m\t\tp\in \classoff\C\K  \\
  \EnvTypeS \Env\K\ep\tpp \\
  \ConvertE\K{s}\tpp\t
}{
  \EnvTypeS \Env\K{\Call\e\m\ep}\tp
}    

\IRule[width=20em]{STG-DCALL}{
  \EnvTypeS \Env\K\e\any \\
  \EnvTypeS \Env\K\ep\tpp \\
  \ConvertE\K{s}\tpp\any
}{
  \EnvTypeS \Env\K{\Call\e\m\ep}\any
}    

\IRule{STG-NEW}{
 \EnvTypeS \Env\K{\e_1}{\tp[1]}~~\dots~~ 
 \EnvTypeS \Env\K{\e_n}{\tp[n]}\ \\  
 \ConvertE\K{s}{\tp[1]}{\t[1]} ~~\dots~~ \ConvertE\K{s}{\tp[n]}{\t[n]} \\
 \b\fd=\Fdef{\f_1}{\t_1}~\dots~\Fdef{\f_n}{\t_n} \\ 
  \Class \C {\b\fd}{\b\md} \in \K
}{
  \EnvTypeS \Env\K{\New\C{\e_1\dots\e_n}}\C
}
\end{mathpar}

\subsection{Transient expression typing}

\opdef{\ConSub\M\K\t\tp}{\t is a consistent subtype of \tp}
\begin{mathpar}
\IRule{CSCons}{
  \t = \any ~\vee~ \tp = \any ~\vee~ \t = \tp
}{
 \ConSub\M\K \t \tp
}

\IRule{CSAss}{
\C \Sub \D \in \M
}{
 \ConSub \M\K \C\D
}

\IRule{CSRec}{
 \M' = \M~\C\Sub\D\\
\mt \in \classoff\D\K \implies \mtp \in \classoff\C\K ~.~ \ConSub{\M'}\K\mt{\mtp}
}{
 \ConSub \M\K \C \D 
}
\end{mathpar}

\opdef{\ConSub\M\K\mt\mtp}{$\mt$ is a consistent subtype of $\mtp$}
\begin{mathpar}
\IRule{CSMet}{
  \ConSub \M\K {\t[2]} {\t[1]} \\
  \ConSub \M\K {\tp[1]} {\tp[2]}
}{
 \ConSub \M\K {\Mtype\m{\t[1]}{\tp[1]}} {\Mtype\m{\t[2]}{\tp[2]}}
}
\end{mathpar}

\opdef{\ConvertE\K{tr}\t\tp}{type convertibility between \t and \tp.}
\begin{mathpar}

\IRule{STTC-SUB}{
  \ConSub\cdot\K\t\tp
}{
  \ConvertE\K{tr}\t\tp
}

\IRule{STTC-TOANY}{
}{
  \ConvertE\K{tr}\t\any
}

\IRule{STTC-ANYCONC}{
}{
  \ConvertE\K{tr}\any\tp
}

\end{mathpar} \\

\opdef{\EnvTypeT\Env\K\e\t}{\e has type \t in environment \Env against heap  and class table \K}
\begin{mathpar}

\IRule{STT-VAR}{
   \HasType \Env\x\t
 }{
   \EnvTypeT \Env\K\x\t
}

\IRule{STT-GET}{
   \HasType \Env\this\C \\
  \Fdef\f\t \in \App\K\C
}{
  \EnvTypeT \Env\K{\FRead\f}\t
}    

\IRule[width=20em]{STT-SET}{
  \HasType \Env\this\C \\
  \Fdef\f\t \in \App\K\C \\
  \EnvTypeT \Env\K\e\tp \\
  \ConvertE\K{tr}\tp\t
}{
  \EnvTypeT \Env\K{\FWrite\f\e}\t
}    

\IRule[width=20em]{STT-CALL}{
  \EnvTypeT \Env\K\e\C \\
  \Mtype \m\t\tp\in \classoff\C\K  \\
  \EnvTypeT \Env\K\ep\tpp \\
  \ConvertE\K{tr}\tpp\any
}{
  \EnvTypeT \Env\K{\Call\e\m\ep}\tp
}    

\IRule[width=20em]{STT-DCALL}{
  \EnvTypeT \Env\K\e\any \\
  \EnvTypeT \Env\K\ep\tpp \\
  \ConvertE\K{tr}\tpp\any
}{
  \EnvTypeT \Env\K{\Call\e\m\ep}\any
}    

\IRule{STT-NEW}{
 \EnvTypeT \Env\K{\e_1}{\tp[1]}~~\dots~~ 
 \EnvTypeT \Env\K{\e_n}{\tp[n]}\ \\ 
 \ConvertE\K{tr}{\tp[1]}{\t[1]} ~~\dots~~ \ConvertE\K{tr}{\tp[n]}{\t[n]} \\ 
 \b\fd=\Fdef{\f_1}{\t_1}~\dots~\Fdef{\f_n}{\t_n} \\ 
  \Class \C {\b\fd}{\b\md} \in \K
}{
  \EnvTypeT \Env\K{\New\C{\e_1\dots\e_n}}\C
}
\end{mathpar}

\section{Translations}
\renewcommand{\trulename}[1]{#1}
\subsection{Thorn}

\begin{tabular}{@{}l@{~ ~ ~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}ll}
\small
  \hspace{-.5cm}\begin{minipage}{8cm}  
\begin{tabbing}
\TR{\Class \C{\fds 1..}{\mds 1 .. }}\= = \src{ \Class \C{ \fdsp 1..}{\mdsp 1..~ \mdspp 1..}} 
\HS \WHERE~\= \fdsp 1 = \src{\Ftype\f{\kty\t}} .., \HS\HS\HS\HS\HS \=\fds 1 = \Ftype\f\t ..   \\
\> \mdsp 1 = \src{\Mdef\m\x{\kty{\t_1}}{\kty{\t_2}}{\ep}} .., \HS \> \mds 1 = \Mdef\m\x{\t_1}{\t_2}\e ..,\HS\HS\> \ep = \TAG{\e}{\this:\C\,\x:{\t_1}}{\t_2} ..,\\
\> \mdspp 1 = \src{\Mdef\m\x\any\any{\SubCast\any{\KCall\this\m{\SubCast{\t_1}\x}{\t_1}{\t_2}}}}
\HS \IF \kty{\t_1} = \D \OR \kty{\t_2} = \D\\
          \>\hspace{1cm} empty \HS  {\bf otherwise}  ..   \\
\TR{\k .. \e} \>= \TR{\k} .. \TRG{\e}\cdot \\
\TR{\x:\t~\Env} \>= \x : \kty{\t} ~ \TR\Env
\end{tabbing}
\begin{tabbing}
\trulename{TTH1} \TRG{\x}\Env \hspace{1.4cm}\= = \src \x
\\[1mm]       
\trulename{TTH2} \TRG{\FRead\f}\Env \> = \src{\FRead\f} 
\\[1mm]
\trulename{TTH3} \TRG{\FWrite\f\e}\Env \> = \src{\FWrite\f\ep} \hspace{.5cm} \=
\WHERE\HS\= \TypeCk{\K, \Env}\this\C, \HS  \Ftype\f\t\In\App\K\C, \HS \ep = \TAG\e\Env{\kty\t}
\\[1mm]
\trulename{TTH4} \TRG{\Call{\e_1}\m{\e_2}}\Env \>= \src{\DynCall{\eps 1}{\m}{\eps 2}} 
\HS  \>\WHERE\HS \TypeCk{\K,\Env}{\e_1}\t, \HS \kty\t=\any, \HS
 \eps 1= \TRG{\e_1}\Env, \HS \eps 2=\TAG{\e_2}\Env\any
\\[1mm]
\trulename{TTH5} \TRG{\Call{\e_1}\m{\e_2}}\Env \>= \src{\KCall{\eps 1}{\m}{\eps 2}{\t[2]}{\tp[2]}} 
\>\WHERE\HS   \TypeCk{\K,\Env}{\e_1}\C, \HS  \eps 1 = \TRG{\e_1}\Env, \HS
 \Mtype\m{\t[1]}{\tp[1]}\In\App\K\C, \HS  \eps 2 = \TAG{\e_2}\Env{\t[2]}, \\
 \> \> \> \t[2] = \kty{\t[1]}, \HS \tp[2] = \kty{\tp[1]}
\\[1mm]
\trulename{TTH6} \TRG{\New\C{\e_1..}}\Env\> = \src{\New\C{\eps 1..}} 
     \>\WHERE\HS    \Ftype{\f_1}{\t_1}\In\C, \HS  \eps 1 = \TAG{\e_1}\Env{\t_1} ..
\\[1mm]
\trulename{TTH7} \TAG\e\Env\t\> = \src\ep \> \WHERE\HS  \EM{\K\vdash\kty\tp \Sub \kty\t}, \TypeCk{\K,\Env}\e\tp, \ep = \TRG\e\Env
\\[1mm]
\trulename{TTH8} \TAG\e\Env\t \>= \src{\SubCast{\kty\t}\ep}
\>\WHERE\HS  \EM{\K\vdash\kty\tp \not\Sub \kty\t}, \TypeCk{\K,\Env}\e\tp, \ep = \TRG\e\Env
\end{tabbing}
\end{minipage}
\end{tabular}
\clearpage

\subsection{TypeScript}

\begin{figure}[!h]
\begin{tabular}{@{}l@{~ ~ ~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}ll}
\small
 \begin{minipage}{8cm}  
\begin{tabbing}
\TR{\Class \C{\fds 1..}{\mds 1 .. } } = \src{ \Class \C{ \fdsp 1..}{\mdsp 1..}}\HS \WHERE\HS
  \=\fds 1 = \Ftype\f\t ..,\HS\HS\=\fdsp 1 = \src{\Ftype\f\any} .., \HS\HS\=\mds 1 = \Mdef\m\x{\t_1}{\t_2}\e \\
  \>\mdsp 1 = \src{\Mdef\m\x\any\any\ep},\HS\HS \>\>\ep = \TR{\e}
\end{tabbing}
\begin{tabbing}
\trulename{TTS1} \TR{\FRead\f}\HS\HS\HS\HS\= = \src{\FRead\f}
\\[1mm]
\trulename{TTS2} \TR{\FWrite\f\e} \> = \src{\FWrite\f\ep} \HS\HS\HS\HS\HS\=\WHERE~\ep=\TR\e
\\[1mm]
\trulename{TTS3} \TR\this           \>= \src{\SubCast\any\this}
\\[1mm]
\trulename{TTS4} \TR\x \> = \src \x
\\[1mm]       
\trulename{TTS5} \TR{\Call{\e_1}\m{\e_2}} \> = \src{\DynCall{\eps 1}{\m}{\eps 2}} \HS\>\WHERE\HS\eps 1 = \TR{ \e_1}, \HS \eps 2 = \TR{\e_2}
\\[1mm]
\trulename{TTS6} \TR{\New\C{\e_1..}} \> = \src{\SubCast\any{\New\C{\eps 1..}}} \HS \>\WHERE \HS   \eps 1 = \TR{\e_1} ..
\end{tabbing}
\end{minipage}
\end{tabular}
\caption{TypeScript}
\end{figure}



\subsection{Typed Racket}

\begin{figure}[!h]
\begin{tabular}{@{}l@{~ ~ ~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}ll}
 \small
\begin{minipage}{8cm}  
\begin{tabbing}
\TR{\Class\C{\fds 1..}{\mds 1.. }} =  \src{\Class \C {\fds 1..}{\mdsp 1.. } }\\
\hspace{.7cm} \WHERE\HS 
\mdsp 1 = \src{\Mdef\m\x\t\tp{\eps 1}} ..,\HS\HS
\mds 1 = \Mdef\m\x\t\tp{\e_1} ..,\HS\HS
\eps 1 = \TRG{\e_1}{\x:\t\,\this:\C}
\end{tabbing}
\begin{tabbing}
\trulename{TTK1} \TRG\x\Env = \src{\x}
\\[1mm]
\trulename{TTK2} \TRG{\FRead\f}\Env  = \src{\FRead\f}
\\[1mm]
\trulename{TTK3} \TRG{\FWrite\f\e}\Env =  \src{\FWrite\f\ep} \hspace{.5cm}
\=\WHERE
\= \TypeCk\K{\this}\C, \HS\HS
\= \Ftype\f\t\In\App\K\C, \hspace{1cm}
\= \ep = \TAG\e\Env\t
\\[1mm]
\trulename{TTK4} \TRG{\Call{\e1_1}\m{\e_2}}\Env = \src{\DynCall{\eps 1}\m{\eps 2}}
\>\WHERE \> \TypeCk{\K,\Env}{\e_1}\any, \HS
\> \eps 1 = \TRG{\e_1}\Env,\HS \hspace{1cm}
\= \eps 2 = \TAG{\e_2}\Env\any
\\
\trulename{TTK5} \TRG{\Call{\e1_1}\m{\e_2}}\Env = \src{\KCall{\eps 1}{\m}{\eps 2}{\D_1}{\D_2}}
\>\WHERE \> \TypeCk{\K,\Env}{\e_1}\C, \HS
\> \Mtype\m{\D_1}{\D_2}\In\App\K\C, \HS
\> \eps 1 = \TRG{\e_1}\Env,\HS 
\= \eps 2 = \TAG{\e_2}\Env{\D_1}
\\[1mm]
\trulename{TTK6} \TRG{\New\C{\e_1..}}\Env =  \src{\New\C{\eps 1..}}
   \>\WHERE \> \Ftype{\f_1}{\t_1}\In\App\K\C ~..
   \>       \>  \eps 1 = \TAG{\e_1}\Env{\t_1} ~..
\\[1mm]
\trulename{TTK7} \TAG\e\Env\t = \src\ep
\> \WHERE\> \TypeCk{\K,\Env}\e\tp, \HS
\> \EM{\K\vdash \t \Sub \tp},
\>  \ep = \TRG\e\Env
\\[1mm]
\trulename{TTK8} \TAG\e\Env\t = \src{\BehCast\t\e}
\>\WHERE\> \TypeCk{\K,\Env}\e\tp, \HS
   \> \EM{\K\vdash \t \not \Sub \tp}
   \>     \ep = \TRG\e\Env
\end{tabbing}
\end{minipage}
\end{tabular}
\caption{Typed Racket}\end{figure}

\clearpage
\subsection{Transient}

\begin{figure}[!h]
\begin{tabular}{@{}l@{~ ~ ~}ll}
 \small
\begin{minipage}{8cm}  
\begin{tabbing}
\TR{\Class\C{\fds 1..}{\mds 1.. }} =  \src{\Class \C {\fdsp 1..}{\mdsp 1.. } }\\
\hspace{.5cm}  \WHERE\HS \=
  \fdsp 1 = \src{\Ftype\f\any} .., \HS
  \fds 1 = \Ftype\f\t ..,\HS\HS
  \mdsp 1 = \src{\Mdef\m\x\any\any{\SubCast\t\x ~; ~\eps 1}} .., \HS
  \mds 1 = \Mdef\m\x\t\tp\e ..,\HS\HS
   \eps 1 = \TAG\e{\x:\t\,\this:\C}\tp~ ..
\end{tabbing}
\begin{tabbing}
\trulename{TTR1} \TRG\this\Env \hspace{1cm} \= = \src\this
\\[1mm]
\trulename{TTR2} \TRG\x\Env \>= \src{\SubCast\t\x} \hspace{1.5cm} \=\WHERE \HS \TypeCk{\K,\Env}\x\t
\\[1mm]
\trulename{TTR3} \TRG{\FRead\f}\Env \>= \src{\SubCast\t{\FRead\f}} \>\WHERE\HS  \TypeCk{\K,\Env}\this\C,\HS\HS\=\Ftype\f\t\In\App\K\C
\\[1mm]
\trulename{TTR4} \TRG{\FWrite\f\e}\Env \>=  \src{\SubCast\t{\FWrite\f\ep}}
  \>\WHERE\HS
  \TypeCk\K\this\C,
  \> \Ftype\f\t\In\App\K\C, \hspace{.7cm}
  \= \ep = \TAG\e\Env\any
\\[1mm]
\trulename{TTR5}   \TRG{\Call{\e_1}\m{\e_2}}\Env \>= \src{\DynCall{\eps 1}\m{\eps 2}}
  \>\WHERE \HS 
  \TypeCk{\K,\Env}{\e_1}\any, \HS
  \> \eps 1 = \TRG{\e_1}\Env, 
  \> \eps 2 = \TAG{\e_2}\Env\any
\\[1mm]
\trulename{TTR6} \TRG{\Call{\e_1}\m{\e_2}}\Env \>= \src{\SubCast\tp{\KCall{\eps 1}\m{\eps 2}\any\any}}
   \>\WHERE\HS
   \TypeCk{\K,\Env}{\e_1}\C,
   \> \Mtype\m\t\tp\In\App\K\C,\HS
   \> \eps 1 = \TRG{\e_1}\Env, \HS\HS
   \eps 2 = \TAG{\e_2}\Env\any
\\[1mm]
\trulename{TTR7} \TRG{\New\C{\e_1..}}\Env \>=  \src{\New\C{\eps 1..}} \>\WHERE\HS
\Ftype{\f_1}{\t_1}\In\App\K\C,
  \>\eps 1 = \TAG{\e_1}\Env{\any} ~..
\\[1mm]
\trulename{TTR8} \TAG\e\Env\t \>= \src{\SubCast\t\e}
    \>\WHERE\HS \TypeCk{\K,\Env}\e\tp, \> (\t = \any \OR \tp = \any),\HS \> \ep = \TRG\e\Env
\\[1mm]
\trulename{TTR9} \TAG\e\Env\t \>= \src\ep \>\WHERE\HS  \TypeCk{\K,\Env}\e\tp, \HS\>(\EM{\ConSub{}\K\t\tp}),\HS \> \ep = \TRG\e\Env
\end{tabbing}
\end{minipage}
\end{tabular}
\caption{Transient}\end{figure}


\section{Proofs of Related Theorems}

\subsection{Accessory Lemmas}

\paragraph{Evaluation Extends Class Tables}

If $\Reduce \K\e\s \Kp\ep\sp$ then $\Kp = \K~\Kpp$ for some $\Kpp$.

\paragraph{Weakening of Expression Typing}

If $\EnvType\Env\s\K\e\t$ then $\EnvType{\Env~\Envp}\s\K\e\t$. \\ 
If $\EnvType\Env\s\K\e\t$ then $\EnvType\Env{\s~\s'}\K\e\t$. \\ 
If $\EnvType\Env\s\K\e\t$ then $\EnvType\Env\s{\K~\Kp}\e\t$. \\ 

\paragraph{Weakening of Well-formedness}

If $\WFtype\K\t$ then $\WFtype{\K~\Kp}\t$. \\
If $\WF\Env\s\K\md$ then $\WF{\Env~\Envp}\s\K\md$.\\
If $\WF\Env\s\K\md$ then $\WF\Env{\s~\s'}\K\md$.\\
If $\WF\Env\s\K\md$ then $\WF\Env\s{\K~\Kp}\md$.\\
If $\WFtype\K{\Fdef\f\t}$ then $\WFtype{\K~\Kp}{\Fdef\f\t}$.\\
If $\WFtype\K\t$ then $\WFtype{\K~\Kp}\t$.\\

\paragraph{Weakening of Subtyping}

If $\StrSub\M{\K}\t\tp$ then $\StrSub\M{\K~\Kp}\t\tp$. \\
If $\StrSub{\M}{\K}\t\tp$ then $\StrSub{\M~\M'}{\K}\t\tp$.

\paragraph{Weakening of $\xt{mtypes}$}

If $\Mtype\m{\HT\x\t}\tp \in \classoff{\C}{\K}$, then $\Mtype\m{\HT\x\t}\tp \in \classoff{\C}{\K~\Kp}$ for some $\Kp$.

\paragraph{Substitution}

If $\EnvType{\b{\HT\x\tp}}\s\K\e\t$ and $\b{\EnvType\cdot\s\K\a\tp}$, then $\EnvType\cdot\s\K{[\a/\x]\e}\t$

\paragraph{Correctness of \classoff{\C}{\K}}

If $\Mtype\m{\t}\tp \in \classoff{\C}{\K}$, $\EnvType\cdot\s\K\a\C$ and 
$\EnvType\cdot\s\K\ap\t$, then $\Reduce \K{\KCall\a\m{\ap}{\t}{\tp}}\s \K\epp\s$ where $\EnvType\cdot\s\K\epp\tp$. 

\paragraph{Canonical forms}

If $\WFp\K{\e~\s}$ and $\EnvType\cdot\s\K\a\C$, then $\s[\a\mapsto{\obj\C{\b\a}}]$.

\paragraph{Evaluation retains typing} \label{lem:ert}

If $\EnvType\cdot\s\K\e\t$, $\EnvType\cdot\s\K\ep\tp$, and $\WFp\K{\ep~\s}$, then if $\Reduce\K\ep\s\Kp\epp\sp$, it follows that $\EnvType\cdot\sp\Kp\e\t$ and $\Kp = \K~\Kpp$.

\subsection{Reduction preserves Well-formedness}

If $\Reduce \K\e\s \Kp\ep\sp$ and $\WFp\K{\e~\s}$, then $\WFp\Kp{\ep~\sp}$. 

\subsection{Consistent Class Table}

If $\WFp\K{\e~\s}$, then $\forall~\Class\C{\b{\fd}}{\b\md}~.~\WFtype\K{\b\fd}~\wedge~\WF\cdot\s\K{\b\md}$

\subsection{Correctness of $\xt{wrap}$}

If $\WFp \K$ (TODO), if $\C \in \K$, $\Cp \in \K$, $\D$ free, $\b\md = \getmds\C\K$, $\bmt = \classoff\C\K$, $\bmtp = \classoff\Cp\K$, and $\k = \wrap\C\bmt\bmtp\D\that$, then $\StrSub\cdot{\K~\k}\D\Cp$ and $\WFp \k$.

\subsection{Type Soundness of Core \kafka Typing}

Given that $\WFp\K{\e~\s}$ and $\EnvType\cdot\s\K\e\t$, then either there is some $\ep$ and $\Kpp$ (with $\Kp = \K~\Kpp$) 
such that $\Reduce \K\e\s \Kp\ep\sp$ and $\WFp\Kp{\ep~\sp}$ and $\EnvType\cdot\sp\Kp\ep\t$ hold, 
or $\e$ is stuck in one of the following forms:
\begin{itemize} 
\item $\a$
\item $\EE[\DynCall\a\m{\ap}]$
\item $\EE[\SubCast\tp\a]$
\item $\EE[\BehCast\tp\a]$
\end{itemize}

We proceed with rule induction on the judgement used to conclude $\EnvType\Env\s\K\e\t$. 
Note that we refer to rule preconditions from left to right.

\begin{itemize}
  \item \RuleRef{KT-VAR}
        Not applicable, since $\Gamma = \cdot$ and therefore contains no variables.
  \item \RuleRef{KT-SUB}
        We apply the IH to the first precondition. If we get stuck in the IH, then the entire
        expression gets stuck or terminates, trivially. Therefore, the interesting case is when
        $\Reduce \K\e\s \Kp\ep\sp$, $\WFp\Kp{\ep~\sp}$ and $\EnvType\cdot\sp\Kp\ep\tp$. Since, by the
        second precondition, we know that $\StrSub \M\K \tp \t$, it follows by weakening of subtyping $\StrSub\M\Kp\tp\t$.
        We can then apply \RuleRef{W2} to find that $\EnvType\cdot\sp\Kp\ep\t$, and therefore $\Reduce\K\e\s\Kp\ep\sp$, $\WFp\Kp{\ep~\sp}$, and $\EnvType\cdot\sp\Kp\ep\t$, and the theorem holds.
  \item \RuleRef{KT-READ}
        Since $\Gamma = \cdot$ by assumption, \RuleRef{KT-READ} cannot have applied.
  \item \RuleRef{KT-REFREAD}
        By inversion of $\RuleRef{KT-REFREAD}$, we know that the expression is of form $\FReadR\a\f$. It follows from $\Fdef\f\t \in \App\K\C$ that $\Class\C{\fd_i \ldots~\Fdef\f\t ~ \fd_j \ldots}{\md~\ldots}$ and from well-formedness of heaps that $\App\sigma\a = \Map\s{\Bind{\a}{\obj\C{\a_i\dots ~\ap~ \a_j\dots}}}$ that $\EnvType\cdot\s\K\ap\t$. Therefore, $\Reduce\K{\FReadR\a\f}\s\K\ap\s$ and $\WFp\K{\ap~\s}$, so the theorem holds.
  \item \RuleRef{KT-WRITE}
        Since $\Gamma = \cdot$ by assumption, \RuleRef{KT-WRITE} cannot have applied.
  \item \RuleRef{KT-REFWRITE}
        By inversion of $\RuleRef{KT-REFWRITE}$, we know that the expression is of form $\FWriteR\a\f\e$. Applying the IH to the third precondition, we find that either $\e$ is a value $\ap$, $\e$ is stuck, or $\Reduce\K\e\s\Kp\ep\sp$, $\WFp\Kp{\ep~\sp}$, and $\EnvType\cdot\sp\Kp\ep\C$. 

        If $\e$ steps to some $\ep$, we can trivially apply $\RuleRef{KT-REFWRITE}$ again, with weakening of typing over class tables and heaps, to conclude that $\EnvType\cdot\sp\Kp{\FWriteR\a\f\ep}\t$.

        If $\e$ is a value $\ap$, then it follows from $\Fdef\f\t \in \App\K\C$ that $\Class\C{\fd_i \ldots~\Fdef\f\t ~ \fd_j \ldots}{\md~\ldots}$ and from well-formedness of heaps that $\App\sigma\a = \Map\s{\Bind{\a}{\obj\C{\a_i\dots ~\app~ \a_j\dots}}}$. Therefore, we can apply the definition of $\xt{write}$ to find that $\setf\s\a\f\K\ap = \Map\s{\Bind{\a}{\obj\C{\a_i\dots ~\ap~ \a_j\dots}}}$, which we then define as $\sp$. Since we know that $\EnvType\cdot\s\K\ap\t$, and we know that $\forall \a \in \sigma, \Map\s{\Bind{\a}{\obj\C{\ldots}}} \implies \Map\sp{\Bind\a{\obj\C{\ldots}}}$, it follows that $\EnvType\cdot\sp\K\ap\t$, and from there that $\WFp\K{\ap~\sp}$ and $\EnvType\cdot\sp\K\ap\t$, so the theorem holds.

        If $\e$ is a stuck state of the form $\EE[\ep]$, define $\EE' = \Call{\EE[\ep]}\f{}$, and then the theorem holds.

  \item \RuleRef{KT-CALL}

      We apply the IH to the first precondition, finding that either $\e$ is a value $\a$, $\e$ is a stuck state, or $\Reduce\K\e\s\Kp\ep\sp$, $\WFp\Kp{\ep~\sp}$, and $\EnvType\cdot\sp\Kp\ep\C$, then case analyze.
      \begin{itemize}
        \item $\Reduce\K\e\s\Kp\epp\sp$, $\WFp\Kp{\epp~\sp}$, and $\EnvType\cdot\sp\Kp\epp\C$. Apply \ref{lem:ert} to the second precondition to find that $\EnvType\Kp\sp\ep\t$, and apply \RuleRef{KT-CALL} to find that $\EnvType\cdot\sp\Kp{\KCall\epp\m\ep\t\tp}\tp$.
        \item $\e$ is $\a$: Apply the IH to $\e'$. Then, either $\e'$ is a value $\ap$, $\e'$ is stuck, or $\Reduce\K\ep\s\Kp\epp\sp$, $\WFp\Kp{\ep~\sp}$, and $\EnvType\cdot\sp\Kp\epp\t$. 
        \begin{itemize}
          \item $\Reduce\K\ep\s\Kp\epp\sp$, $\WFp\Kp{\epp~\sp}$, and $\EnvType\cdot\sp\Kp\epp\C$. Then, $\Reduce\K{\KCall\a\m\ep\t\tp}\s\Kp{\KCall\a\m\epp\t\tp}\sp$ by the definition of evaluation contexts. Apply \ref{lem:ert} to the first precondition to find that $\EnvType\cdot\sp\Kp\a\C$, then use \RuleRef{KT-CALL} to conclude that $\EnvType\cdot\sp\Kp{\KCall\a\m\epp\t\tp}\tp$.
          \item $\e' = \ap$. In this case, apply correctness of $\xt{mtypes}$ to find that $\Reduce\K{\KCall\a\m\ap\t\tp}\s\K\epp\s$, where $\EnvType\cdot\s\K\epp\tp$.
          \item $\e'$ is stuck at one of the three stuck states, of the form $\EE[\epp]$, then we can construct $\EE'[\epp] = \KCall\a\m{\EE[\epp]}\t\tp$, which is stuck.
        \end{itemize}
        \item If $\e$ is stuck at one of the three stuck states of the form $\EE[\epp]$, then we can construct $\EE'[\epp] = \KCall{\EE[\epp]}\m{\ep}\t\tp$, which is stuck.
      \end{itemize}
  
  \item \RuleRef{KT-DYNCALL}
  
      We apply the IH to the first precondition, finding that either $\e$ is a value $\a$, $\e$ is a stuck state, or $\Reduce\K\e\s\Kp\ep\sp$, $\WFp\Kp{\ep~\sp}$, and $\EnvType\cdot\sp\Kp\ep\any$, then case analyze.
      \begin{itemize}
        \item $\Reduce\K\e\s\Kp\epp\sp$, $\WFp\Kp{\epp~\sp}$, and $\EnvType\cdot\sp\Kp\epp\any$. Apply \ref{lem:ert} to the second precondition to find that $\EnvType\Kp\sp\ep\any$, and apply \RuleRef{KT-DYNCALL} to find that $\EnvType\cdot\sp\Kp{\DynCall\epp\m\ep}\any$.
        \item $\e$ is $\a$: Apply the IH to $\e'$. Then, either $\e'$ is a value $\ap$, $\e'$ is stuck, or $\Reduce\K\ep\s\Kp\epp\sp$, $\WFp\Kp{\ep~\sp}$, and $\EnvType\cdot\sp\Kp\epp\any$. 
        \begin{itemize}
          \item $\Reduce\K\ep\s\Kp\epp\sp$, $\WFp\Kp{\epp~\sp}$, and $\EnvType\cdot\sp\Kp\epp\any$. Then, $\Reduce\K{\KCall\a\m\ep\t\tp}\s\Kp{\KCall\a\m\epp\t\tp}\sp$ by the definition of evaluation contexts. Apply \ref{lem:ert} to the first precondition to find that $\EnvType\cdot\sp\Kp\a\any$, then use \RuleRef{KT-DYNCALL} to conclude that $\EnvType\cdot\sp\Kp{\DynCall\a\m\epp}\any$.
          \item $\e' = \ap$. If $\sigma(a) = \C\{\b{\app}\}$, and if $\Mdef\m\x\any\any\e \in \K(\C)$, then $\Reduce\K{\DynCall\a\m\ap}\s\K{[\a/\this ~ \ap/\x]\e}\any$, by the definition of evaluation. Then, since $\WFp\K{\e~\s}$, it follows that $\WFq\C$, and then that $\EnvType{\HT{\this}{\C}~\HT{\x}{\any}}\s\K\e\any$. Then, since we have that $\EnvType\cdot\s\K\a\C$ (by application of \RuleRef{KT-REFTYPE}), and that $\EnvType\cdot\s\K\ep\any$, we can use the substitution lemma to find that $\EnvType\cdot\s\K{[\a/\this ~ \ap/\x]\e}\any$, and the theorem holds.


          If the precondition does not apply, and $\C$ does not contain $\m$ under type $\any$, then the expression gets stuck, and the theorem holds.
          \item $\e'$ is stuck at one of the three stuck states, of the form $\EE[\epp]$, then we can construct $\EE'[\epp] = \DynCall\a\m{\EE[\epp]}$, which is stuck.
        \end{itemize}
        \item If $\e$ is stuck at one of the three stuck states of the form $\EE[\epp]$, then we can construct $\EE'[\epp] = \DynCall{\EE[\epp]}\m{\ep}$, which is stuck.
      \end{itemize}
      
  \item \RuleRef{KT-NEW}
  
  We apply the IH to the preconditions $\e_{1} \cdots \e_{n}$, finding that either $\e_{i}$ is a value $\a$, $\e_{i}$ is a stuck state, 
  or $\Reduce\K{\e_i}\s\Kp{\ep_i}\sp$, $\WFp\Kp{\ep_i~\sp}$, and $\EnvType\cdot\sp\Kp{\ep_i}\C_i$, then case analyze.
    
  \begin{enumerate}
   \item $\EnvType\cdot\s\K{\New\C{\e_1\dots\e_n}}\C$ 
   \item $\WFp\K{\e~\s}$  by case  
   \item $\Class \C {\b\fd}{\b\md} \in \K$  
   \item $\EnvType \cdot\s\K{\e_1}{\t_1}\dots \EnvType \cdot\s\K{\e_n}{\t_n}$
   \item $\b\fd=\Fdef{\f_1}{\t_1}\dots\Fdef{\f_n}{\t_n}$ by inversion lemma on (1)
   \item $\EnvType \cdot\s\K{\a_1}{\t_1}\dots \EnvType \dot\s\K{\a_n}{\t_n}$ by Inductive hypo on (2)
   \item $\Kp~{\New\C{\b\a}~\s}$ by Inductive hypo and (6)
   \item $\Kp=\K$
   \item $\sp=\Map\s{\Bind\ap{\obj\C{\b\a}}}$
   \item $\ap$ fresh
   \item $\ep=\ap$ by semantics on (7)
   \item $\EnvType \cdot\sp\Kp{\ap}{\C}$ by W10 on (8) and (9)
   \item $\k \in \K \implies \WF{}\cdot\K\k$ by (2)
   \item $\WFtype{\K}\s$ by premise of WF (2)
   \item $\WFtype{\K}\sp$ by (14), (2), (4)
   \item $\WFtype{\Kp}\sp$ by (15), (8)
   \item $\WFp\Kp{\ap~\sp}$ by (13), (8), (16), (12)
   \item done by (17) and (12)
  \end{enumerate}

  \item \RuleRef{KT-SUBCAST}
  
      Apply the IH to the precondition, finding that either $\e$ is a value $\a$, $\e$ is a stuck state, or $\Reduce\K\e\s\Kp\ep\sp$, $\WFp\Kp{\ep~\sp}$, and $\EnvType\cdot\sp\Kp\ep\any$. If it gets stuck at one of the three stuck states, or steps to a new expression, then the case is trivial.

      Consider the $\a$ case. Case analyze on $\t$:
      \begin{itemize}
        \item $\t = \any$. Trivially, $\Reduce\K{\SubCast\t\a}\s \K\a\s$.
        \item $\t = \C$. Define $\D$ such that $\sigma(\a) = \D\{\b{\ap}\}$. Case analyze on if $\StrSub \M\K \D \C$.
        \begin{itemize}
          \item If $\StrSub \M\K \D \C$, then $\Reduce\K{\SubCast\t\a}\s \K\a\s$. Moreover, $\HasType\cdot\K\s\a\t$, via \RuleRef{W2} and \RuleRef{W10}.
          \item Otherwise, $\SubCast\t\a$ is stuck, and the theorem holds.
        \end{itemize}
      \end{itemize}
      
  \item \RuleRef{KT-BEHCAST}
\begin{proofy}
\stepp[base] $\EnvType\cdot\s\K\e\tp$ \basis By assumption.
\stepp[progform] $\WFp \K{\e~\s}$ \basis By assumption
\stepp[inpswf] $\WFq \s$ \basis By inversion of \refby{progform}
\stepp Apply IH to \refby{base} and case analyze.
\begin{casel}
  \caseof{ \begin{iknown}
    \stepp[kred] $\Reduce\K\e\s\Kp\ep\sp$
    \stepp[kbase] $\WFp\Kp{\ep~\sp}$
    \stepp $\EnvType\cdot\sp\Kp\ep\tp$
    \end{iknown}} 
  \begin{proofy}
  \stepp $\Reduce\K{\BehCast{\t}{\e}}\s\Kp{\BehCast{\t}{\ep}}\sp$ \basis By defn. of evaluation environments on \refby{kred}
  \stepp[ktype] $\EnvType\cdot\sp\Kp{\BehCast\t\ep}\t$ \basis By \RuleRef{KT-BEHCAST}
  \stepp $\WFp\Kp{\ep~\sp}$ \basis By \refby{kbase, ktype}
  \end{proofy}
  \caseof{$\e$ is stuck in one of the allowed stuck states $\EE[\ep]$}
  \begin{proofy}
    \stepp $\BehCast\t\e = \EE'[\ep]$ \basis By case analysis and defn. of $\EE$.
    \stepp $\EE'[\ep]$ stuck \basis As $\ep$ stuck.
  \end{proofy}
  \caseof{$\e = \a$}
  \begin{proofy}
    \stepp Let $\C$ and $\b{\ap}$ be such that $\s(\a) = \C\{\b\ap\}$
    \stepp Case analyze on $\t$.
    \begin{casel}
      \caseof{$\t = \Cp$}
      \begin{proofy}
        \stepp Let $\D$ be fresh.
        \stepp Let $\ap$ be fresh.
        \stepp[wcorr] Let $\k$ be $\k = \wrap\C{\classoff\C\K}{\classoff\Cp\K}\D\that$.
        \stepp Let $\sp = \s[\ap \mapsto \D\{\a\}]$.
        \stepp[b2] $\EnvType\cdot{\K\k}\sp\ap\D$ \basis \RuleRef{W9}
        \stepp[b1] $\StrSub\cdot{\K\k}\D\Cp$ \basis correctness of $\xt{wrap}$ on \refby{wcorr}
        \stepp[wth] $\EnvType\cdot{\K\k}\sp\ap\Cp$ \basis \RuleRef{W2} on \refby{b1,b2}
        \stepp $\WFp{\K ~ \k}{\ap~\sp}$ \basis \RuleRef{WP} on \refby{wth, inpswf}
      \end{proofy}
      \caseof{$\t = \any$}
      \begin{proofy}
        \stepp Let $\D$ be fresh.
        \stepp Let $\ap$ be fresh.
        \stepp[wcorr2] Let $\k$ be $\k = \wrapAny\C{\classoff\C\K}\D\that$.
        \stepp Let $\sp = \s[\ap \mapsto \D\{\a\}]$.
        \stepp[b21] $\EnvType\cdot{\K\k}\sp\ap\any$ \basis \RuleRef{W10}
        \stepp $\WFp{\K ~ \k}{\ap~\sp}$ \basis \RuleRef{WP} on \refby{b21,wcorr2}
      \end{proofy}
    \end{casel}
  \end{proofy}
\end{casel}
\end{proofy}
  
  \item \RuleRef{KT-REFTYPE}
  
      Trivial, as $\e=\a$.
  
  \item \RuleRef{KT-REFANY}
  
      Trivial, as $\e=\a$.
\end{itemize}


\subsection{Type Soundness of \kafka Behavioral Cast}

Given that $\WFp\K{\e~\s}$ and $\EnvType\cdot\s\K\e\t$, then either there is some $\ep$ 
such that $\Reduce \K\e\s \Kp\ep\sp$ and $\WFp\Kp{\ep~\sp}$ and $\EnvType\cdot\sp\Kp\ep\t$ hold, 
or $\e$ is stuck in one of the following forms:
\begin{itemize} 
\item $\a$
\item $\EE[\DynCall\a\m{\ap}]$
\item $\EE[\SubCast\tp\a]$
\item $\EE[\BehCast\tp\a]$
\end{itemize}

Note that the majority of the proof is identical to that seen in the above proof
for soundness of the \kafka core, and is therefore elided. We will only cover
the case for the \kafka behavioural cast, \RuleRef{WB1}.

\subsection{Wrap function creates well-formed classes}

  \begin{theorem}{Wrap function creates well-formed classes}{WFun-WFC}
  
  \begin{conds}
   \cond{\WFq{\K~\e~\s}}\lbl{cond1}
%    \cond{\names{\classoff\Cp\K} $\subseteq$ \names{\classoff\C\K}}\lbl{cond2}
%    \cond{\fresh\D}\lbl{cond3}
   \cond{\bmt = \classoff\C\K}\lbl{cond3a}
   \cond{\bmtp = \classoff\Cp\K}\lbl{cond3b}
   \cond{k = \wrap\C{\bmt}{\bmtp}\D\that}\lbl{cond4}
   \cond{\App\s\a = \obj\C{\b{\a_1}}}\lbl{cond5}
   \cond{\sp = \Map \s{\Bind\ap{\obj\D{\a}}}}\lbl{cond6}
   \cond{\cload{\bmt}}\lbl{cond7}
   \cond{\fresh\that}\lbl{cond8}
  \end{conds}
  
  \then\axiom{\WF{}\sp{\K~\k}{\k}}
  
    \begin{proof} \innatE{on the definition of the \xt{wrap} function}
     \step{\WFtype{\K~\k}{\Fdef\that\C}}{\byjdg{WF}\trf{cond5},~\trf{cond1}}\lbl{1}

     \begin{case}{\t = \Cpp, \tp = \Cppp, \Mtype\m\tpp\tppp $\not\in$ \bmtp \textbf{for} \Mdef\m\x{\t}{\tp}{~\KCall{\this.\that()_{\C}}\m{\x}\t\tp~}}\lbl{E}
      \step{\Mtype\m\Cpp\Cppp $\in$ \bmt }{\trf{cond1}, \trf{cond4}, defintion of case}\lbl{E1}
      \step{\Cpp $\in$ \Kk}{\trf{E1}}\lbl{E2}
      \step{\Cppp $\in$ \Kk}{\trf{E1}}\lbl{E3}
      \step{\WFtype\Kk\Cpp}{\byjdg{WC}{\trf{E2}}}\lbl{E4}
      \step{\WFtype\Kk\Cppp}{\byjdg{WC}{\trf{E3}}}\lbl{E5}
      \slet{\Envp}{\Env, ~\namet{\x}{\Cpp}}\lbl{E7}
      \step{\EnvType \Env\sp\Kk{\this.\that()_{\C}}\C }{\byjdg{W3}{\trf{1}, \textbf{this} variable, definition of \textbf{mtypes}}}\lbl{E6}     
      \step{\EnvType {\Envp}\sp\Kk{\x}\Cpp}{\byjdg{W1}{\trf{E7}}}\lbl{E8}  
      \step{\EnvType {\Envp}\sp\Kk{\KCall{\this.\that}\m{\x}\Cpp\Cppp}\Cppp}{\byjdg{W5}{\trf{E6}, \trf{E8}, \trf{E1}}}\lbl{E9}
      \step{\WF{\Envp}{\sp}{\Kk}{\Mdef\m\x{\Cpp}{\Cppp}{~\KCall{\this.\that}\m{\x}\Cpp\Cppp~}}}{\byjdg{WT2}{\trf{E9},~\trf{E4}, ~\trf{E5}}} \lbl{E10}                 
      \end{case}

     \begin{case}{\t = \any, \tp = \any, \Mtype\m\tpp\tppp $\not\in$ \bmtp \textbf{for} \Mdef\m\x{\t}{\tp}{~\KCall{\this.\that}\m{\x}\t\tp~}}\lbl{F}
      \statem{Same as $\t$ = \Cpp, $\t$ = \Cppp by defintion of case, \trf{cond1}, \trf{cond4}, and with WT1 and WA instead of WT2 and WC 
      respectively.}\lbl{F1}      
     \end{case}

     \begin{case}{\Mdef\m\x\Dp\Dpp {~\bscast\Dpp{\KCall{\this.\that()_{\C}}\m{\bscast\Cp\x}\Cp\Cpp}~}}\lbl{K}
      \step{\Mtype\m\Dp\Dpp $\in$ \bmtp }{\trf{cond1}, \trf{cond4}, defintion of case}\lbl{K1}
      \step{\WFtype\Kk\Dp}{\byjdg{WC}{\trf{K1}}}\lbl{K1a}      
      \step{\WFtype\Kk\Dpp}{\byjdg{WC}{\trf{K1}}}\lbl{K1b}      
      \step{\Mtype\m\Cp\Cpp $\in$ \bmt }{\trf{cond1}, \trf{cond4}, defintion of case}\lbl{K2}
      \slet{\Envp}{\Env, ~\namet{\x}{\Dp}}\lbl{K3}
      \step{\EnvType\Envp\sp\Kk{\x}{\Dp}}{\byjdg{W1}{\trf{K3}}}\lbl{K4}
      \step{\EnvType\Envp\sp\Kk{\bscast\Cp\x}{\Cp}}{\byjdg{WB}{\trf{K4}}}\lbl{K5}
      \step{\EnvType \Envp\sp\Kk{\this.\that()_{\C}}\C }{\byjdg{W3}{\trf{1}, \textbf{this} variable, definition of \textbf{mtypes}}}\lbl{K6}
      \step{\EnvType \Envp\sp\Kk{\KCall{\this.\that()_{\C}} \m {\bscast{\Cp}\x}\Cp\Cpp }\Cpp }{\byjdg{W4}{\trf{K6},~\trf{K2},~\trf{K5},~\trf{cond3a}}}\lbl{K7}
      \step{\EnvType \Envp\sp\Kk{\bscast\Dpp{\KCall{\this.\that()_{\C}}\m{\bscast\Cp\x}\Cp\Cpp}}{\Dpp}}{\byjdg{WB}{\trf{K7}}}\lbl{K8}
      \longstepB{\WF{\Envp}{\sp}{\Kk}{\Mdef\m\x\Dp\Dpp {~\bscast\Dpp{\KCall{\this.\that()_{\C}}\m{\bscast\Cp\x}\Cp\Cpp}~}}}{\byjdg{WT2}{\trf{K8},~\trf{K1a},~\trf{K1b}}}\lbl{K9}
      
     \end{case}

     \begin{case}{\Mdef\m\x\Dp\Dpp {~\bscast\Dpp{\KCall{\this.\that()_{\C}}\m{\bscast\any\x}\any\any}~}}\lbl{L}
      \step{\Mtype\m\Dp\Dpp $\in$ \bmtp }{\trf{cond1}, \trf{cond4}, defintion of case}\lbl{L1}
      \step{\WFtype\Kk\Dp}{\byjdg{WC}{\trf{L1}}}\lbl{L2}      
      \step{\WFtype\Kk\Dpp}{\byjdg{WC}{\trf{L1}}}\lbl{L3}      
      \step{\Mtype\m\any\any $\in$ \bmt }{\trf{cond1}, \trf{cond4}, defintion of case}\lbl{L4}
      \slet{\Envp}{\Env, ~\namet{\x}{\Dp}}\lbl{L5}
      \step{\EnvType\Envp\sp\Kk{\x}{\Dp}}{\byjdg{W1}{\trf{L5}}}\lbl{L6}
      \step{\EnvType\Envp\sp\Kk{\bscast\any\x}{\any}}{\byjdg{WB}{\trf{L6}}}\lbl{L7}
      \step{\EnvType \Envp\sp\Kk{\this.\that()_{\C}}\C }{\byjdg{W3}{\trf{1}, \textbf{this} variable}, definition of \textbf{mtypes}}\lbl{L8}      
      \step{\EnvType \Envp\sp\Kk{\KCall{\this.\that()_{\C}} \m {\bscast{\any}\x}\any\any }\any }{\byjdg{W4}{\trf{L8},~\trf{L4},~\trf{L7},~\trf{cond3a}}}\lbl{L9}
      \step{\EnvType \Envp\sp\Kk{\bscast\Dpp{\KCall{\this.\that()_{\C}}\m{\bscast\any\x}\any\any}}{\Dpp}}{\byjdg{WB}{\trf{L9}}}\lbl{L10}
      \longstepB{\WF{\Envp}{\sp}{\Kk}{\Mdef\m\x\Dp\Dpp {~\bscast\Dpp{\KCall{\this.\that()_{\C}}\m{\bscast\any\x}\any\any}~}}}{\byjdg{WT2}{\trf{L10},~\trf{L2},~\trf{L3}}}\lbl{L11}
     \end{case}

     \begin{case}{\Mdef\m\x\any\any {~\bscast\any{\KCall{\this.\that()_{\C}}\m{\bscast\Cp\x}\Cp\Cpp}~}}\lbl{M}
      \step{\Mtype\m\any\any $\in$ \bmtp }{\trf{cond1}, \trf{cond4}, defintion of case}\lbl{M1}
      \step{\Mtype\m\Cp\Cpp $\in$ \bmt }{\trf{cond1}, \trf{cond4}, defintion of case}\lbl{M2}
      \step{\WFtype\Kk\any}{\byjdg{WA}{\any}}\lbl{M3}      
      \slet{\Envp}{\Env, ~\namet{\x}{\any}}\lbl{M4}
      \step{\EnvType\Envp\sp\Kk{\x}{\any}}{\byjdg{W1}{\trf{M4}}}\lbl{M5}
      \step{\EnvType\Envp\sp\Kk{\bscast\Cp\x}{\Cp}}{\byjdg{WB}{\trf{M5}}}\lbl{M6}
      \step{\EnvType \Envp\sp\Kk{\this.\that()_{\C}}\C }{\byjdg{W3}{\trf{1}, \textbf{this} variable}, definition of \textbf{mtypes}}\lbl{M7}
      \step{\EnvType \Envp\sp\Kk{\KCall{\this.\that()_{\C}} \m {\bscast{\Cp}\x}\Cp\Cpp }\Cpp }{\byjdg{W4}{\trf{M7},~\trf{M6},~\trf{M2},~\trf{cond3a}}}\lbl{M8}
      \step{\EnvType \Envp\sp\Kk{\bscast\any{\KCall{\this.\that()_{\C}}\m{\bscast\Cp\x}\Cp\Cpp}}{\any}}{\byjdg{WB}{\trf{M8}}}\lbl{M9}
      \longstepC{\WF{\Envp}{\sp}{\Kk}{\Mdef\m\x\any\any {~\bscast\any{\KCall{\this.\that()_{\C}}\m{\bscast\Cp\x}\Cp\Cpp}~}}}{\byjdg{WT1}{\trf{M9},~\trf{M3}}}\lbl{M10}
     \end{case}
    
     \step{$\Class \D {\b\fd}{\b\md} \in \K~\k$}{\trf{cond7}}\lbl{N2}
     \step{\cload{\classoff\D{\K~\k}}}{\trf{cond8}, \bylemm{\ref{lem:DM-WR}}{DupMeth over wrappers}{\trf{cond7}, \trf{cond4}}}\lbl{N1}
     \step{\xt{overloading}$_{\cmd}$(\b\md~\b\fd) \textbf{for} \k}{\bylemm{\ref{lem:DM-OL}}{DupMeth gives overloading}{\trf{cond7}}, \trf{N2}, \trf{N1}}\lbl{N3}   
     \done{\trf{1}, \trf{N3}, and \textbf{Case}}
    \end{proof}
   \end{theorem}

\begin{lemma}{Extending dupMeth with wrappers}{DM-WR}

  \begin{conds}
   \cond{k = \wrap\C{\classoff\C\K}{\classoff\Cp\K}\D\that}\lbl{cond4}
   \cond{\cload{\classoff\C\K}}\lbl{cond1}
  \end{conds}
  
  \then\axiom{\cload{\classoff\D{\K~\k}}}

   \begin{proof} \innatE{on the construction of \k}
    \step{\names{\classoff\D{\K~\k}} $\subseteq$ \names{\classoff\C{\K}}.}{\trf{cond4}, \textbf{wrap} function (ensures all methods in \D must be in \C).}\lbl{1}
    \step{\cload{\classoff\D{\K~\k}}}{\trf{1}, \trf{cond1}, \textbf{dupMeth} function}\lbl{2}
    \done{\trf{2}}
   \end{proof}
\end{lemma}
 
    
\begin{lemma}{dupMeth of wrapper class gives overloading}{DM-OL}

  \begin{conds}
   \cond{k = \wrap\C{\classoff\C\K}{\classoff\Cp\K}\D\that}\lbl{cond1}
   \cond{$\Class \D {\b\fd}{\b\md} \in \K~\k$}\lbl{cond2}
   \cond{\bmt = \classoff\D{\K~\k}}\lbl{cond3}
   \cond{\cload{\bmt}}\lbl{cond4}
   \cond{\fresh{\textbf{that}}}\lbl{cond5}
  \end{conds}
  
  \then\axiom{\xt{overloading}$_{\emptyset}$(\b\md~\b\fd)}

   \begin{proof} \indana{\trf{cond4}}
     \begin{case}{FO1}\lbl{A}
      \step{\xt{overloading}$_{\cmd}$(\namet{\that}{\C})}{\trf{cond5}, \trf{cond1}}\lbl{A1}
      \done{\trf{A1}}
     \end{case}
     
     \begin{case}{MO1}\lbl{B}
      \statem{Trivial, axiom.}\lbl{B1}
      \done{\trf{B1}}
     \end{case}

     \begin{case}{MO2}\lbl{C}
      \step{\xt{overloading}$_{\cmd}$(\Mdef\m\x\any\any\e ~ \b\mdp ~\b\fd)}{def of \textbf{case}}\lbl{C1}
      \step{\m $\not\in$ \names{\b\mtp}}{\trf{cond4} on \textbf{case}}\lbl{C2}
      \step{\Mdef\m\x\any\any\e $\not\in$ \b\mdp}{\trf{C1}, \trf{C2}}\lbl{C3}
      \slet{\cmdp}{\cmd,~\Mdef\m\x\any\any\e}\lbl{C4}
      \step{\xt{overloading}$_{\cmdp}$(\b\mdp~\b\fd)}{Ind Hyp on \textbf{case}, \trf{C1}, \trf{C3}, \trf{C4}}\lbl{C5}
      \done{\trf{C3}, \trf{C4}, \trf{C5}}
     \end{case}

     \begin{case}{MO3}\lbl{D}
      \step{\xt{overloading}$_{\cmd}$(\Mdef\m\x\C\Cp\e ~ \b\mdp ~\b\fd)}{def of \textbf{case}}\lbl{D1}
      \step{\m $\not\in$ \names{\b\mtp}}{\trf{cond4} on \textbf{case}}\lbl{D2}
      \step{\Mdef\m\x\C\Cp\e $\not\in$ \mdp}{\trf{D1}, \trf{D2}}\lbl{D3}
      \slet{\cmdp}{\cmd, ~\Mdef\m\x\C\Cp\e}\lbl{D4}
      \step{\xt{overloading}$_{\cmdp}$(\b\mdp~\b\fd)}{Ind Hyp on \textbf{case}, \trf{D1}, \trf{D3}, \trf{D4}}\lbl{D5}
      \done{\trf{D3}, \trf{D4}, \trf{D5}}      
     \end{case}
   \end{proof}
\end{lemma}

\subsection{Type Soundness of TypeScript and Typed Racket Translation}

\begin{lemma}{Type correctness of TypeScript/Typed Racket translation}{THTS-TRANS}
  \begin{conds}
    \cond{$\WFpX\K\e{s}$}\lbl{cond1}
    \cond{$\WFtypeX \K{s}\t$}\lbl{cond2}
    \cond{$\HT\x\tp \in \Env \implies \WFtypeX\K{s}\tp$}\lbl{cond3}
    \cond{\EnvTypeE\Env\K{s}\e\t}\lbl{cond4}
    \cond{$\TR\K = \Kp$}\lbl{cond5}
    \cond{$\TR\Env = \Envp$}\lbl{cond6}
  \end{conds}

  \then\axiom{$\EnvType\Envp\cdot\Kp{\TRG{\e}\Env}{\any}$}

  \begin{proof} \indmsg{\EnvTypeE\Env\K{s}\e\t}

    \begin{case}{STG-VAR}\lbl{A}
      \begin{case}{\x $\neq$ \this}\lbl{AA}
	\step{$\TR{\x} = \x$}{\byjdg{TTS4}{case, \trf{cond4}}}\lbl{AA1}
	\step{$\EnvType\Envp\cdot\Kp\x{\kty\t}$}{\trf{cond4}, \trf{cond5}, \trf{cond6}, \RuleRef{KT-VAR}}\lbl{AA2}
	\done{\trf{AA2}}
      \end{case}
      
      \begin{case}{\x = \this}\lbl{AB}
	\step{\EnvTypeS\Env\K\this\t}{case}\lbl{AB1}
	\step{\HasType\Env\this\t}{\byjdg{Inversion}{\trf{AB1}}}\lbl{AB2}
	\step{\TR\this = \SubCast\any\this}{\byjdg{TTS3}{case, \trf{cond4}}}\lbl{AB3}
	\step{\EnvType\Envp\cdot\Kp\this{\t}}{\byjdg{KT-VAR}{\trf{AB2}}}\lbl{AB4}
	\step{\EnvType\Envp\cdot\Kp{\SubCast\any\this}{\any}}{\byjdg{KT-SBUCAST}{\trf{AB4}}}\lbl{AB5}
	\done{\trf{AB5}}
      \end{case}
    \end{case}
    
    \begin{case}{STG-GET}\lbl{B}
      \step{$\TR{\FRead\f} = \FRead\f$}{\byjdg{TTS1}{\trf{cond4}}}\lbl{B1}
      \step{$\EnvType\Envp\cdot\Kp{\FRead\f}{\kty\t}$}{\byjdg{KT-READ}{\trf{cond4}, \trf{cond5}, \trf{cond6}}}\lbl{B2}
      \done{\trf{B2}}
    \end{case}

    \begin{case}{STG-SET}\lbl{C}
      \step{$\EnvTypeS\Env\K{\FWrite\f\e}\t$}{case}\lbl{C1}
      \step{$\ConvertE\K{s}\tp\t$}{case}\lbl{C2}
      \step{$\EnvTypeS\Env\K\e\tp$}{inversion on \trf{C1}}\lbl{C3}
      \slet{\ep}{\TRG\e\Env}\lbl{C4}
      \step{$\EnvType\Envp\cdot\Kp\ep{\any}$}{\byjdg{Ind Hyp.}{\trf{C3}, \trf{C4}}}\lbl{C5}
      \step{$\TR{\FWrite\f\e} = \FWrite\f\ep$}{\byjdg{TTS2}{\trf{C1}, \trf{C4}, \trf{cond5}}}\lbl{C6}
      \step{$\EnvType\Envp\cdot\Kp{\FWrite\f\ep}{\any}$}{\byjdg{KT-WRITE}{\trf{C6}, \trf{C5}, \trf{cond5}}}\lbl{C7}    
      \done{\trf{C7}}
    \end{case}
    
    \begin{case}{STG-CALL}\lbl{D}
      \step{\EnvTypeS\Env\K{\Call{\e}\m{\ep}}\tp}{case}\lbl{D1}
      
      \begin{steps}{\byjdg{Inversion lemma}{\trf{D1}}}
	\step{\EnvTypeS\Env\K{\e}{\C}}\lbl{D2}
	\step{\EnvTypeS\Env\K{\ep}{\tpp}}\lbl{D3}
	\step{\Mtype\m\t\tp $\in$ \classoff\C\K}\lbl{D4}
	\step{\ConvertE\K{s}\tpp\t}\lbl{D5}
      \end{steps}
      
      \slet{\e$_1$}{\TRG\e\Env}\lbl{D6}
      \slet{\ep$_{1}$}{\TRG\ep\Env}\lbl{D7}
      \step{\TR{\Call{\e}\m{\ep}} = \DynCall{\e_1}\m{\ep_1}}{\byjdg{TTS4}{\trf{D6}, \trf{D7}, \trf{D1}}}\lbl{D8}
      \step{\EnvType\Envp\cdot\Kp{\e_1}\any}{\byjdg{Ind Hyp.}{\trf{D2}, \trf{cond5}, \trf{cond6}}}\lbl{D9}
      \step{\EnvType\Envp\cdot\Kp{\ep_1}\any}{\byjdg{Ind Hyp.}{\trf{D3}, \trf{cond5}, \trf{cond6}}}\lbl{D10}
      \step{\EnvType\Envp\cdot\Kp{\DynCall{\e_1}\m{\ep_1}}{\any}}{\byjdg{KT-DYNCALL}{\trf{D9}, \trf{D10}}}\lbl{D11}
      \done{\trf{D11}}
    \end{case}
    
    \begin{case}{STG-DCALL}\lbl{E}
      \step{\EnvTypeS\Env\K{\Call{\e}\m{\ep}}\any}{case}\lbl{E1}
      
      \begin{steps}{\byjdg{Inversion lemma}{\trf{E1}}}
	\step{\EnvTypeS\Env\K{\e}{\any}}\lbl{E2}
	\step{\EnvTypeS\Env\K{\ep}{\tpp}}\lbl{E3}
	\step{\ConvertE\K{s}\tpp\any}\lbl{E4}
      \end{steps}
      
      \slet{\e$_1$}{\TRG\e\Env}\lbl{E5}
      \slet{\ep$_{1}$}{\TRG\ep\Env}\lbl{E6}
      \step{\TR{\Call{\e}\m{\ep}} = \DynCall{\e_1}\m{\ep_1}}{\byjdg{TTS4}{\trf{E5}, \trf{E6}, \trf{E1}}}\lbl{E7}
      \step{\EnvType\Envp\cdot\Kp{\e_1}\any}{\byjdg{Ind Hyp.}{\trf{E2}, \trf{cond5}, \trf{cond6}}}\lbl{E8}
      \step{\EnvType\Envp\cdot\Kp{\ep_1}\any}{\byjdg{Ind Hyp.}{\trf{E3}, \trf{cond5}, \trf{cond6}}}\lbl{E9}
      \step{\EnvType\Envp\cdot\Kp{\DynCall{\e_1}\m{\ep_1}}{\any}}{\byjdg{KT-DYNCALL}{\trf{E8}, \trf{E9}}}\lbl{E10}
      \done{\trf{E10}}
    \end{case}

    \begin{case}{STG-NEW}\lbl{F}
      \begin{steps}{case}
	\step{\EnvTypeS\Env\K{\New\C{\e_1 ~\ldots}}\t}\lbl{F1A}
	\step{\b\fd=\Fdef{\f_1}{\t_1}~\dots}\lbl{F1B}
	\step{\Class \C {\b\fd}{\b\md} $\in$ \K}\lbl{F1C}
      \end{steps}
      \begin{steps}{\byjdg{Inversion}{\trf{F1A}}}
	\step{\EnvTypeS\Env\K{\e_1}\tp$_1$ ~ \ldots}\lbl{F2}
	\step{\ConvertE\K{s}{\tp_1}{\t_1} ~ \ldots}\lbl{F3}
      \end{steps}
       \slet{$\ep_{i}$}{$\TR{\e_{i}} \xt{~for~all~} i$}\lbl{F4}
       \step{\EnvType\Envp\cdot\Kp{\ep_i}{\any}}{\byjdg{Ind Hyp.}{\trf{F2}}}\lbl{F5}
       \step{\TR{\New\C{\e_1,\ldots}} = \SubCast\any{\New\C{\ep_1,\ldots}}}{\byjdg{TTS6}{\trf{F1A}}}\lbl{F6}
       \step{\EnvType\Envp\cdot\Kp{\New\C{\ep_1,\ldots}}{\C}}{\byjdg{KT-NEW}{\trf{F5}, \trf{F1B}, \trf{F1C}}}\lbl{F7}
       \step{\EnvType\Envp\cdot\Kp{\SubCast\any{\New\C{\ep_1,\ldots}}}{\any}}{\byjdg{KT-SUBCAST}{\trf{F7}}}\lbl{F8}
       \done{F8}
    \end{case}
  
  \end{proof}
\end{lemma}

\begin{lemma}{Soundness of TypeScript/Typed Racket convertibility}{THTS-COMP}
  \begin{conds}
    \cond{$\ConvertE\K{s}\t\tp$}\lbl{cond1}
    \cond{$\EnvTypeS\Env\K\e\t$}\lbl{cond2}
    \cond{$\ep = \TRG{\e}\Env$}\lbl{cond3}
    \cond{$\TR\K = \Kp$}\lbl{cond4}
    \cond{$\TR\Env = \Envp$}\lbl{cond5}
    \cond{$\EnvType\Envp\cdot\Kp{\ep}{\t}$}\lbl{cond6}
  \end{conds}
  \then\axiom{$\EnvType\Envp\cdot\Kp{\TAG\e\Env{\tp}}{\tp}$}

  \begin{proof}{ \indmsg{$\ConvertE\K{s}\t\tp$}}

  \begin{case}{STGC-SUB}
      \step{$\StrSub\cdot\Kp\t\tp$}{\trf{cond4}, case}\lbl{SUB-V1}
      \step{$\e = \TAG\e\Env{\tp}$}{TTK7 on \trf{SUB-V1}}
      \step{$\EnvType\Envp\cdot\Kp{\e}\tp$}{\RuleRef{KT-SUB} on \trf{cond6}, \trf{SUB-V1}}\lbl{SUB-V2}
      \done{\trf{SUB-V2}}
  \end{case}

  \begin{case}{STGC-TOANY}
      \step{$\e = \TAG\e\Env{\any}$}{TTK8 on \trf{TOANY-V1}}
      \step{$\EnvType\Envp\cdot\Kp{\SubCast\any\e}\any$}{\RuleRef{KT-SUBCAST} on \trf{cond6}}\lbl{TOANY-V2}
      \done{\trf{TOANY-V2}}
  \end{case}

  \begin{case}{STGC-ANYCONC}
      \step{$\e = \TAG\e\Env{\t}$}{TTK8 on \trf{ANYCONC-V1}}
      \step{$\EnvType\Envp\cdot\Kp{\SubCast\t\e}\t$}{\RuleRef{KT-SUBCAST} on \trf{cond6}}\lbl{ANYCONC-V2}
      \done{\trf{ANYCONC-V2}}
  \end{case}

  \end{proof}
\end{lemma}

\begin{lemma}{Type correctness of Typed Racket translation}{THTR-TRANS}
  \begin{conds}
    \cond{$\WFpX\K\e{s}$}\lbl{cond1}
    \cond{$\WFtypeX \K{s}\t$}\lbl{cond2}
    \cond{$\HT\x\tp \in \Env \implies \WFtypeX\K{s}\tp$}\lbl{cond3}
    \cond{\EnvTypeE\Env\K{s}\e\t}\lbl{cond4}
    \cond{$\TR\K = \Kp$}\lbl{cond5}
    \cond{$\TR\Env = \Envp$}\lbl{cond6}
  \end{conds}

  \then\axiom{$\EnvType\Envp\cdot\Kp{\TRG{\e}\Env}{\t}$}

  \begin{proof} \indmsg{\EnvTypeW\Env\K\e\t}

    \begin{case}{STG-VAR}    
      \step{$\e = \x$}{case}\lbl{VAR-V1}
      \step{${\TRG{\e}\Env} = \x$}{TTK1}\lbl{VAR-V2}
      \step{$\EnvType\Envp\cdot\Kp\x\t$}{\RuleRef{KT-VAR}, \trf{cond6}}\lbl{VAR-V3}
      \done{\trf{VAR-V3}}
    \end{case}

    \begin{case}{STG-GET} 
      \step{$\e = \FRead\f$}{case}\lbl{GET-V1}
      \step{${\TRG{\e}\Env} = \FRead\f$}{TTK2}\lbl{GET-V2}
      \step{$\EnvType\Envp\cdot\Kp\this\C$}{\trf{cond6}}\lbl{GET-V3}
      \step{$\Fdef\f\t \in \App\Kp\C$}{\trf{cond5}}\lbl{GET-V4}
      \step{$\EnvType\Envp\cdot\Kp{\FRead\f}\t$}{\RuleRef{KT-READ} on \trf{GET-V3}, \trf{GET-V4}}\lbl{GET-V5}
      \done{\trf{GET-V5}}
    \end{case}

    \begin{case}{STG-SET} 
      \step{$\e = \FWrite\f{\e_1}$}{case}\lbl{SET-V1}
      \slet{$\ep_1$}{$\TRG{\e_1}\Env$}\lbl{SET-V2}
      \step{$\EnvType\Envp\cdot\Kp{\ep_1}\tp$}{IH on case}\lbl{SET-V3}
      \slet{$\epp_1$}{$\TAG{\e_1}\Env\t$}\lbl{SET-V4}
      \slet{$\e$}{$\FWrite\f{\epp_1}$}
      \step{$\EnvType\Envp\cdot\Kp{\epp_1}\t$}{lemma \ref{lem:THTS-COMP} on case, \trf{SET-V4}}\lbl{SET-V5}
      \step{$\EnvType\Envp\cdot\Kp\this\C$}{\trf{cond6}}\lbl{SET-V6}
      \step{$\Fdef\f\t \in \App\Kp\C$}{\trf{cond5}}\lbl{SET-V7}
      \step{$\EnvType\Envp\cdot\Kp{\e}\t$}{\byjdg{\RuleRef{KT-WRITE}}{\trf{SET-V5}, \trf{SET-V6}, \trf{SET-V7}}}\lbl{SET-V8}
      \done{\trf{SET-V8}}
    \end{case}

    \begin{case}{STG-CALL} 
      \step{$\e = \Call\ep\m\epp$}{case}\lbl{CALL-V1}
      \slet{$\ep_1$}{$\TRG{\ep}\Env$}
      \slet{$\epp_1$}{$\TRG{\epp}\Env$}
      \slet{$\epp_2$}{$\TAG{\epp}\Env\t$}
      \step{$\EnvType\Envp\cdot\Kp{\ep_1}\C$}{IH on case}\lbl{CALL-V2}
      \step{$\EnvType\Envp\cdot\Kp{\epp_1}\tpp$}{IH on case}\lbl{CALL-V3}
      \step{$\EnvType\Envp\cdot\Kp{\epp_2}\t$}{lemma \ref{lem:THTS-COMP} on case, \trf{CALL-V3}}\lbl{CALL-V4}
      \step{$\Mtype\m\t\tp \in \App\Kp\C$}{\trf{cond5}}\lbl{CALL-V5}
      \step{$\EnvType\Envp\cdot\Kp{\Call{\ep_1}\m{\epp_2}}\tp$}{\byjdg{\RuleRef{KT-CALL}}{\trf{CALL-V2}, \trf{CALL-V4}, \trf{CALL-V5}}}\lbl{CALL-V6}
      \done{\trf{CALL-V6}}
    \end{case}

    \begin{case}{STG-DCALL} 
      \step{$\e = \Call\ep\m\epp$}{case}\lbl{DCALL-V1}
      \slet{$\ep_1$}{$\TRG{\ep}\Env$}
      \slet{$\epp_1$}{$\TRG{\epp}\Env$}
      \slet{$\epp_2$}{$\TAG{\epp}\Env\t$}
      \step{$\EnvType\Envp\cdot\Kp{\ep_1}\any$}{IH on case}\lbl{DCALL-V2}
      \step{$\EnvType\Envp\cdot\Kp{\epp_1}\tpp$}{IH on case}\lbl{DCALL-V3}
      \step{$\EnvType\Envp\cdot\Kp{\epp_2}\any$}{lemma \ref{lem:THTS-COMP} on case, \trf{DCALL-V3}}\lbl{DCALL-V4}
      \step{$\EnvType\Envp\cdot\Kp{\Call{\ep_1}\m{\epp_2}}\tp$}{\byjdg{\RuleRef{KT-DYNCALL}}{\trf{DCALL-V2}, \trf{DCALL-V4}}}\lbl{DCALL-V5}
      \done{\trf{DCALL-V5}}
    \end{case}

    \begin{case}{STG-NEW} 
      \step{$\e = \New\C{\e_i ~ \ldots}$}{case}\lbl{NEW-V1}
      \slet{$\ep_i$}{$\TRG{\epp}\Env$}
      \slet{$\epp_i$}{$\TAG{\epp}\Env{\t_i}$}
      \step{$\EnvType\Envp\cdot\Kp{\ep_i}{\tp_i}$}{IH on case}\lbl{NEW-V2}
      \step{$\EnvType\Envp\cdot\Kp{\epp_i}{\t_i}$}{lemma \ref{lem:THTS-COMP} on case, \trf{NEW-V2}}\lbl{NEW-V3}
      \step{$\Fdef{\f_i}{\t_i} \in \App\Kp\C$}{\trf{cond5}}\lbl{NEW-V4}
      \step{$\EnvType\Envp\cdot\Kp{\New\C{\e_i ~ \ldots}}\C$}{\byjdg{\RuleRef{KT-NEW}}{\trf{NEW-V3}, \trf{NEW-V4}}}\lbl{NEW-V5}
      \done{\trf{NEW-V5}}
    \end{case}
  \end{proof}
\end{lemma}

\subsection{Type Soundness of Thorn Translation}

\begin{lemma}{Soundness of convertibility}{THT-COMP}
  \begin{conds}
    \cond{$\Convertible\K\t\tp$}\lbl{cond1}
    \cond{$\EnvTypeW\Env\K\e\t$}\lbl{cond2}
    \cond{$\ep = \TRG{\e}\Env$}\lbl{cond3}
    \cond{$\TR\K = \Kp$}\lbl{cond4}
    \cond{$\TR\Env = \Envp$}\lbl{cond5}
    \cond{$\EnvType\Envp\cdot\Kp{\ep}{\kty\t}$}\lbl{cond6}
  \end{conds}
  \then\axiom{$\EnvType\Envp\cdot\Kp{\TAG\e\Env{\tp}}{\kty\tp}$}

  \begin{proof}{ \indmsg{$\Convertible\K\t\tp$}}

  \begin{case}{STHC-SUB}
    \begin{case}{$\StrSub\cdot\Kp{\kty\t}{\kty\tp}$}
      \step{$\TAG\e\Env\tp = \ep$}{TTH7 on \trf{cond6}, case}\lbl{CS2}
      \step{$\EnvType\Envp\cdot\Kp{\TAG\e\Env{\tp}}{\kty\tp}$}{\RuleRef{KT-SUB} on case, \trf{CS2}, \trf{cond6}}
    \end{case}

    \begin{case}{$\StrNotSub\cdot\Kp{\kty\t}{\kty\tp}$}
      \step{$\TAG\e\Env\tp = \SubCast{\kty\tp}\ep$}{TTH8 on \trf{cond6}, case}\lbl{CS2}
      \step{$\EnvType\Envp\cdot\Kp{\SubCast{\kty\tp}\ep}{\kty\tp}$}{\RuleRef{KT-SUBCAST} on case, \trf{CS2}, \trf{cond6}}
    \end{case}
  \end{case}

  % WTS: \EnvType\Envp\cdot\Kp{\ep}{\any}
  \begin{case}{STHC-TOANY}
    \step{$\TAG\e\Env\any = \SubCast\any\ep$}{TTH8 on case}
    \step{$\EnvType\Envp\cdot\Kp{\SubCast\any\ep}{\any}$}{\RuleRef{KT-SUBCAST} on \trf{cond6}}
  \end{case}

  % WTS: \EnvType\Envp\cdot\Kp{\ep}{\C}
  \begin{case}{STHC-OPTCONC}
    \step{$\TAG\e\Env\C = \SubCast\C\ep$}{TTH8 on case}
    \step{$\EnvType\Envp\cdot\Kp{\SubCast\C\ep}{\C}$}{\RuleRef{KT-SUBCAST} on \trf{cond6}}
  \end{case}

  \begin{case}{STHC-ANYCONC}
    \step{$\TAG\e\Env{\t} = \SubCast{\kty\t}\ep$}{TTH8 on case}
    \step{$\EnvType\Envp\cdot\Kp{\SubCast{\kty\t}\ep}{\kty\t}$}{\RuleRef{KT-SUBCAST} on \trf{cond6}}
  \end{case}

  \end{proof}
\end{lemma}

\begin{lemma}{Type correctness of Thorn translation}{THT-TRANS}
  \begin{conds}
    \cond{$\WFpW\K\e$}\lbl{cond1}
    \cond{$\WFtypeW \K\t$}\lbl{cond2}
    \cond{$\HT\x\tp \in \Env \implies \WFtypeW\K\tp$}\lbl{cond3}
    \cond{\EnvTypeW\Env\K\e\t}\lbl{cond4}
    \cond{$\TR\K = \Kp$}\lbl{cond5}
    \cond{$\TR\Env = \Envp$}\lbl{cond6}
  \end{conds}

  \then\axiom{$\EnvType\Envp\cdot\Kp{\TRG{\e}\Env}{\kty\t}$}

  \begin{proof} \indmsg{\EnvTypeW\Env\K\e\t}

    \begin{case}{STH-VAR}
      \step{$\TRG{\x}\Env = \x$}{TTH1}\lbl{TSSL1}
      \step{$\EnvType\Envp\cdot\Kp\x{\kty\t}$}{\trf{cond6}, \RuleRef{KT-VAR}}\lbl{TSSL2}
      \done{\trf{TSSL2}}      
    \end{case}

    \begin{case}{STH-GET}
      \step{$\TRG{\FRead\f}\Env = \FRead\f$}{TTH2}\lbl{TSSL3}
      \step{$\EnvType\Envp\cdot\Kp{\FRead\f}{\kty\t}$}{\trf{cond5}, \RuleRef{KT-READ}}\lbl{TSSL4}
    \end{case}

    \begin{case}{STH-SET}
      \step{$\EnvTypeW\Env\K{\FWrite\f\e}\t$}{case}\lbl{TSSL5}
      \step{$\Convertible\K\tp\t$}{case}\lbl{TSSLC}
      \step{$\EnvTypeW\Env\K\e\tp$}{inversion on \trf{TSSL5}}\lbl{TSSL6}
      \slet{\ep}{\TRG\e\Env}\lbl{TSSA1}
      \step{$\EnvType\Envp\cdot\Kp\ep{\kty\tp}$}{IH on \trf{TSSL6}}\lbl{TSSL7}
      \slet{\epp}{{\TAG\e\Env{\t}}}\lbl{TSSA2}
      \step{$\EnvType\Envp\cdot\Kp\epp{\kty\t}$}{lemma \ref{lem:THT-COMP} on \trf{TSSL7}}\lbl{TSSL8}
      \step{$\TRG{\FWrite\f\e}\Env = \FWrite\f\epp$}{TTH3 on \trf{TSSA2},\trf{TSSL5},\trf{cond5}}\lbl{TSSL8}
      \step{$\EnvType\Envp\cdot\Kp{\FWrite\f\epp}{\kty\t}$}{\trf{TSSL8},\trf{TSSL5},\trf{cond5}, \RuleRef{KT-READ}}\lbl{TSSL9}
    \end{case}

    \begin{case}{STH-CALL}
      \step{$\EnvTypeW\Env\K{\Call{\e_1}\m{\ep_1}}\t$}{case}\lbl{THCA1}
      \step{$\EnvTypeW\Env\K{\e_1}{\t[a]}$}{case}\lbl{THCA2}
      \step{$\t[a] = \C \vee \t[a] = \CW$}{case}\lbl{TSSA5}
      \step{$\Mtype\m\tp\t \in \classoff\C\K$}{case}\lbl{THCA3}
      \step{$\EnvTypeW\Env\K{\ep_1}\tpp$}{case}\lbl{THCA4}
      \step{$\Convertible\K\tpp\tp$}{case}\lbl{THCA5}
      \slet{$\e_2$}{${\TRG{\e_1}\Env}$}\lbl{TSSA1}
      \slet{$\ep_2$}{${\TRG{\ep_1}\Env}$}\lbl{TSSA2}
      \step{$\EnvType\Envp\cdot\Kp{\e_2}{\kty{\t[a]}}$}{IH on \trf{THCA2}, \trf{TSSA1}}\lbl{THCA6}
      \step{$\EnvType\Envp\cdot\Kp{\ep_2}{\kty\tpp}$}{IH on \trf{THCA4}, \trf{TSSA2}}\lbl{THCA7}
      \slet{$\epp_2$}{${\TAG{\ep_1}\Env{\t[a]}}$}\lbl{TSSA3}
      \step{$\EnvType\Envp\cdot\Kp{\epp_2}{\kty\tp}$}{lemma \ref{lem:THT-COMP} on \trf{THCA5}, \trf{THCA7}}\lbl{THCA8}

      \begin{case}{$\t[a] = \C$}
        \step{$\TRG{\Call{\e_1}\m{\ep_1}}\Env = \KCall{\e_2}\m{\epp_2}{\kty\tp}{\kty\t}$}{TTH5 on \trf{THCA2},\trf{THCA8},\trf{THCA3}}
        \step{$\EnvType\Envp\cdot\Kp{\KCall{\e_2}\m{\epp_2}{\kty\tp}{\kty\t}}{\kty\t}$}{\trf{THCA6},\trf{THCA8},\trf{cond5},\RuleRef{KT-CALL}}\lbl{TSSL9}
      \end{case}

      \begin{case}{$\t[a] = \CW$}
        \step{$\TRG{\Call{\e_1}\m{\ep_1}}\Env = \DynCall{\e_2}\m{\epp_2}$}{TTH4 on \trf{THCA2},\trf{THCA8}}
        \step{$\EnvType\Envp\cdot\Kp{\KCall{\e_2}\m{\epp_2}{\kty\tp}{\kty\t}}{\kty\t}$}{\trf{THCA2},\trf{THCA8},\RuleRef{KT-DYNCALL}}\lbl{TSSL10}
      \end{case}
    \end{case}

    \begin{case}{STH-DCALL}
      \step{$\EnvTypeW\Env\K{\Call{\e_1}\m{\ep_1}}\t$}{case}\lbl{THCD1}
      \step{$\EnvTypeW\Env\K{\e_1}\any$}{case}\lbl{THCD2}
      \step{$\EnvTypeW\Env\K{\ep_1}\any$}{case}\lbl{THCD3}
      \slet{$\e_2$}{${\TRG{\e_1}\Env}$}\lbl{TSSD1}
      \slet{$\ep_2$}{${\TRG{\ep_1}\Env}$}\lbl{TSSD2}
      \step{$\TRG{\Call{\e_1}\m{\ep_1}}\Env = \DynCall{\e_2}\m{\ep_2}$}{TTH4 on \trf{TSSD1},\trf{THCD2},\trf{TSSD2}}\lbl{THCD4}
      \step{$\EnvType\Envp\cdot\Kp{\e_2}\any$}{IH on \trf{THCD2}}\lbl{THCD5}
      \step{$\EnvType\Envp\cdot\Kp{\ep_2}\any$}{IH on \trf{THCD3}}\lbl{THCD6}
      \step{$\EnvType\Envp\cdot\Kp{\DynCall{\e_2}\m{\ep_2}}{\kty\t}$}{\trf{THCD5},\trf{THCD6},\RuleRef{KT-DYNCALL}}\lbl{THCD9}
    \end{case}

    \begin{case}{STH-NEW}
      \step{$\EnvTypeW\Env\K{\New\C{\e_1,\ldots}}\t$}{case}\lbl{THCN1}
      \step{$\EnvTypeW\Env\K{\e_1}\tp_1 ~ \ldots$}{case}\lbl{THCN2}
      \step{$\Convertible\K{\tp_1}{\t_1} ~ \ldots$}{case}\lbl{THCN3}
      \slet{$\ep_i$}{${\TRG{\e_i}\Env}$ for all $i$}\lbl{TSSN1}
      \step{$\EnvType\Envp\cdot\Kp{\ep_i}{\kty{\tp_i}}$}{IH on \trf{THCN2}}\lbl{THCN4}
      \slet{$\epp_i$}{${\TAG{\ep_i}\Env{{\t_i}}}$ for all $i$}\lbl{TSSN2}
      \step{$\EnvType\Envp\cdot\Kp{\epp_i}{\kty{\t_i}}$}{lemma \ref{lem:THT-COMP} on \trf{TSSN2}, \trf{THCN2}}\lbl{THCN5}
      \step{$\TRG{\New\C{\e_1,\ldots}}\Env = \New\C{\epp_1,\ldots}$}{TTH6 on \trf{TSSD1},\trf{THCD2},\trf{TSSD2}}\lbl{THCN6}
      \step{$\EnvType\Envp\cdot\Kp{\New\C{\epp_1,\ldots}}{\kty\t}$}{\trf{THCN5},\RuleRef{KT-NEW}}\lbl{THCN7}
    \end{case}
  \end{proof}
\end{lemma}


\subsection{Type Soundness of Transient Translation}

\begin{lemma}{Soundness of Transient convertibility}{THTA-COMP}
  \begin{conds}
    \cond{$\ConvertE\K{tr}\t\tp$}\lbl{cond1}
    \cond{$\EnvTypeS\Env\K\e\t$}\lbl{cond2}
    \cond{$\ep = \TRG{\e}\Env$}\lbl{cond3}
    \cond{$\TR\K = \Kp$}\lbl{cond4}
    \cond{$\TR\Env = \Envp$}\lbl{cond5}
    \cond{$\EnvType\Envp\cdot\Kp{\ep}{\t}$}\lbl{cond6}
  \end{conds}
  \then\axiom{$\EnvType\Envp\cdot\Kp{\TAG\e\Env{\tp}}{\kty\tp}$}

  \begin{proof}{ \indmsg{$\Convertible\K\t\tp$}}

  \begin{case}{STC-SUB}
    \begin{case}{$\StrSub\cdot\Kp{\t}{\tp}$}
      \step{$\TAG\e\Env\tp = \ep$}{TTH7 on \trf{cond6}, case}\lbl{CS2}
      \step{$\EnvType\Envp\cdot\Kp{\TAG\e\Env{\tp}}{\kty\tp}$}{\RuleRef{KT-SUB} on case, \trf{CS2}, \trf{cond6}}
    \end{case}

    \begin{case}{$\StrNotSub\cdot\Kp{\t}{\tp}$}
      \step{$\TAG\e\Env\tp = \SubCast{\kty\tp}\ep$}{TTH8 on \trf{cond6}, case}\lbl{CS2}
      \step{$\EnvType\Envp\cdot\Kp{\SubCast{\kty\tp}\ep}{\kty\tp}$}{\RuleRef{KT-SUBCAST} on case, \trf{CS2}, \trf{cond6}}
    \end{case}
  \end{case}

  \begin{case}{STC-TOANY}
    \step{$\TAG\e\Env{\t} = \SubCast{\kty\t}\ep$}{TTH8 on case}
    \step{$\EnvType\Envp\cdot\Kp{\SubCast{\kty\t}\ep}{\kty\t}$}{\RuleRef{KT-SUBCAST} on \trf{cond6}}
  \end{case}

  \begin{case}{STC-OPTCONC}
    \step{$\TAG\e\Env{\t} = \SubCast{\kty\t}\ep$}{TTH8 on case}
    \step{$\EnvType\Envp\cdot\Kp{\SubCast{\kty\t}\ep}{\kty\t}$}{\RuleRef{KT-SUBCAST} on \trf{cond6}}
  \end{case}

  \end{proof}
\end{lemma}

\begin{lemma}{Type correctness of Transient translation}{THTA-TRANS}
  \begin{conds}
    \cond{$\WFpX\K\e{tr}$}\lbl{cond1}
    \cond{$\WFtypeX \K{tr}\t$}\lbl{cond2}
    \cond{$\HT\x\tp \in \Env \implies \WFtypeX\K{tr}\tp$}\lbl{cond3}
    \cond{\EnvTypeE\Env\K{tr}\e\t}\lbl{cond4}
    \cond{$\TR\K = \Kp$}\lbl{cond5}
    \cond{$\TR\Env = \Envp$}\lbl{cond6}
  \end{conds}

  \then\axiom{$\EnvType\Envp\cdot\Kp{\TRG{\e}\Env}{\t}$}

  \begin{proof} \indmsg{\EnvTypeW\Env\K\e\t}

    \begin{case}{STT-VAR}    
      \slet{$\ep$}{$\TRG{\x}\Env$}\lbl{STTVar1}
      \step{$\ep = \SubCast\t\x$}{TTR2 on \trf{cond4}, \trf{STTVar1}}
      \step{$\EnvType\Envp\cdot\Kp\x\any$}{\trf{cond5}, case}\lbl{STTVar2}
      \step{$\EnvType\Envp\cdot\Kp{\SubCast\t\x}\t$}{\RuleRef{KT-SUBCAST} on \trf{STTVar2}}
    \end{case}

    \begin{case}{STT-GET}
      \slet{$\ep$}{$\TRG{\FRead\f}\Env$}\lbl{STTGet1}
      \step{$\EnvType\Envp\cdot\Kp\this\C$}{\trf{cond5} on case}\lbl{STTGet2}
      \step{$\Fdef\f\any \in \App\Kp\C$}{\trf{cond6} on case}\lbl{STTGet3}
      \step{$\ep = \SubCast\t{\FRead\f}$}{TTR3 on case}
      \step{$\EnvType\Envp\cdot\Kp{\FRead\f}\any$}{\RuleRef{KT-
      READ} on \trf{STTGet2}, \trf{STTGet3}}\lbl{STTGet4}
      \step{$\EnvType\Envp\cdot\Kp{\SubCast\t{\FRead\f}}\t$}{\RuleRef{KT-SUBCAST} on \trf{STTGet4}}
    \end{case}

    \begin{case}{STT-SET}
      \slet{$\e_1$}{$\TRG{\FWrite\f\e}\Env$}\lbl{STTSet1}
      \slet{$\e_2$}{$\TRG{\e}\Env$}\lbl{STTSet2}
      \step{$\EnvType\Envp\cdot\Kp{\e_2}\t$}{IH on \trf{STTSet2}}\lbl{STTSet3}
      \slet{$\ep_2$}{$\TAG{\e_2}\Env\any$}\lbl{STTSet4}
      \step{$\e_1 = \SubCast\t{\FWrite\f{\ep_2}}$}{TTR4 on case, \trf{STTSet4}}
      \step{$\Fdef\f\any \in \App\Kp\C$}{\trf{cond6} on case}\lbl{STTSet6}
      \step{$\EnvType\Envp\cdot\Kp{\ep_2}\any$}{lemma \ref{lem:THTA-COMP} on \trf{STTSet4} and case}\lbl{STTSet7}
      \step{$\EnvType\Envp\cdot\Kp{\FWrite\f{\ep_2}}\any$}{\RuleRef{KT-WRITE} on \trf{cond5},\trf{STTSet6},\trf{STTSet7}}\lbl{STTSet8}
      \step{$\EnvType\Envp\cdot\Kp{\SubCast\t{\FWrite\f{\ep_2}}}\t$}{\RuleRef{KT-SUBCAST} on \trf{STTSet8}}\lbl{STTSet9}
    \end{case}

    \begin{case}{STT-CALL}
      \slet{$\e$}{$\TRG{\Call{\e_1}\m{\ep_1}}\Env$}\lbl{STTCall1}
      \slet{$\e_2$}{$\TRG{\e_1}\Env$}\lbl{STTCall2}
      \slet{$\ep_2$}{$\TRG{\ep_1}\Env$}\lbl{STTCall3}
      \slet{$\epp_2$}{$\TAG{\ep_1}\Env\any$}\lbl{STTCall4}
      \step{$\e = \SubCast\t{\KCall{\e_2}\m{\epp_2}\any\any}$}{TTR6 on case}
      \step{$\EnvType\Envp\cdot\Kp{\e_2}\C$}{IH on case}\lbl{STTCall5}
      \step{$\EnvType\Envp\cdot\Kp{\ep_2}\tpp$}{IH on case}\lbl{STTCall6}
      \step{$\EnvType\Envp\cdot\Kp{\epp_2}\any$}{lemma \ref{lem:THTA-COMP} on \trf{STTCall6}}\lbl{STTCall7}
      \step{$\Mtype\m\any\any \in \classoff\C\Kp$}{\trf{cond5}}\lbl{STTCall8}
      \step{$\EnvType\Envp\cdot\Kp{\KCall{\e_2}\m{\epp_2}\any\any}\any$}{\RuleRef{KT-CALL} on \trf{STTCall5},\trf{STTCall8},\trf{STTCall7}}\lbl{STTCall9}
      \step{$\EnvType\Envp\cdot\Kp{\SubCast\t{\KCall{\e_2}\m{\epp_2}\any\any}}\t$}{\RuleRef{KT-SUBCAST} on \trf{STTCall9}}
    \end{case}

    \begin{case}{STT-DCALL}
      \slet{$\e$}{$\TRG{\Call{\e_1}\m{\ep_1}}\Env$}\lbl{STTDCall1}
      \slet{$\e_2$}{$\TRG{\e_1}\Env$}\lbl{STTDCall2}
      \slet{$\ep_2$}{$\TRG{\ep_1}\Env$}\lbl{STTDCall3}
      \slet{$\epp_2$}{$\TAG{\ep_1}\Env\any$}\lbl{STTDCall4}
      \step{$\EnvType\Envp\cdot\Kp{\e_2}\any$}{IH on case}\lbl{STTDCall5}
      \step{$\EnvType\Envp\cdot\Kp{\ep_2}\tpp$}{IH on case}\lbl{STTDCall6}
      \step{$\EnvType\Envp\cdot\Kp{\epp_2}\any$}{lemma \ref{lem:THTA-COMP} on \trf{STTDCall3},\trf{STTDCall6}, case}\lbl{STTDCall7}
      \step{$\e = {\DynCall{\e_2}\m{\epp_2}}$}{TTR5 on case}
      \step{$\EnvType\Envp\cdot\Kp{\DynCall{\e_2}\m{\epp_2}}\any$}{\RuleRef{KT-DYNCALL} on \trf{STTDCall5}, \trf{STTDCall7}}\lbl{STTCall8}
    \end{case}

    \begin{case}{STT-NEW}
      \slet{$\e$}{$\TRG{\New\C{\e_i \ldots}}\Env$}\lbl{STTNew1}
      \slet{$\ep_i$}{$\TRG{\e_i}\Env$}\lbl{STTNew2}
      \slet{$\epp_i$}{$\TAG{\e_i}\Env{\t_i}$}\lbl{STTNew3}
      \step{$\EnvType\Envp\cdot\Kp{\ep_i}{\tp_i}$}{IH on case}\lbl{STTNew4}
      \step{$\Fdef{\f_i}\any \ldots \in \App\Kp\C$}{\trf{cond4}}\lbl{STTNew5}
      \step{$\EnvType\Envp\cdot\Kp{\epp_i}{\t_i}$}{lemma \ref{lem:THTA-COMP} on \trf{STTNew4}, case}\lbl{STTNew6}
      \step{$\EnvType\Envp\cdot\Kp{\New\C{\epp_i \ldots}}{\C}$}{\RuleRef{KT-NEW} on \trf{STTNew6}}
    \end{case}
  \end{proof}
\end{lemma}
\end{document}
