\documentclass[]{article}
\usepackage{stmaryrd} 
\usepackage{xspace,listings,url,framed,amssymb,
	mathpartir,hyperref,doi, mathtools,wrapfig,
	stmaryrd, graphicx, tikz, colortbl, xparse, etoolbox,
	pgffor, makecell, microtype}
\usepackage[customcolors,norndcorners]{hf-tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{shapes.multipart}
\usetikzlibrary{positioning}
\usetikzlibrary{calc}
\usetikzlibrary{backgrounds}
\usepackage[inline]{enumitem}
\usepackage{epigraph}
\setlength{\epigraphrule}{0pt}
\renewcommand*{\textflush}{flushright}
\setlength{\epigraphwidth}{4in}
\newcommand{\code}[1]{{\tt #1}\xspace}
\newcommand{\FZ}[1]{\textbf{FZ: #1}}
\input{macros}

%opening
\title{README for Kafka artifact}
\author{}
\date{}


\begin{document}

\maketitle

\section{Kafka's .Net implementation}

Our Kafka and native translation implementations are written in F$\#$. The folder kafkaimpl contains the translation from the surface source language to kafka, the translation from kafka to CIL, and the type checker for Kafka. The folder kafkatests contains unit tests for the kafka implementation. The implementation of Kafka follows the same syntax and semantics as those presented in figure 3 and 4 of the paper. The implementation of our translation from the source language to Kafka follows the rules presented in section 5 of the paper. We strongly recommend loading, building, and running this implementation within Microsoft Visual Studio, it is by far the simplest and easiest option. 

To run this implementation, it takes two command line variables. The gradual semantics you wish to use and the name path of the file which contains the code that you wish to run. 'beh' is the option for the behavioral semantics, 'opt' for the optional semantics, 'tra' for the transient semantics, and 'con' for the concrete semantics. The three litmus tests presented in the paper are readily available to be ran, and they are in the files: litmus1.txt, litmus2.txt, litmus3.txt. It is possible for the user to pass in a file of their own design.

% what the litmus tests actually means
The result of each litmus test under each gradual semantics reflect the behavior expressed in section 3 of our paper.


\section{Kafka's Coq proof}

We have proved type soundness for Kafka in Coq, the kafka.v file in the impl folder is the self-contained Coq 8.6 proof for KafKa. It is important that the version of Coq must be 8.6, otherwise any Coq IDE will work including the command line.

Theorem 1 (page 14) in the paper corresponds to the Coq theorem \\

Soundness: $\forall$ $\K$ $\e$ $\s$ $\t$,

WellFormedState $\K$ $\e$ $\s$ $\rightarrow$ HasType \texttt{nil} $\s$ $\k$ $\e$ $\t$ $\rightarrow$ is$\_$sound $\k$ $\s$ $\e$ $\t$ .

HasType \texttt{nil} $\s$ $\k$ $\e$ $\t$ \textit{corresponds to} \texttt{nil} $\s$ $\k$ $\vdash$ $\e$ : $\t$ \\

The WellFormedState statement combines well-typedness of the class table and the running expression with heap typing. \\

There are three holes in the proof, in kafka.v:
\begin{itemize}
\item Transitivity of structural recursive subtyping (line number: 342)
\item Soundness of subtyping (line number: 350)
\item That subtyping still holds when the class table is expanded (line number: 642)
\end{itemize}
	
The first two components are well-known prior work (e.g. A Mechanical Soundness Proof for Subtyping Over Recursive Types, Jones 2016). 
The third property simply requires that pre-existing subtyping judgments still hold when the class table is expanded.



\section{Installation for the native languages}

In section 4 of this document, we present each of the three litmus tests in the native code of the four gradual languages of TypeScript, Thorn, Typed Racket, and Reticulated Python. In this section, we will discuss how to install each of the native language that is required to run the native litmus tests.

\subsection{TypeScript}

For TypeScript, all the information regarding the language and the process of installment can be found at https://www.typescriptlang.org/.

\subsection{Thorn}

Unfortunately, there does not exist a public implementation of Thorn that is readily available. The Thorn skeleton, which we obtained through private means, was heavily savaged from bit rot and decay, and was not easily installable nor it contain all the necessary components, such as the thorn type checker.

\subsection{Typed Racket}

For Typed Racket, first you would need to install the Racket IDE called DrRacket, which can be found at https://docs.racket-lang.org/getting-started/index.html. In order to write a Typed Racket module within DrRacket you would be required to follow the three steps outlined at: https://docs.racket-lang.org/ts-guide/quick.html.


\subsection{Reticulated Python}

The information regarding the installment and running of Reticulated Python can be found at: https://github.com/mvitousek/reticulated. It requires Python version 3.5 or older. 


\section{Litmus tests in native languages}

Below we present source code for each of the litmus tests. If time permits, we would have loved to have to these litmus tests placed on an image. However, for the moment, you are required to copy and paste these code into their corresponding native implementation. We apologies for any inconvenience this has caused. 

\subsection*{Concrete}

The code for the litmus tests in Thorn. \\ 

\noindent
\textbf{Litmus Test 1}:
\begin{verbatim}
class A() { def m(x:A):A = this; }
class I() { def n(x:I):I = this; }
class T() {
def s(x:I):T = this;
def t(x:dyn):dyn = this.s(x);
}
T().t(A());
\end{verbatim}

\noindent
\textbf{Litmus Test 2}:
\begin{verbatim}
class Q() { def n(x: Q): Q = this;}
class A() { def m(x:A): A = this;}
class I() { def m(x:Q):I = this;}
class T() {
def s(x:I):T = this; 
def t(x:dyn):dyn = this.s(x);
}
T().t(A());   
\end{verbatim}


\noindent\textbf{Litmus Test 3}:
\begin{verbatim}
class C() { def m(x:C):C = x; }
class D() { def n(x:D):D = x; }
class E() { def m(x:D):D = x; }      
class F() {
def m(x:E):E = x;
def n(x:dyn):dyn = this.m(x);
} 
F().n(C()).m(C());
\end{verbatim}

\subsection*{Optional}

The code for the litmus tests in TypeScript. \\

\noindent\textbf{Litmus Test 1}:
\begin{verbatim}
class A { m(x: A): A { return this } }
class I { n(x:I):I { return this } }
class T {
s(x: I): T { return this }
t(x: any): any { return this.s(x) }
}
new T().t(new A())
\end{verbatim}

\noindent\textbf{Litmus Test 2}:
\begin{verbatim}
class Q { n(x: Q): Q { return this } }
class A { m(x: A): A { return this } }
class I { m(x:Q):I { return this } }
class T {
s(x: I): T { return this }
t(x: any): any { return this.s(x) }
}
new T().t(new A())
\end{verbatim}

\noindent\textbf{Litmus Test 3}:
\begin{verbatim}
class C { m(x: C): C { return x } }
class D { n(x: D): D { return x } }
class E { m(x: D): D { return x } }
class F {
m(x: E): E { return x }
n(x: any): any { return this.m(x) }
}
new F().n(new C()).m(new C())
\end{verbatim}

\subsection*{Behavioral}

The code for the litmus tests in Typed Racket. \\

\noindent\textbf{Litmus Test 1}:

\begin{verbatim}
#lang racket
(module u racket
(define Tp% (class object%
(super-new)
(define/public (t x) (send this s x))))
(provide Tp%))
(module t typed/racket
(require/typed (submod ".." u) [Tp% (Class [t (-> Any Any)])])
(define-type A (Instance (Class (m (-> A A)))))
(define-type I (Instance (Class (n (-> I I)))))
(define-type T (Instance (Class (s (-> I T)))))
(define T% (class Tp%
(super-new)
(: s (-> I T))
(define/public (s x) this)))
(define A% (class object%
(super-new)
(: m (-> A A))
(define/public (m x) this)))
(provide T% A%))
(require 't)
(send (new T%) t (new A%))
\end{verbatim}

\noindent\textbf{Litmus Test 2}:

\begin{verbatim}
#lang racket
(module u racket
(define Tp% (class object%
(super-new)
(define/public (t x) (send this s x))))
(provide Tp%))
(module t typed/racket
(require/typed (submod ".." u) [Tp% (Class [t (-> Any Any)])])
(define-type Q (Instance (Class (n (-> Q Q)))))
(define-type A (Instance (Class (m (-> A A)))))
(define-type I (Instance (Class (m (-> Q I)))))
(define-type T (Instance (Class (s (-> I T)))))
(define T% (class Tp%
(super-new)
(: s (-> I T))
(define/public (s x) this)))
(define A% (class object%
(super-new)
(: m (-> A A))
(define/public (m x) this)))
(provide T% A%))
(require 't)
(send (new T%) t (new A%))
\end{verbatim}

\noindent\textbf{Litmus Test 3}:

\begin{verbatim}
#lang racket
(module u racket
(define Fp% (class object%
(super-new)
(define/public (n x) (send this m x))))
(provide Fp%))
(module t typed/racket
(require/typed (submod ".." u) [Fp% (Class [n (-> Any Any)])])
(define-type C (Instance (Class (m (-> C C)))))
(define-type E (Instance (Class (m (-> D D)))))
(define-type D (Instance (Class (n (-> D D)))))
(define F% (class Fp%
(super-new)
(: m (-> E E))
(define/public (m x) x)))
(define C% (class object%
(super-new)
(: n (-> C C))
(define/public (n x) x)))
(provide F% C%))
(require 't)
(send (send (new F%) n (new C%)) m (new C%))
\end{verbatim}


\subsection*{Transient}

The code for the litmus tests in Transient Reticulated Python. \\

\noindent\textbf{Litmus Test 1}:
\begin{verbatim}
class A:
def m(self, x:A) -> A:
return self
class I:
def n(self, x:I) -> I:
return self
class T:
def s(self, x:I) -> T:
return self
def t(self, x:Dyn) -> Dyn:
return self.s(x)
T().t(A())
\end{verbatim}

\noindent
\textbf{Litmus Test 2}:
\begin{verbatim}
class C:
def n(self, x:C) -> C:
return self
class Q:
def m(self, x:Q) -> Q:
return self     
class A:
def m(self, x:A) -> A:
return self
class I:
def m(self, x:Q) -> I:
return self
class T:
def s(self, x:I) -> T:
return self
def t(self, x:Dyn) -> Dyn:
return self.s(x)
T().t(A())
\end{verbatim}

\noindent\textbf{Litmus Test 3}:
\begin{verbatim}
class C:
def m(self, x:C) -> C:
return x
class D:
def n(self, x:D) -> D:
return x
class E:
def m(self, x:D) -> D:
return x
class F:
def m(self, x:E) -> E:
return x   
def n(self, x:Dyn) -> Dyn:
return self.m(x)
F().n(C()).m(C())
\end{verbatim}


\end{document}
