\documentclass[]{article}

%opening
\title{README for Kafka artifact}
\author{}
\date{}

\begin{document}

\maketitle

\section{Kafka's .Net implementation and what it means}

The Kafka implementation is written in F$\#$. The implementation follows the same syntax and semantics as those presented in figure 3 and 4 of the paper. Explain how to build it, how to run it, which tests to run, and what the result of the tests mean. The litmus tests have been translated into each of the gradual semantics (optional, behavioral, transient, concrete).

beh is for behavioral
opt is for optional
tra is for transient
con is for concrete

litmus1, litmus2, litmus3, or pass in a code example or pass in a file.

\section{Coq and what its result means}


\section{How to install each native languages}

In section \ref{litmus}, we present each of the three litmus tests in the native code of the four gradual languages of TypeScript, Thorn, Typed Racket, and Reticulated Python. In this section, we will discuss how to install each of the native language that is required to run the native litmus tests.

\subsection{TypeScript}

For TypeScript, all the information regarding the language and the process of installment can be found at https://www.typescriptlang.org/.

\subsection{Thorn}

Unfortunately, there does not currently exist a public implementation of Thorn that is readily available. The Thorn skeleton, which we obtained through private means, was heavily savaged from bit rot and decay, and was not easily installable nor it contain all the necessary components, such as the thorn type checker.

\subsection{Typed Racket}

For Typed Racket, first you would need to install the Racket IDE called DrRacket, which can be found at https://docs.racket-lang.org/getting-started/index.html. In order to write a Typed Racket module within DrRacket you would be required to follow the three steps outlined at: https://docs.racket-lang.org/ts-guide/quick.html.


\subsection{Reticulated Python}

The information regarding the installment and running of Reticulated Python can be found at: https://github.com/mvitousek/reticulated. It requires Python version 3.5 or older. 


\section{Litmus tests in native languages}\label{litmus}

Below we present source code for each of the litmus tests. If time permits, we would have loved to have to these litmus tests placed on an image. However, for the moment, you are required to copy and paste these code into their corresponding native implementation. We apologies for any inconvenience this has caused. 

\subsection*{Concrete}

The code for the litmus tests in Thorn. \\ 

\noindent
\textbf{Litmus Test 1}:
\begin{verbatim}
class A() { def m(x:A):A = this; }
class I() { def n(x:I):I = this; }
class T() {
def s(x:I):T = this;
def t(x:dyn):dyn = this.s(x);
}
T().t(A());
\end{verbatim}

\noindent
\textbf{Litmus Test 2}:
\begin{verbatim}
class Q() { def n(x: Q): Q = this;}
class A() { def m(x:A): A = this;}
class I() { def m(x:Q):I = this;}
class T() {
def s(x:I):T = this; 
def t(x:dyn):dyn = this.s(x);
}
T().t(A());   
\end{verbatim}


\noindent\textbf{Litmus Test 3}:
\begin{verbatim}
class C() { def m(x:C):C = x; }
class D() { def n(x:D):D = x; }
class E() { def m(x:D):D = x; }      
class F() {
def m(x:E):E = x;
def n(x:dyn):dyn = this.m(x);
} 
F().n(C()).m(C());
\end{verbatim}

\subsection*{Optional}

The code for the litmus tests in TypeScript. \\

\noindent\textbf{Litmus Test 1}:
\begin{verbatim}
class A { m(x: A): A { return this } }
class I { n(x:I):I { return this } }
class T {
s(x: I): T { return this }
t(x: any): any { return this.s(x) }
}
new T().t(new A())
\end{verbatim}

\noindent\textbf{Litmus Test 2}:
\begin{verbatim}
class Q { n(x: Q): Q { return this } }
class A { m(x: A): A { return this } }
class I { m(x:Q):I { return this } }
class T {
s(x: I): T { return this }
t(x: any): any { return this.s(x) }
}
new T().t(new A())
\end{verbatim}

\noindent\textbf{Litmus Test 3}:
\begin{verbatim}
class C { m(x: C): C { return x } }
class D { n(x: D): D { return x } }
class E { m(x: D): D { return x } }
class F {
m(x: E): E { return x }
n(x: any): any { return this.m(x) }
}
new F().n(new C()).m(new C())
\end{verbatim}

\subsection*{Behavioral}

The code for the litmus tests in Typed Racket. \\

\noindent\textbf{Litmus Test 1}:

\begin{verbatim}
#lang racket
(module u racket
(define Tp% (class object%
(super-new)
(define/public (t x) (send this s x))))
(provide Tp%))
(module t typed/racket
(require/typed (submod ".." u) [Tp% (Class [t (-> Any Any)])])
(define-type A (Instance (Class (m (-> A A)))))
(define-type I (Instance (Class (n (-> I I)))))
(define-type T (Instance (Class (s (-> I T)))))
(define T% (class Tp%
(super-new)
(: s (-> I T))
(define/public (s x) this)))
(define A% (class object%
(super-new)
(: m (-> A A))
(define/public (m x) this)))
(provide T% A%))
(require 't)
(send (new T%) t (new A%))
\end{verbatim}

\noindent\textbf{Litmus Test 2}:

\begin{verbatim}
#lang racket
(module u racket
(define Tp% (class object%
(super-new)
(define/public (t x) (send this s x))))
(provide Tp%))
(module t typed/racket
(require/typed (submod ".." u) [Tp% (Class [t (-> Any Any)])])
(define-type Q (Instance (Class (n (-> Q Q)))))
(define-type A (Instance (Class (m (-> A A)))))
(define-type I (Instance (Class (m (-> Q I)))))
(define-type T (Instance (Class (s (-> I T)))))
(define T% (class Tp%
(super-new)
(: s (-> I T))
(define/public (s x) this)))
(define A% (class object%
(super-new)
(: m (-> A A))
(define/public (m x) this)))
(provide T% A%))
(require 't)
(send (new T%) t (new A%))
\end{verbatim}

\noindent\textbf{Litmus Test 3}:

\begin{verbatim}
#lang racket
(module u racket
(define Fp% (class object%
(super-new)
(define/public (n x) (send this m x))))
(provide Fp%))
(module t typed/racket
(require/typed (submod ".." u) [Fp% (Class [n (-> Any Any)])])
(define-type C (Instance (Class (m (-> C C)))))
(define-type E (Instance (Class (m (-> D D)))))
(define-type D (Instance (Class (n (-> D D)))))
(define F% (class Fp%
(super-new)
(: m (-> E E))
(define/public (m x) x)))
(define C% (class object%
(super-new)
(: n (-> C C))
(define/public (n x) x)))
(provide F% C%))
(require 't)
(send (send (new F%) n (new C%)) m (new C%))
\end{verbatim}


\subsection*{Transient}

The code for the litmus tests in Transient Reticulated Python. \\

\noindent\textbf{Litmus Test 1}:
\begin{verbatim}
class A:
def m(self, x:A) -> A:
return self
class I:
def n(self, x:I) -> I:
return self
class T:
def s(self, x:I) -> T:
return self
def t(self, x:Dyn) -> Dyn:
return self.s(x)
T().t(A())
\end{verbatim}

\noindent
\textbf{Litmus Test 2}:
\begin{verbatim}
class C:
def n(self, x:C) -> C:
return self
class Q:
def m(self, x:Q) -> Q:
return self     
class A:
def m(self, x:A) -> A:
return self
class I:
def m(self, x:Q) -> I:
return self
class T:
def s(self, x:I) -> T:
return self
def t(self, x:Dyn) -> Dyn:
return self.s(x)
T().t(A())
\end{verbatim}

\noindent\textbf{Litmus Test 3}:
\begin{verbatim}
class C:
def m(self, x:C) -> C:
return x
class D:
def n(self, x:D) -> D:
return x
class E:
def m(self, x:D) -> D:
return x
class F:
def m(self, x:E) -> E:
return x   
def n(self, x:Dyn) -> Dyn:
return self.m(x)
F().n(C()).m(C())
\end{verbatim}


\end{document}
