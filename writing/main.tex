\documentclass[a4paper,USenglish]{tex/lipics-v2016}
\usepackage{xspace,listings,url,framed,amssymb,colortbl,
            amsmath,tex/mathpartir,hyperref,doi,
            stmaryrd, graphicx, tikz, colortbl, xparse} % double brackets llbracket
\usepackage[customcolors,norndcorners]{hf-tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{shapes.multipart}
\usetikzlibrary{positioning}
\usetikzlibrary{calc}
\usetikzlibrary{backgrounds}
\input{macros}

\definecolor{Gray}{gray}{0.9}

\usepackage{epigraph}
\setlength{\epigraphwidth}{0.75\linewidth}
\setlength{\epigraphrule}{0pt}
\renewcommand*{\textflush}{flushright}
\renewcommand*{\epigraphsize}{\normalsize\itshape}

\definecolor{vlightgray}{gray}{0.93}

\lstdefinelanguage{JavaScript}{
  keywords={typeof,new,true,false,instanceof,catch,function,return,null, 
    catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{darkgray},
  ndkeywords={class,def,interface,export,boolean,throw,extends,implements,import,this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,  comment=[l]{//},  morecomment=[s]{/*}{*/},
  commentstyle=\color{gray}\ttfamily,  stringstyle=\color{gray}\ttfamily,
  morestring=[b]',  morestring=[b]",
  backgroundcolor=\color{vlightgray},
  aboveskip=\medskipamount, %0em,
  belowskip=\smallskipamount %0em
}
\lstset{
  language=JavaScript,  extendedchars=true,  basicstyle=\footnotesize\ttfamily,
  showstringspaces=false,   showspaces=false,  numberstyle=\small,
  numbersep=9pt,  tabsize=2, breaklines=true,  showtabs=false, captionpos=b
}

\renewcommand{\u}[1]{\underline{#1}\xspace}

\usepackage[textsize=tiny]{todonotes}

% Author macros::begin %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Gradual Types for Objects Redux}
\titlerunning{Gradual Types for Objects Redux}
%% provide for each author the \author and \affil macro, even if same
\author[1]{Ano Nymous, et al.}
%% Benjamin Chung, Paley Li, Jan Vitek
%\affil[1]{}
\authorrunning{Anon} %mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et. al.'
\Copyright{Anon}%mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/
%\subjclass{Dummy classification -- please refer to \url{http://www.acm.org/about/class/ccs98-html}}% mandatory: Please choose ACM 1998 classifications from http://www.acm.org/about/class/ccs98-html . E.g., cite as "F.1.1 Models of Computation". 
%\keywords{Dummy keyword -- please provide 1--5 keywords}% mandatory: Please provide 1-5 keywords
% Author macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Editor-only macros:: begin (do not touch as author)%%%%%%%%
\EventEditors{Anon}
\EventNoEds{2}
\EventLongTitle{}
\EventShortTitle{ECOOP 2017}
\EventAcronym{ECOOP}
\EventYear{2017}
\EventDate{}
\EventLocation{}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
% Editor-only macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}
\maketitle

\begin{abstract}
The enduring popularity of dynamically typed languages has given rise to a
cottage industry of static type systems, \emph{gradual type systems}, that
let developers annotate legacy code piecemeal. Soundness for a program which
mixes typed and untyped code means that some errors will caught at type
checking time, while other will be caught as the program executes. After a
decade of research it is clear that the combination of mutable state, self
references and subtyping presents serious challenges to implementers.  This
paper reviews the state of the art in gradual typing for objects. We
introduce \kafka, a class-based object calculus with a static type system,
dynamic method dispatch, transparent wrappers and dynamic class
generation. We model key features of several gradual type systems by
translation to \kafka and discuss the implications of the respective
designs.
\end{abstract} 



\section{Introduction}

\vspace{-5mm}

\epigraph{``Because half the problem is seeing the problem''}

\vspace{-5mm}

\noindent
A decade ago Siek and Taha~\cite{SiekTaha07} presented a gradual type system
for a variant of Abadi and Cardelli's object-based
calculus~\cite{cardelli:1996:theory-of-objects}. Their system featured a
dynamic type, denoted \any, and a subtype relation that combined structural
subtyping with a consistency relation between terms that differ in dynamic
type annotations.  Soundness at the boundaries between typed and untyped
code is ensured by inserting casts as shown in their previous work for
functional languages~\cite{SiekTaha06}.  Ten years later, many systems
support the gradual addition of types to untyped object-oriented
programs.\footnote{Languages which allow mixing typed and untyped with
  objects include
%%
C\#~\cite{Bierman10},
Dart~\cite{dart13}, 
DRuby~\cite{FurrAF2009},
Hack~\cite{hack13}, 
Gradualtalk~\cite{GS13},
Reticulated Python~\cite{siek14}, 
Safe Typescript~\cite{safe-typescript},
StrongScript~\cite{ecoop15}, 
Thorn~\cite{oopsla09}, 
Typed Racket~\cite{Takikawa:2012}, 
TypeScript~\cite{BAT14}.}
%%
Yet, faithful realizations of Seik and Taha's elegant idea have proved to be
surprisingly elusive.  One possible reason being that the original paper did
not consider state.  The combination of mutable state, aliasing and
subtyping complicates enforcement strategies as one must consider situations
where an object is being accessed at different types. While several
solutions have been proposed to address this, the performance implications
of the implementation strategies of these solutions seem
daunting.\footnote{Most practical \emph{sound} type system reports order of
  magnitude pathologies, e.g.~5x slow downs for
  Gradualtalk~\cite{allende13}, 10x for Reticulated Python~\cite{siek14},
  22x for Safe Typescript~\cite{safe-typescript}, and 121x for Typed
  Racket~\cite{popl16}. These numbers merely indicate the existence of
  configurations that hurt performance.  They are neither comparable nor
  worst case indicators.  Most systems lack rigorous evaluations.  }
Predictably, developers of industrial languages have chosen to compromise on
soundness to avoid degrading performance.\footnote{ Dart, Typescript and
  Hack have unchecked modes that won't catch all type errors neither statically
or dynamically.}

This paper explores the design space of gradual type system for
object-oriented languages. We aim to expose some of the forces that have
influenced existing systems and discuss the implication of key design
decisions. While there are significant challenges that, in the end, may
prevent adoption of some of the more ambitious type systems, there are are
also opportunities for improving on existing techniques.  This paper also
aims to lay the agenda for future investigations.

To capture the essence of gradual typing for objects and highlight the
challenges implementers face, we present translations of gradual type system
into a common target language. Targeting the same language lets us reason
about the type systems in the same framework and allows for comparison. But
which language should we target? The language should avoid linguistic
clutter while expressing key object-oriented features directly rather than
by encoding. We propose to target a typed object-oriented language inspired
by modern language runtimes such as the Java Virtual Machine and .Net.  They
have a static type system with classes and subtyping but they also allow for
dynamic resolution of method dispatch.\footnote{Both runtimes support
  reflective invocation based on method names. Dynamic resolution was added
  to C\# in version 4.0~\cite{BAT14}. In Java, \xt{invokedynamic} allows for
  custom method dispatch.} As well as reasonably efficient implementations,
and in both environments, primitive types can be unboxed as the static
typing an accurately final types.

A contribution of this work is the design of \kafka, a statically typed
object calculus.  \kafka is class based (with an explicit class table \K),
with mutable state (a heap address \a refers to an object, each field \f is
reifed into a pair of getter and setter methods), and allows the dynamic
generation of wrapper classes (by update of the class table \K and
allocation of new objects \a).  Methods can be statically resolved, denoted
by a simple call \Call\a\m\x, or can be dynamically resolved, denoted by a
dynamic call \DynCall\a\m\x. The \kafka type system is based on structural
type equivalence (although not essential, it could just as well use nominal
types with multiple subtyping \`a la Java).  The dynamic type is written
\any. To support transparent wrappers, a distinguished \that field is
available to wrapper classes but does not show up in type
signatures.

The heart of any gradual type system implementation is the explicit casts
that are inserted at type boundaries.  Two different \emph{structual} casts
are built-in to \kafka; they only inspect the structure of objects.  The
subtype cast \SubCast\t\a is a structural cast that checks if the object
references by \a is a subtype of type \t, \t can be either a class \C or the
dynamic type \any.  The shallow cast \ShaCast\t\a merely checks that the
object has all the methods of type \t without looking at their signatures.
\kafka also supports two \emph{generative} casts which create new wrapper
classes.  The behavioral cast \BehCast\t\a generates a wrapper object that
monitors that methods invoked on \a abide by the interface of type \t. The
monotone cast \MonCast\t\a returns a wrapper monitoring all invocations to
the object referenced by \a, furthermore this wrapper can only be refined by
removing occurences of \any in its type.

Another contribution is the translation of five type systems representative
of the main strains of gradual typing for objects. Each gradually typed
expression \HT{\u\e}{\u\T} in the source is translated to a well-typed
\kafka term, \HT\e\T, each type \u\T has a corresponding \kafka type \T,
and, similarly, each expression \u\e has an equivalent \e. While soundness
in \kafka is straightforward (except for generative casts), soundness of the
source gradual type systems is more interesting.  In \kafka, a well-typed
program can only get stuck at a cast or a dynamically resolved call.  With
gradual types, an expression \Call{\u\x}\m{\u{\x'}} where \u\x is declared
to be of class \u\C can have significantly different behavior depending on
choices made while designing the gradual type system. TypeScript has
\emph{optional types}; a well-typed program can get stuck at any method call
as \u\C translates to \any. Thorn has \emph{concrete types}; a well-typed
program will not get stuck at statically resolved method calls, and \u\C
maps to itself \C. Typed Racket has \emph{promised types}; a well-typed
program will not get stuck at a call to \m, because \u\x refers to an
object, or wrapper, that implements \m.  Wrappers may fail if their target
does not behave like a \u\C. Finally we describe the monotonic
and transient variants of Reticulated Python which have somewhat surprising
semantic properties.


\section{Background}


\vspace{-5mm}

\epigraph{ ``If you know the enemy and know yourself...''}

\vspace{-5mm}

\noindent The intellectual lineage of gradual types can be traced back to
attempts to add types to Smalltalk and LISP. A highlight on the Smalltalk
side is the Strongtalk optional type system~\cite{Bracha93} which led to
Bracha's notion of pluggable types~\cite{pluggabletypes}. For him, types are
solely to catch errors at checking time, they should never affect the
runtime behavior of programs. The rationale for this is that types are
viewed as an add-on that can be turned off without affecting semantics.  In
the words of Richards~\emph{et al.}~\cite{ecoop15}, an optional type system
is \emph{trace preserving}, which means that if a term \e reduces to value
\a, adding type annotations will never cause \e to get stuck. This property
is valuable to developers as it prevents type annotations from introducing
errors, also it follows that type annotations do not effect performance. The
optional type systems currently in wide use include Hack~\cite{hack13},
TypeScript~\cite{BAT14} and Dart~\cite{dart13}.  StrongScript~\cite{ecoop15}
and Thorn~\cite{popl10} allow programmers to choose between optional and
concrete types.

On the functional side, the ancestry is dominated by the work of Felleisen
and his students.  The Typed Scheme~\cite{tf-popl08} design that later
became Typed Racket is strongly influenced by their earlier work on
higher-order contracts~\cite{ff-icfp02}. Typed Racket was envisioned as a
vehicle for teaching programming to high-school students and undergraduates.
For that reason, being able to explain the source of errors was viewed as an
important design constraint as well as preventing surprises -- a variable
annotated as a \C should behave as a \C. If it doesn't, then that should be
reported at the first discrepancy. The approach to typing is thus quite
different from optional types. In Typed Racket, whenever a value crosses a
boundary between typed and untyped code, the value will be wrapped in a
contract that monitors it's behavior. This allows to ensure that the type of
mutable values remains consistent with their declared type and that
functions respect their declared interface. When a value misbehaves, blame
can be assigned to module where the value originated. In Typed Racket, the
granularity of typing is the module, thus each module is either entirely
typed or entirely untyped.

Siek and Taha coined the term gradual typing in~\cite{SiekTaha06} as any
type system that allows programmers to control the degree of static checking
for a program by choosing to annotate function parameters with types, or
not. Their contribution was formalization in a lambda calculus with
references and a proof of soundness that stated that all type errors would
be caught. They defined the type consistency relation $\t \sim \tp$ which
states that a type that agree on non-\any position are compatible.  In their
follow up~\cite{SiekTaha07} they extended the work to a stateless object
calculus and combined consistency with structural subtyping. Extending the
approach to mutable objects proved challenging. Reticulated
Python~\cite{siek14} attempts to find a reasonable compromise between
soundness and efficiency.  The language has three modes: in \emph{guarded}
mode, Python behaves as Typed Racket with contracts applied to values,
\emph{transient} mode performs first order checks before each call, and the
\emph{monotonic} mode is similar to guarded except there is at most one
wrapper per object and casts can only remove occurences of \any from its
type.

Other noteworthy systems include Gradualtalk~\cite{GS13}, C\#
4.0~\cite{Bierman10}, Thorn~\cite{oopsla09},
StrongScript~\cite{ecoop15}. Gradualtalk is a variant of Smalltalk with
Felleisen-style contracts and mostly nominal type equivalence. C\# 4.0 adds
the type {\sf dynamic} (i.e.~\any) to the language and dynamically resolved
method invocation when the receiver is of type \any.  This means C\# has a
dynamic sublanguage that allows developer to write unchecked code, but it
also has a strongly type sublanguage in which values are guaranteed to be of
their declared type.  Thorn and StrongScript extend the C\# approach with
the addition of optional types (called like types).  Thorn is a new language
implemented by translation to the JVM.\footnote{The translation strategy is
  quite close to that presented here.} The presence of concrete types means
that the compiler can optimize code (unbox data and inline methods) and
programmers are guaranteed that type errors will not occur within concretely
typed code.  StrongScript takes Thorn and reimplements it within the context
of TypeScript.  The interesting design choices there are that while
TypeScript originally relied on structural subtyping, StrongScript changed
the language to follow a nominal discipline. It is interesting to note that
this change did not affect the semantics of benchmark
applications. Moreover, to deal with higher-order functions which TypeScript
inherits from JavaScript, the language does use contract for functions.


\subsection{Surveying the design space}

\figref{over} gives a synthetic overview of systems with publicly available
implementations. All languages here are class-based, except TypeScript which
also has types for plain JavaScript objects. Most languages base subtyping
on the name of classes and on explicit subtype declarations, rather than on
structural similarities between classes.  Exceptions include Gradualtalk
which is nominal but also supports structural subtype if programmers want to
use it.  TypeScript uses structural subtyping, but does not implement a
runtime structural check. This is probably because of the JavaScript roots
of the language, annecdotal evidence suggests that structural subtyping is
not always exercised~\cite{ecoop15}.  The consistency relation used in
Reticulated Python is fundamentally structural.  For Racket, the heavy use
of first-class classes and class generation naturally leads to choosing
structural subtyping as many of the classes being manipulated have no names.


\newcommand{\rot}[1]{\begin{rotate}{80} #1 \end{rotate}}
\newcommand{\X}{\EM{\bullet}}
\newcommand{\XX}{\EM{\bullet^2}}
\newcommand{\XY}{\EM{\bullet^1}}

\begin{figure}[!ht]
  \center
~ \\[2cm]
  {\small
\begin{tabular}{r|lllllllllllllr}
& & \rot{Nominal}
  & \rot{Optional types}
  & \rot{Concrete types}
  & \rot{Promised types}
  & \rot{Class based}
  & \rot{First-class Class}
  & \rot{Soundness claim}
  & \rot{Unboxed prim.}
  & \rot{Subtype cast}
  & \rot{Shallow cast}
  & \rot{Generative cast}
  & \rot{Blame assignment}
  & \rot{Pathologies}
  \\
Dart         &&\X &\X &   &   &\X &   &    &    &\X &   &   &   &  - 
\\\hline
Hack         &&\X &\X &   &   &\X &   &    &    &\X &   &   &   &  -  
\\\hline
TypeScript   &&   &\X &   &   &\X &   &    &    &   &   &   &   &  -  
\\\hline
C\#          &&\X &\X &\X &   &\X &   &\XX & \X &\X &   &   &   &  -  
\\\hline
Thorn        &&\X &\X &\X &   &\X &   &\XX & \X &\X &   &   &   & 0.8x
\\\hline
StrongScript &&\X &\X &\X &\X &\X &   &\XX &    &\X &   &\X &   & 1.1x   
\\\hline
Gradualtalk  &&\XY&   &   &\X &\X &   & \X &    &   &   &\X &\X &  5x
\\\hline
Typed Racket &&   &   &   &\X &\X &\X &\X  &    &   &\X &\X &\X & 121x 
\\\hline
Reticulated Python    \\
\it Transient&&   &\X &   &   & \X &  & \X &    &   &\X &   &\X & 10x \\
\it Monotonic&&   &   &   &\X & \X &  & \X &    &   &   &\X &\X &  27x\\
\it Guarded  &&   &   &   &\X & \X &  & \X &    &   &   &\X &\X &  21x\\
\end{tabular}}
  \caption{Overview of implemented systems. (1) Gradualtalk has optional
    structural constraints. (2) Concretely typed expressions are sound in
    C\#, Thorn and StrongScript.}\label{over}
\end{figure}

Optional types are the default execution mode for Dart, Hack and TypeScript.
Dart has a checked mode that can be turned on to catch some type errors.
The Transient variant of Reticulated Python is essentially optionally typed,
any value can flow into a variable regardless of its type
annotation. Run-time checks are applied before method invocation.  C\#,
StrongScript and Thorn support both optional and concrete types.  In the
case of Thorn and C\#, when primitives are concretely typed they can be
unboxed and do not require tagging.

The choice of casts follows from other design decisions. Languages with
concrete types naturally tend to use subtype casts to establish the type of
values. For nominal systems there are highly optimized algorithms. Shallow
casts are casts that only checking the presence of methods not their
signature. These are used by Racket and Python to ensure some basic form of
type conformance. Generative casts are used when information such as a type
or a blame label must be associated with a reference or an object.

The last column of \figref{over} lists self-reported performance
pathologies.  These numbers are not comparable as they refer to different
programs and different configurations of type annotations. They are also not
likely to be worst case scenarios as many of these languages do not have a
sufficient corpus of code written in them to conduct a thorough evaluation.
Lastly, these implementations have not been optimized.  Nevertheless, one
can observe that for optional types no overhead is expected as the type
annotations are erased during compilation. Concrete types introduce very
cheap casts, and lead to code that is can be compiled more efficiently. So
experiments suggest performance improvements.  The Transient Reticulated
Python performance can be viewed as a worst case scenario for concrete types
-- i.e. there is a shallow cast at almost every call. Finally languages
with generative casts tend to suffer prohibitive slow downs in pathological 
cases.

\subsection{Blame}
Blame assignment is a topic of investigation in its own right
(e.g.~\cite{Wadler09,SW09,Ahmed09}). Anecdotal evidence from Typed Racket
users suggests that context provided by blame when a run-time type error
occurs is valuable. It helps developers pinpoint the provenance of the
ill-typed value or function that caused the error. A fitting analogy are the
stack traces printed by Java when a program terminates abruptly. Developers
working with languages like C++ must run their program in a debugger to
obtain the same information. In Java, stack traces have little run-time cost
because they piggyback on another feature of the language, namely precise
exceptions.\footnote{ Java's precise exceptions have a price, they inhibit
  some compiler optimizations, but for stack traces the compiler only need
  retain names of methods on the stack and record them on {\sf throw}.} It
is likely that recording blame may be more costly as some information must
be associated with values at every cast.

[Do: fix references to the most recent results on Blame.]

\subsection{Trace preservation}

The semantics of the various type systems are subtle in their distinctions. Ideally,
one would like to reject programs that will fail, but there is a tension
because some of the dynamically typed code exploits the fact that it is
dynamically typed.  Type systems are correctly pesmistic in flagging
potential errors.

To illustrate the difficulties we provide four litmus tests, these are small
programs written in \kafka syntax, but can also be expressed in all the
languages of interest. Each test consists of a class table 
composed of the respective litmus classes, some auxiliary code and a main expression.
In all cases, the main expression is a call to the method t of class T with 
an argument of class A. In each case, the programs are well typed statically.

In the optionally typed semantics, e.g. Dart, all tests run to
completition without getting stuck. Using concrete types in Thorn, 
all of these tests will get stuck with subtype cast expression error. 
As class A is not a subtype of I, nor I'. Therefore, every litmus test will 
get stuck whenever A is passed when an I is expected.
For optional types and the Reticulated Python with Transient semantics, 
the L1 test will fail as transient checks that A has all the method names of I. 
However, the tests L2, L3 and L4 will all succeed, as Transient only checks names at calls.



\begin{figure}[!ht]
\begin{tabular}{cc}
  \begin{tabular}{|@{}cc@{\hspace{1mm}}|}\hline
  \begin{minipage}{4.3cm}
    \begin{lstlisting}
class A {
   m(x: A): A {this}}

class I {
   n(x: I): I {this}}

class T {
   t(x: I): T {this}}
      \end{lstlisting}    
  \end{minipage}
&
  \begin{minipage}{4.6cm}
    \begin{lstlisting}
class A {
  m(x: A): A {this}}

class I {
  m(x: C): I {this}}

class T {
  t(x: I): T {this}}
      \end{lstlisting}    
  \end{minipage}
\\[2mm]
(Litmus test 1) & (Litmus test 2)\\[3mm]
  \begin{minipage}{4.3cm}
    \begin{lstlisting}
class A {
  m(x: *): * {this}}

class I {
  m(x: C): C {this}}

class I2 {
  m(x: D): D {this}}

class E {f: I g: I2}

class T {
  t(x: A): E {
      new E(x,x)}}
      \end{lstlisting}    
  \end{minipage}
&
  \begin{minipage}{4.6cm}
    \begin{lstlisting}
class A {
  f: *
  m(x: A): A {
    this.f(
      new A(new C())}}


class I {
  f: D
  m(x: I): I {this}}


class T {
  t(x: I): I {x.m(x)}
      \end{lstlisting}    
  \end{minipage}
\\[2mm]
(Litmus test 3) &  (Litmus test 4)\\\hline
  \end{tabular}
  &
\begin{minipage}{4cm}
\begin{tabular}{|@{}c@{\hspace{1mm}}|}\hline
  \begin{minipage}{4cm}
    \begin{lstlisting}
class C { 
  n(x: C): C {this}}

class D {
  o(x: D): D {this}}
    \end{lstlisting}    
  \end{minipage}
 \\
  (Auxiliary classes)\\\hline
\end{tabular}
\\ \\ \\  
\begin{tabular}{|@{}c@{\hspace{1mm}}|}\hline
  \begin{minipage}{4cm}
    \begin{lstlisting}
new T().t(new A())
    \end{lstlisting}    
  \end{minipage}
  \\
  (Program 1-3)\\\hline
\end{tabular}
\\ \\ \\  
\begin{tabular}{|@{}c@{\hspace{1mm}}|}\hline
  \begin{minipage}{4cm}
    \begin{lstlisting}
new T().t(
    new A(new D()))
    \end{lstlisting}    
  \end{minipage}
  \\
  (Program 4)\\\hline
\end{tabular}
\end{minipage}
\end{tabular}

~\\

\center
\renewcommand{\V}{\EM{\checkmark}}
\begin{tabular}{|r|l@{~}l@{~}l@{~}l|}\hline
                     & L1 & L2 & L3 & L4\\\hline\rowcolor{Gray}
Thorn                &    &    &    &   \\
Typed Racket         &    & \V & \V &  \\\rowcolor{Gray}
Monotonic  RetPy     &    & \V &    &   \\
Transient RetPy      &    & \V & \V & \V \\\rowcolor{Gray}
TypeScript           & \V & \V & \V & \V \\\hline
\end{tabular}  
  \caption{Semantic litmus tests.}\label{litmus}
\end{figure}




[Say: OOP with structural subtyping makes it easier to make contract errors.]


\subsection{Soundness}

[Say: All dynamic OO language have a dynamic type system that catches type errors.  
So the difference between Sound and unsound is (a) the place where the error is caught, 
(b) cases when the gradul type system departs from the underlying type system.]  

\subsection{Performance}

The only exhaustive study of performance of gradual typing~\cite{popl16} was
provocatively titled ``Is sound gradual typing dead?''.  Takikawa~\emph{et
  al.}  reported that 14 out of 16 small real-world programs had performance
cliffs past which partially typed code would run between 2x and 121x slower
than untyped code. Few if any commercial system could justify that increased
assurance is worth is worth a performance regression of this
scale.\footnote{Otherwise one would accept some of the research prototypes
  adding memory safety to C would have become mainstream.} While there is
ongoing research towards reducing the overheads of
contracts~\cite{pycket15}, preliminary results suggest that the ...


[Say: primitive and immutable value checks are cheap]

[Say: first order functions w/o recursion are cheap ]

[Say: higher order/recursive functions are expensive]

[Say: TR works well as long as you don't exchange large mutable values or hof]

[Say: OOP is all about large graphs and hof ==> ouch ]

[Say: consistency makes it impossible to unbox.]

\section{Gradual Typing in Practice}

Gradual types systems comes in many shapes and size, with different constraints 
and complexity, as well as their own strength and weakness. In this section, we present 
a brief introduction for five gradual types systems, focusing on their role within 
the gradual typing landscape. We aim to illustrate the niche of each system, and what 
make them unique. 

Several description contains examples written using the straight-forward syntax
provided by \kafka instead of the original language, allowing us to start explaining
the different gradual typing idioms within the same context.


\newcommand{\code}[1]{{\tt #1}\xspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{TypeScript}

Typescript~\cite{BAT14} is a backwards compatible extension of JavaScript
with classes and type annotations. Type equivalence is structural and
subtyping of recursive types is supported (types arise from class
declarations). Missing annotations are treated as \any. The role of types is
to catch simple errors, such as misspelling the method names of a class.

\begin{lstlisting}
  class A { }
    m(x: C): A { this } }

  new A().n(new C())
\end{lstlisting}

Well-typed code is translated to plain JavaScript with all types erased and
methods resolved dynamically. In our translation to \kafka, the above program
(with the correct method name) would translate to the following.

\begin{lstlisting}
  class A { }
    m(x: *): * { this } }

  new A()@m(new C())
\end{lstlisting}

The translated code uses the dynamic calls (written \code @) with its methods signature
set to \any. However, it is easy to trick the compiler into accepting incorrect
code, as the following code would compile, but throws a JavaScript exception.

\begin{lstlisting}
  (<*>new A()) . n(new C())
\end{lstlisting}

The designers of TypeScript saw unsoundness as a way to ensure (a) types do
not prevent a program from running, e.g. when importing a new library with
type annotations inconsistent with clent code; and (b) existing
browsers can run TypeScript code with no overheads.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Thorn}

Thorn~\cite{oopsla09} is an object-oriented language with multiple
inheritance, nominal type equivalence, and a combination of optional and
concrete types. Optional types (\code{?T}) are treated exactly
as in TypeScript, they are translated to dynamic types and method invocations are
resolved dynamically. Concrete types (written \code{T}) are treated as they would be in Java. 
A variable \code{x:~C} is guaranteed to be of class \code C or of a subtype thereof.

\begin{lstlisting}
class A {
  m(x: ?C): ?C { x }
  n(x:  C):  C { x }
}

new A().m( new D() )  // OK -- warning
new A().n( new D() )  // ERR -- D !<: C
\end{lstlisting}

In the above code snippet, class \code A has a method taking an optional
type and another taking a concrete type. Assume the types \code C and \code D are
unrelated. The first call is allowed because the type of \code m is treated
as \any (the Thorn compiler does emit a warning). The second call is ruled
as incorrect, there are no subtype relation between \code C and \code D.
Translating Thorn to \kafka is straightforward. Optional types are translated
to \any. Concrete types are translated with the structural subtype casted
in \kafka. 

%TODO: finish this sentence: Method calls with either receiver 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Typed Racket}

Typed Racket is an extension of Racket, designed to allow programmers to
type their untyped Racket code. It differs in two key ways from
Strongscript, using \emph{promised types}, as mentioned before, but also in
where it allows programmers to add types in the first place. Gradual typing
evokes images of programmers altering their programs to add more
types. However, an important question arises about that mental picture: what
does it mean to gradually add types to a program?

The answer taken by Strongscript and the other gradual typing systems we
discuss in this paper is that programmers should be able to add a type
anywhere it is syntactically valid. However, this idea is somewhat
artificial - some programmers will add types slowly, one function at a time,
while others will type whole compilation modules at a time.

The approach taken by Typed Racket is built around the latter style of
gradual typing.  Instead of adding types to individual functions, it allows
programmers to type their programs one module at a time, where each module
is a separate compilation unit.  This approach constrains the way that
programmers can add types to programs, and avoids having to reason
about what it means to have a partially typed method, since in Typed Racket
everything in a module is either fully typed or completely untyped.

Additionally, Typed Racket is the first \emph{promised type} systems
we will be discussing. Suppose that you have a variable $\x$ under type $\t$
where $\t$ has some method $\xt{f}$. Naturally, you would expect to be able
to call $\xt{f}$ (written in Typed Racket as \verb|(send x f)|), and would expect that your type
would guarantee that this function call would both work and return a value
of the correct type.

However, there are a number of places where this basic assumption can be
violated, as a result of the interaction between typed and untyped code. If the
underlying value has no function \xt{f}, then this call will fail, but this
would be a runtime type error, exactly the kind of problem we wish to avoid.

The solution to this problem comes from how Typed Racket controls the
interaction between modules, at the \emph{module boundaries}, where the
system has to ensure that the untyped code respects the type annotations. To
ensure the type annotations are respected, Typed Racket uses
contracts. The idea behind using contracts~\cite{ff-icfp02} is that they allow
the system to check the types on the values going into typed code from
untyped code, and values flowing out of untyped code into typed code.

\begin{figure}[h]
% to generate, run
% racket format-racket.rkt ../examples/typed_racket/untyped1.rkt untyped-rkt1.pdf
% racket format-racket.rkt ../examples/typed_racket/typed1.rkt typed-rkt1.pdf
\includegraphics{figures/untyped-rkt1.pdf}
\caption{untyped1.rkt: a simple Racket file}
\label{fig:ut1r}
\end{figure}

\begin{figure}
\includegraphics{figures/typed-rkt1.pdf}
\caption{typed1.rkt: Typed Racket file using untyped1.rkt}
\label{fig:t1r}
\end{figure}

This construction, whereby every module is either entirely typed or entirely
untyped allows Typed Racket to take a unique approach to enforcement, built
around contracts~\cite{tf-popl08} applied at the points where modules
interact. Types of values are checked at boundaries, and methods are
effectively wrapped as they cross between modules.

The key drawback to this approach is that a wrapper cannot establish
\emph{actual identity} the same way that \emph{concrete} type systems like
Strongscript can. Instead, wrapper or guard based systems like the Typed
Racket approach can only prove that a given untyped function will \emph{act
  like} a typed function, up to cast errors, and have to be executed every
time a value passes through a typed-untyped boundary.

As a demonstration of this, consider figure~\ref{fig:tr2}. Here we import
the same untyped function, but instead of using the correct type annotation
for the (untyped) identity function, we assert that it takes an integer and
makes it into a string. This type annotation is clearly wrong, but Typed
Racket has no way of checking that it is correct when it is applied. Rather,
we are allowed to use the \xt{id} function, and only find out that the type
is wrong when it returns a number where we expected a string.

\begin{figure}[h]
% racket format-racket.rkt ../examples/typed_racket/typed2.rkt typed-rkt2.pdf
\includegraphics{figures/typed-rkt2.pdf}
\caption{typed2.rkt: Invalid type annotation}
\label{fig:tr2}
\end{figure}

However, the use of promised typing provides a major advantage: untyped code
does not need to be aware of types. In order to use a \emph{concrete} type
system, even untyped code must exist in at least an inheritance hierarchy
that can be reasoned about by the runtime type checking system. As a result,
promised typing can be used in languages that do not have class hierarchies.

While promised type systems can successfully type more code, they are
limited in that they cannot absolutely establish type correctness across
casts, unlike concrete type systems. As a result, errors occur when untyped
code is used, rather than at the boundary crossing.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Reticulated Python}

Reticulated Python is an extension of Python with sound gradual types by
Vitousek et al~\cite{siek14}, providing Python programmers with
the ability to add types to their programs. Unlike the other languages we
have examined so far, Reticulated Python supports multiple different
semantics for their types, providing different guarantees and imposing
different restrictions.

Three different gradual typing semantics are currently avaliable in
Reticulated Python: transient, monotonic, and guarded. All three systems are
promised typing approaches, checking to ensure that untyped code behaves as
if it were typed from the perspective of a typed observer. However, the
mechanism for achieving this differs in each case.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Transient}

In both Strongscript and Typed Racket, if you wrote a method 
under type $\xt{int} \rightarrow \xt{int}$, you could be
assured that you would only ever be called with an argument that was
actually an int. To achieve this guarantee, the systems perform 
inline runtime casts based on runtime type information and
inserted wrappers to check that the types were respected \emph{before} an
actual function call was made. Likewise, a function that was declared to
return an int would always return an int, ensured either by wrapping or by
adding casts inside of it.

Transient takes the opposite perspective. Instead of the caller being
responsible for checking the types on the arguments and the callee ensuring
the return type is correct, the transient semantics for Reticulated Python
has the callee enforce the types on the arguments and the caller enforce the
type of the return value.

To illustrate this, consider figure~\ref{fig:guard2}. If we look at the
execution trace that produces the error, we find the following sequence of
events happened:
\begin{enumerate}
\item Evaluate \verb|A1()| to value \xt{v}
\item Wrap \xt{v} with wrapper \xt{A2W}, producing \xt{vw}
\item Invoke \verb|test| with \xt{vw}
\item Call \verb|a| with 2 on \xt{vw}
\item \xt{A2W} checks that 2 is an integer
\item Append 2 to the string ``foo'' inside \xt{A1.a}
\item Return ``2foo'' 
\item \xt{A2W} finds that ``2foo'' is not an integer, and errors.
\end{enumerate}

Likewise, in figure~\ref{fig:guard3}, we would end up with steps 5 and (a
successful) step 8 repeated 1000 times in the execution trace. However, we
can ``bake in'' the checks added by \xt{A2W} into the program itself,
resulting in figure~\ref{fig:trans1}.

\begin{figure}[h]
\begin{verbatim}
class A1:
  def a(a : Any) : Any:
    return a + "foo"
class A2:
  def a(a : Int) : Int:
    check(a, Int)
    return a + 2

def test(a:A2):Int
  return check(a.a(2), Int) + 1

test(A1())
\end{verbatim}
\caption{Transient: Type checks baked into source.}
\label{fig:trans1}
\end{figure}

This embedding preserves the execution trace that we saw in the guarded
semantics, but also completely avoids the problems inherent to having
wrappers added at type transitions. However, while the transient semantics
is able to preserve the execution trace, the site at which the error happens
is somewhat different.

In the guarded semantics, step 8 happened \emph{before} the function
\verb|a| was able to return, and therefore the caller effectively never saw
the wrong type. In the transient semantics, the caller is now responsible
for ensuring that the types of the values passed into it are correct, which
has two key implications.

The first is that the site where errors occur is now slightly
different. When a function returns a value that does not match up with the
type that it produces, that discrepancy is now noticed in the caller,
instead of inside of the wrapper.

This leads to the second implication of the transient semantics: all typed
code now has to add type checks, as seen in \verb|A2.a| in
figure~\ref{fig:trans1}. No typed code can trust any type, be that a type
that is passed in (for the case where untyped code calls typed code), or a
type returned from another function (as the other function could be
untyped).

While this approach completely avoids the problem identified in
figure~\ref{fig:guard3}, it raises a new performance issue: this check
cannot be statically removed. Any nominally typed variable can now no longer
be statically trusted to respect its type, and as a result, every invocation
must be checked for type safety. Therefore, the transient semantics will run
into performance issues, if naievly implemented, as more types are added,
contradicting the typical wisdom about types and performance. While a more
sophisticated implementation may be able to avoid some of these checks, even
better performance of typed code can be made possible by using a different
type safety guarantee.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Monotonic}
A key downfall of the approaches we discussed previously is that they
cause performance impacts in fully-typed code, especially at heap access
sites. The monotonic semantics for Reticulated Python aims to recover this,
in exchange for a new dynamically-enforced guarantee.

To see why the impact exists, consider the following code

\begin{verbatim}
function evil(x : *) : * {
	x := "foo bar"
}

Ref<Int> a = Ref(3)
evil(a)
Int y = !x + 2
\end{verbatim}

If we stripped all checks from this code, we would end up with a stuck
state, since we would be adding a string to an integer, despite statically
typing the value of $\a$ as an integer, as we were able to assign to the
underlying reference from an untyped context.

The approaches discussed for Typed Racket and the transient semantics
handle this case differently, but both require that the typed code perform
a typecheck at the dereference of $\x$. Problematically, these checks
have to be performed even in a fully typed program, because it is impossible
to know which pointers have been exposed to dynamic code.

The key feature of the monotonic semantics is that it imposes these checks
on the dynamic code - any dynamic reference has to respect the types imposed
by a typed reference. In the above example, the monotonic semantics would
produce an error when we tried to assign a string into $\x$ - despite the
static typing working out, because the reference has a type which is
incompatible with our new type, monotonic will reject it at that point.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Kafka: A Core Calculus}

We present \kafka, a gradually typed object-oriented languages.
\kafka is a statically typed class-based calculus with dynamic dispatch, 
following the design of C\#. The dynamic type of \kafka is denoted by \any.
\kafka is structurally typed, it does not have null values, or supports
inheritance between classes. Fields are accessed by getter and setter methods, 
their presence in class types is observed by the presence of the respective 
getters and setters.

Statically dispatched method calls (i.e. calls where the type of the
receiver is not \any) are denoted by \Call\x\m\e. Methods are limited to a
single argument for simplicity. Dynamically dispatched method calls 
(i.e. calls where the type of the receiver is \any) are denoted by \DynCall\x\m\e.
Object creation is denoted by denoted \New\C{\b\e}, a class name (\C) and 
a sequence of arguments (\b\e) in the order of definition of fields.

The meta-variables \x ranges over argument names, \a over memory locations, \f
over field names (as well as getter and setter method names), \m over method
names, \C, \D, and \E over class names.  We use \this to denote a distinguished 
variable name for the current object, and \that to denote a distinguished field 
name for the target of the wrapper class. \D is a meta-variable used to range over dynamically 
generated class names. \a is ranges over heap addresses. \k ranges over 
class definitions consisting of a class name, followed by a, possibly empty, 
sequence of field definitions, \fd, and a, possibly empty, sequence of 
method definitions, \md.

\begin{figure}[!h]
\hrulefill

\begin{minipage}{6.3cm}\begin{tabular}{@{}l@{~}l@{}l@{}l@{}ll}
\e &::=  \x         &\B \this         &\B \that        &\B \New\C{\b\e} \\
   &\B \Get\e\f     &\B \Set\e\f\e    &\B \Call\e\m\e  &\B \DynCall\e\m\e \\
   &\B \SubCast\t\e &\B \ShaCast\t\e  &\B \a \\ 
\end{tabular}\end{minipage}
\begin{minipage}{6cm}\begin{tabular}{l@{~}l@{}l@{}l}
   ~ \k &::= \Class \C {\b\fd}{\b\md}
\end{tabular}
\begin{tabular}{l@{~}l@{}l@{}l}
\md &::= \Mdef\m\x\t\t\e   &\B  \Mdef\f\x\t\t\e &\B \Mdefz\f\t\e \\
\mt &::= \Mtype\m\t\t &\B~  \Mtype\f\t\t  &\B \Mtype\f{}\t  \\
~ \t&::= ~ \any  \B   \C  & \fd~ ::= ~ \Fdef\f\t \\ 
\end{tabular}\end{minipage}

\hrulefill

\caption{\kafka Syntax.}\label{syn}
\end{figure}

%% TODO Put somewhere????
%\E  &::= \Ftype\x\t  \B \none\\
% \s  &::= ~~\none ~~ \B ~~  {\Bind{\a}{\obj\C{\b\a}}}~\s


\kafka have two structural cast expressions. The structural subtype cast, denoted by \SubCast\t\a,
asserts that the object at location \a is of type \t.  The structural shallow cast, 
denoted by \ShaCast\t\a, asserts the object at location \a has methods with names matching
to those of type \t, while not making any guarantee about the type of the arguments.  

% The generative behavioral cast, denoted \BehCast\t\a, will ensure that 
% either \a behaves as a \t or that it get stuck. The generative monotonic 
% cast, denoted \MonCast\t\a, is a behavioral cast that, in addition, imposes 
% constraints on fields.

\subsection{Semantics}

\begin{figure}[!h]
\begin{tabular}{|ccc|ccc|}
\hline
\multicolumn{3}{|l|}{Static:} & \multicolumn{3}{l|}{Dynamic:}\\
\hline
$\K~\e$ & $\progtrans{}{}$ & $\Kp~\ep$ & 
$\Kp~\ep~\cdot$ & $\longrightarrow^*$ & $\Kpp~\a~\s$ \\
\hline
\multicolumn{3}{|l|}{Guarantee:} & \multicolumn{3}{l|}{Guarantee:}\\
\hline
&& $\WFp\Kp\ep$ & 
$\EnvType {\cdot}{\cdot}\Kp\e\t$ & $\implies$ & 
$\EnvType {\cdot}{\s}\Kpp\a\t$ \\\hline
\end{tabular}
\caption{\kafka Reductions.}\label{redu}
\end{figure}

The semantics for \kafka are typical of small step operational semantics, 
with some unusual features to accomodate the translations of various
gradual type systems and their cast semantics. A \kafka program is defined 
by the combination of a class table \K (consists of a list of classes \k)
and an evaluation expression \e. 

\kafka classes contain methods and fields, the latter can be declared 
either via an explicit field declaration in the class
(e.g. \HT\f\t) or by a pair of a getter (\Get\this\f) and setter 
(\Set\this\f\x) methods. Semantically, both explicit and implicit fields behave 
identically, which has the concequence that untyped field access is forbidden, 
as explicit field semantics would become dependent on the approach to typing. 
Methods in \kafka are segregated into typed (methods whose argument and
return type is not \any) and untyped methods, the former of which can be 
called with the statically resolved \Call\e\m\e form, and the latter of
which can only be called with the dynamically checked \DynCall\e\m\e 
expression. Executions halt when it gets stuck, encounters an expression that is 
not a value and cannot apply any more evaluation rules, or the expression is a value.

A heap (\s) in \kafka is a set of mappings from memory locations to objects,
denoted by \Map\s{\Bind\a{\obj\C{\b\a}}}. Objects in the heap are the 
combination of a list of field values \a and the class name \C.
A configuration is the combination of a program \K\e and a heap \s, 
and reducing one configuration \K\e\s to another configuration \Kp\ep\sp 
is denoted \Reduce\K\e\s\Kp\ep\sp. The reductions rules for \kafka are presented 
in figure \ref{fig:semantics}, with the evaluation contexts, denoted by \EE, presented 
at the bottom.

The auxiliary function \names{} returns the names of methods, and the
auxiliary function \untyped{} returns the methods whose types are \any.
The auxiliary function \xt{read} return the location \ap pointing to the
field \f of the object at location \a. The auxiliary function \xt{write}
return the heap \sp with the field \f of the object at location \a updated
to the location \ap. \App\K\C denotes the lookup of class \C in class table \K.
\Mdef\m\x\t\tp\e \In \k denotes that method \m occurs in class \k. All auxiliary 
functions are defined in the appendix. Note that the ordering within lists of 
fields and methods definition is not relevant (i.e. we can reorder when convenient). 

\begin{figure}[!h]
\hrulefill

\begin{minipage}{8cm}
  \opdef{\Reduce \K\e\s \Kp\ep\sp}
        {\e\s evaluates to \ep\xspace in a step}\\[-1mm]
\begin{tabular}{l@{}l@{~}l@{~}l}
\CondRule{E1}{  %% new C -> a
   \fresh\ap 
}{ 
  \ReduceA \K{\New\C{\b\a}}\s \K\ap{\Map\s{\Bind\ap{\obj\C{\b\a}}}}
}
\CondRule{E2}{  %% a.f() -> e
    \Mdefz\f\t\e \In \App\K\C \AND  \App\s\a =\obj\C{\b\a}
}{
   \ReduceA \K{\Get\a\f}\s \K{[\a/\this]\e}\s
}
\CondRule{E3}{  %% a.f(a) -> e
    \Mdef\f\x\t\t\e \In \App\K\C \AND  \App\s\a=\obj\C{\b\a}
}{
   \ReduceA \K{\Set\a\f\ap}\s \K{[\a/\this~{\ap/\x}]\e}\s
}
\CondRule{E4}{  %% a.f() -> e
 \readf \s\a\f\K =  \ap 
}{
  \ReduceA \K{\Get\a{\f}}\s  \K\ap\s
}
\CondRule{E5}{  %% a.f(e) -> e
 \setf \s\a\f\ap\K =  \sp
}{
  \ReduceA \K{\Set\a{\f}\ap}\s \K\ap\sp
}
\CondRule{E6}{  %% a.m(a) -> e
  \Mdef\m\x\D\Dp\e  \In \App\K\C \AND \App\s\a=\obj\C{\b\a}
}{
 \ReduceA \K{\Call\a\m\ap}\s \K{[\a/\this~{\ap/\x}]\e}\s
}
\CondRule{E7}{  %% a@m(a) -> e
    \Mdef\m\x\any\any\e \In \App\K\C \AND \App\s\a=\obj\C{\b\a}
}{
  \ReduceA \K{\DynCall\a\m\ap}\s \K{[\a/\this~{\ap/\x}]\e}\s
}
\CondRule{E8}{  %% Subtypecast
}{ 
  \ReduceA \K{\SubCast \any\a}\s \K\a\s
}
\CondRule{E9}{  %% Subtypecast
  \StrSub {}\K\C \D \AND \App\s\a=\obj\C{\b\a} 
}{ 
  \ReduceA \K{\SubCast \D\a}\s \K\a\s
}
\CondRule{E10}{  %% Shallow Structural
}{ 
  \ReduceA \K{\ShaCast \any\a}\s \K\a\s
}
\CondRule{E10b}{  %% Shallow Structural
 \names{{\App\K\C}}  $\supseteq$  \names{{\App\K\D}} \AND \App\s\a=\obj\C{\b\a} 
}{ 
  \ReduceA \K{\ShaCast \D\a}\s \K\a\s
}
% \CondRule{E11}{  %% Behavioral cast
%   \behcast \a\t\s\K  \Kp\ap\sp
% }{ 
%   \ReduceA  \K{\BehCast \t\a}\s \Kp\ap\sp
% }
% \CondRule{E12}{  %% Monotonic cast
%   \moncast \a\t\s\K  \Kp\sp
% }{ 
%   \ReduceA \K{\MonCast\t\a}\s \Kp\a\sp
% }
\CondRule{E11}{  %% E[e] -> E[e']
  \Reduce \K\e\s \Kp\ep\sp
}{
 \ReduceA \K{\EE[\e]}\s \Kp{\EE[\ep]}\sp
}
\end{tabular}\end{minipage}

%%%%%%%%%%%%%%%%%%% CONTEXTS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
~\\[2mm]

\begin{minipage}{4cm}\begin{tabular}{l@{~~}l@{~}l@{~}l@{~}l@{~}l@{~}l@{~}l}
\EE &::= \Get\EE\f     &\B
        \Set\EE\f\e   &\B
        \Set\a\f\EE   &\B  
        \Call\EE\m\e  &\B
        \Call\a\m{\EE} &\B
        \DynCall\EE\m\e   &\B
        \DynCall\a\m\EE   \\
   &\B~
       \SubCast\t\EE  &\B
       \ShaCast\t\EE  &\B
       \BehCast\t\EE &\B
       \MonCast\t\EE  &\B
       \New\C{\b \a\,\EE\,\b\e}
  &\B \EM{\square}
\end{tabular}
\end{minipage}

\hrulefill
\caption{\kafka Semantics.}
\label{fig:semantics}
\end{figure}

\subsection{Translations}

\kafka provides the basis to describe the operations of a typical object-oriented languages. 
\kafka requires programmers to write casts wherever a type boundary is encountered, 
which is not representative of how actual gradually typed programming languages behave. 
Most gradual type languages abstract away from inserting casts, instead
they would be automatically inserted and used at runtime, remaining invisibly to programmers
unless errors are produced.

We introduce a \emph{translation} mechanism that works similarly to the cast insertion described 
by Siek and Taha~\cite{SiekTaha06} described cast insertion, however, our mechanism differs in
that it cannot be bottom-up. Instead, our translation is \emph{bidirectional}, as described by 
Pierce and Turner~\cite{lti-pierce}. Bidirectional typechecking is a local type 
inference mechanism, that allows identifying cast insertion locations in a modular way.

Casts are the key to the different interpretations of gradual typing, as
they are one of the two places that, in \kafka, a program can get stuck
at. The approaches that we will be comparing have different definitions of
casting, and their varying approach to runtime type assertions forms an
important part of how they interact with untyped parts of the program.

\subsection{Structural Casts}

\kafka offers two kinds of structural casts. One which performs a structural
subtype check and one that only check for the persence of methods with given
names. 

The first type of cast is the simplest, as it only checks that the runtime type
tag (\C) is a subtype of the required type (\D), and is notated \SubCast\D\e. 
Here, the runtime check conists only of ensuring that the subtyping judgment
holds, which can be done easily and does not require any additional runtime 
components beyond the cast. Moreover, this kind of cast establishes value idenity
exactly, allowing us to type it with the cast type, shown in \RuleRef{W8}.

This is not true, however, of the name cast, which only checks for the presence
of methods with the given name. While simple - it does not even need
a separate judgment form in figure \ref{fig:semantics} - the name cast is
extremely weak, and cannot ensure that type identity is preserved up to the 
level required to give it a strong \kafka type. As a result, any use of it is
typed \any, as seen in \RuleRef{W9}.

To illustrate the first cast, through subtyping, we present the 
translation of a subset of the programming language Thorn to \kafka. 

\section{Translation: TypeScript}

TypeScript is an example of a \emph{optional} type system, where the types have
no static guarantee whatsoever, and, as a result, the type system has no effect
on the semantics of the language. As a result, TypeScript types are all \any,
no matter the declared type.

To model TypeScript on top of \kafka, we will use a very simple translation 
mechanism, where every type becomes \any and every call becomes a dynamic call.
We only have to ensure that the output program is type correct with respect to
\kafka.

We proceed through translation top-down, starting with the whole program 
translation depicted in figure~\ref{redu} (\RuleRef{PT}), then proceeding 
through the included expression and recursing into the classes, where we 
translate the included methods (\RuleRef{CR2} and \RuleRef{MT}).

\begin{mathpar}
\IRule{PT}{
  {\classtrans{\K}{\K}{\K'}} \\ \GenCast{\K}{\cdot}{\e}{\ep}{\t} 
}{\progtrans{\e~\K}{\e'~{\K'}}}

\IRule{CR1}{ 
  \b{\methtrans {\K}{\C}{\md}{\md'}{}} \\
  \classtrans {\K}{\Kp}\Kpp
}{
   \classtrans {\K}{{\Class \C{\b{\Ftype\f\t}}{\b\md}~\Kp}}{\Class \C {\b{\Ftype\f\t}}{\b{\md'}}~\Kpp}}

\IRule{CR2}{ 
}{
  \classtrans {\K}\cdot\cdot
}

\IRule{MT}{
  \AnaCast {\K}{\HT\this{\C}~\HT\x{\t}}{\e}\ep{\tp}
}{
  \methtrans {\K}{\C}{\Mdef\m\x{\t}{\tp}{\e}}{\Mdef\m\x\any\any\ep}{}
}
\end{mathpar}

Beyond the top level translation, we have two judgments that perform cast 
insertion on expressions, following Pierce and Turner~\cite{pierce:1998:local},
the synthetic cast insertion judgment $\GenCast\K\Env\e\ep\t$, which states that
, against context \Env and class table \K, source expression \e translates to
\kafka expression \ep producing source type \t, and the analytic judgment
$\AnaCast\K\Env\e\ep\t$, which ensures that the translated \kafka expression 
$\ep$ will model source type \t, coming from source expression \e.

Inside of this bidirectional framework, we then have a fairly typical set of
translation judgments for translating optionally typed TypeScript programs into
\kafka.

\begin{mathpar}
\IRule{TSA1}{\HasType{\Env}\x\t}{\GenCast{\K}\Env\x\x\t}

\IRule[width=30em]{TSA2}{
    \GenCast\K\Env{\e_1}{\e_3}{\C} \\ \n(\b{\t_1}):\t_2 \in \classoff\C\K \\ \b{\AnaCast\K\Env{\e_2}{\e_4}{\t_1}}
}{
    \GenCast\K\Env{\Call{\e_1}\m{\b{\e_2}}}{\DynCall{\e_3}\m{\b{\e_4}}}{\t_2}
}

\IRule{TSA3}{
    \GenCast\K\Env{\e_1}{\e_3}{\any} \\ {\AnaCast\K\Env{\e_2}{\e_4}{\any}}
}{
    \GenCast\K\Env{\Call{\e_1}\m{{\e_2}}}{\DynCall{\e_3}\m{{\e_4}}}{\any}
}

\IRule[width=20em]{TSA4}{
    \HasType{\E}\this\C \\ \f(\b{\t_1}):\t_2 \in \classoff\C\K \\ {\AnaCast\K\Env{\e}{\ep}{\t_1}}
}{
    \GenCast\K\Env{\Call{\this}\f{\b\e}}{\Call{\this}\f{\ep}}{\any}
}

\IRule{TSA5}{
  \b{\AnaCast{\K}\Env{\e_1}{\e_2}\t} \\ 
  \Class \C {\b{\Ftype\f\t}} {\b{\md}}
  }{\GenCast\K\Env{\New\C{\b{\e_1}}}{\SubCast\any{\New\C{\b{\e_2}}}}{\C}}
\end{mathpar}

For TypeScript the synthetic case of translation is uninteresting, with the 
exception of \RuleRef{TSA4}, which allows TypeScript programs to access fields
via the self-reference, whose type is always absolutely known.

\begin{mathpar}
\IRule{TSAASC1}{
  \GenCast\K\Env\e\ep\tp \\
  \K \vdash \tp \Sub \t
}{
  \AnaCast\K\Env\e\ep\t
}

\IRule{TSAASC2}{
  \GenCast\K\Env\e\ep\any
}{
  \AnaCast\K\Env\e\ep\t
}

\IRule{TSAASC3}{
  \GenCast\K\Env\e\ep\C
}{
  \AnaCast\K\Env\e\ep\any
}
\end{mathpar}

Of more interest are TypeScript's analytic rules. Here, \RuleRef{TSAASC1}
requires the interaction between typed parts of the program to be well-typed,
but \RuleRef{TSAASC2} and \RuleRef{TSAASC3} allow untyped values to be passed
into typed references without impediment


\section{Translation: Thorn}
\newcommand{\bC}{\xt{!C}}

The translation for Thorn contains an ``unsound'' type $\dt\C$, which has its own subtyping relation, and compiles 
down to \any in \kafka. This unsound type still enforces the same static requirements as its sound counterpart, but 
generates no runtime casts and therefore has lower overhead. Over this new type, we define a subtyping relation, 
$\t \Sub_t \t$.


\begin{tabular}{l@{~~}l@{}l@{}l}
\\
\t  &::= ~ \any \B \C \B \dt\C \\
\\
\end{tabular}

\newcommand{\ThorSub}[4]{\EM{#1~#2 \vdash #3 \Sub_t #4}}
\opdef{\ThorSub\M\K\t\tp}{\t is a subtype of \tp}
\begin{mathpar}
\IRule{THSWeak}{\ThorSub \M\K\C\D}{\ThorSub\M\K{\dt\C}{\dt\D}}

\IRule{THSLower}{\ThorSub \M\K\C\D}{\ThorSub\M\K{\C}{\dt\D}}
\end{mathpar}

The remainder of the subtyping judgment is identical to subtyping in \kafka, and 
it defines the synthetic and analytic cases for the cast insertion of Thorn.

\newcommand{\ba}{\xt{!}}

\begin{mathpar}
\IRule{THA1}{
  \HasType\Env\x\t
}{
  \GenCast\K\Env\x\x\t
}

\IRule[width=30em]{THA2}{
    \GenCast\K\Env{\e_1}{\e_3}\C \\ 
    \src{\n(\b{\t_1}):\t_2 \in \classoff\C\K} \\ 
    \b{\AnaCast\K\Env{\e_2}{\e_4}{\t_1}}
}{
    \GenCast\K\Env{\Call{\e_1}\n{\b{\e_2}}}{\Call{\e_3}\n{\b{\e_4}}}{\t_2}
}

\IRule{THA3}{
    \GenCast\K\Env{\e_1}{\e_3}{\dt\C} \\ 
    \src{\m({\t_1}):\D \in \classoff\C\K} \\ 
    \AnaCast\K\Env{\e_2}{\e_4}{\t_1}
}{
    \GenCast\K\Env{\Call{\e_1}\m{{\e_2}}}{\SubCast\D{\DynCall{\e_3}\m{{\e_4}}}}{\D} %Q: do I need to cast the return value of non-bang
}

\IRule{THA4}{
    \GenCast\K\Env{\e_1}{\e_3}{\dt\C} \\ 
    \m({\t_1}):\t \in \classoff\C\K \\ 
    \t \neq \D \\
    \AnaCast\K\Env{\e_2}{\e_4}{\t_1} 
}{
    \GenCast\K\Env{\Call{\e_1}\m{{\e_2}}}{\DynCall{\e_3}\m{{\e_4}}}{\t}
    %Q: do I need to cast the return value of non-bang
}

\IRule{THA5}{
    \GenCast\K\Env{\e_1}{\e_3}\any \\ 
    \AnaCast\K\Env{\e_2}{\e_4}\any
}{
    \GenCast\K\Env{\Call{\e_1}\m{{\e_2}}}{\DynCall{\e_3}\m{{\e_4}}}\any
}

\IRule{THA6}{
  \b{\AnaCast\K\Env{\e_1}{\e_2}\t} \\ 
  \Class \C {\b{\Ftype\f\t}} {\b\md}
  }{
  \GenCast\K\Env{\New\C{\b{\e_1}}}{\New\C{\b{\e_2}}}\C
}
\end{mathpar}

The synthetic cases describes the traditional ``bottom-up'' style of typing judgment. Each case produce an equivalent 
\kafka term for the translated type. Therefore, \RuleRef{THA1}, \RuleRef{THA2}, \RuleRef{THA5}, and \RuleRef{THA6} are all effectively 
direct translations of the traditional typing rules for their cases.

The exception being \RuleRef{THA3} and \RuleRef{THA4}, as they are applied when the receiver type is a weak type, an unsound type, 
and case analyze is performed on the declared return type. In \RuleRef{THA3}, the return type is a concrete type, or a sound type, 
from an unsound type, and therefore requires an insertion of a runtime cast, and the alternative case is shown in \RuleRef{THA4}.

It is important to note that both \RuleRef{THA3} and \RuleRef{THA4} produce dynamic calls on the receiver, despite the 
receiver having a source language type. This is because Thorn's weak types are translated to \kafka's \any, which causes 
all calls on optional types by \kafka to be dynamic.

\hrulefill

\begin{mathpar}
\IRule{THAASC1}{
  \GenCast\K\Env{\e_1}{\e_2}{\C_2} \\
  \src{\ThorSub\K\cdot{\C_2}{\C_1}}\\
}{
  \AnaCast\K\Env{\e_1}{\e_2}{\C_1}
}

\IRule{THAASC2}{
  \GenCast\K\Env{\e_1}{\e_2}{\dt\D} \\ 
  \src{\ThorSub\K\cdot\D\C}
}{
  \AnaCast\K\Env{\e_1}{\SubCast{\C}{\e_2}}{\C}
}

\IRule{THAASC3}{
  \GenCast\K\Env{\e_1}{\e_2}{\any} \\
}{
  \AnaCast\K\Env{\e_1}{\SubCast{\C}{\e_2}}{\C}
}

\IRule{THAASC4}{
  \GenCast\K\Env{\e_1}{\e_2}{\any} \\
}{
  \AnaCast\K\Env{\e_1}{\e_2}{\dt\C}
}

\IRule{THAASC5}{
  \GenCast\K\Env{\e_1}{\e_2}{\t} \\ \t \neq \any
}{
  \AnaCast\K\Env{\e_1}{\e_2}{\any}
}
\end{mathpar}


\section{Translation: Reticulated Python - Transient Semantics}

Reticulated Python implements several different semantics, through not simultaneously in the same language. 

The transient semantics is illustrated by the cast, $\ShaCast\t\e$. It asserts that $\e$ has the same \emph{names} as $\t$,
and the closest type representation in \kafka is the $\any$ type, as illustrated in \RuleRef{W9}. The transient semantics 
guarantees that the methods on the named type will be callable with some argument, and some return value. It is up to 
the callee to check the arguments are correct and the caller to ensure the return value is correct.

Therefore, the translation of the transient semantics require a several rules in order to be well formed in \kafka. 
The most notablely is the rule \RuleRef{MTT}, it is forced to erase every type from the arguments to the function, 
as typed arguments may not be respected in the dynamics semantics. The type invariant is ensured to hold by using 
a tuple class (to simulate sequencing, which \kafka does not natively support) to check the type of the argument, and then return 
the value of the body (inserted into the second field of the tuple class).


\begin{mathpar}
\IRule{MTU}{
  \AnaCast{\K}{\HT\this\C~\HT\x\any}{\e}{\ep}{\any}
}{\methtrans\K\C{\Mdef\m\x\any\any\e}{\Mdef\m\x\any\any\ep}{}}

\IRule{MTT}{
  \t \neq \any \\
  \AnaCast{\K}{\HT\this\C~\HT\x\t}{\e}{\ep}{\tp}
}{\methtrans\K\C{\Mdef\m\x\C\Cp\e}{\Mdef\m\x\any\any{\SubCast{\any}{\New{\EMxt{A2}}{\ShaCast\C\x, \e}.{\EMxt{f2}}()}}}{}}
\end{mathpar}

Internally, the translations required to support the transient semantics from within KafKa are also substantial. 
As noted previously, the translation is not obligated by transient to check method argument types before entry, and as a result, every call, 
typed or untyped, in transient is an untyped call. Likewise, every typed method call must be guarded with a cast to ensure that 
the return type of the method is correct, as shown in \RuleRef{GRA2}.
 

\begin{mathpar}
\IRule{GRA1}{\HasType{\E}\x\t}{\GenCast{\K}\E\x{\ShaCast\t\x}\t}


\IRule[width=30em]{GRA2}{
    \GenCast\K\Env{\e_1}{\e_3}{\C} \\ \m({\t_1}):\t_2 \in \classoff\C\K \\ \b{\AnaCast\K\Env{\e_2}{\e_4}{\t_1}}
}{
    \GenCast\K\Env{\Call{\e_1}\m{{\e_2}}}{\ShaCast{\t_2}{(\DynCall{\SubCast{\any}{\e_3})}\m{\SubCast{\any}{\e_4}}}}{\t_2}
}

\IRule{GRA3}{
    \GenCast\K\Env{\e_1}{\e_3}{\any} \\ {\AnaCast\K\Env{\e_2}{\e_4}{\any}}
}{
    \GenCast\K\Env{\Call{\e_1}\m{{\e_2}}}{\DynCall{\e_3}\m{{\e_4}}}{\any}
}

\IRule[width=20em]{GRA4}{
    \HasType{\E}\this\C \\ \f(\b{\t_1}):\t_2 \in \classoff\C\K \\ {\AnaCast\K\Env{\e}{\ep}{\t_1}}
}{
    \GenCast\K\Env{\Call{\this}\f{\b\e}}{\Call{\this}\f{\ep}}{\any}
}

\IRule{GRA5}{
  \b{\AnaCast{\K}\E{\e_1}{\e_2}\t} \\ 
  \Class \C {\b{\Ftype\f\t}} {\b{\md}}
  }{\GenCast\K\Env{\New\C{\b{\e_1}}}{\New\C{\b{\e_2}}}{\C}}
\end{mathpar}

The lack of statically typable calls in the transient semantics means that a pure implementation of transient in 
\kafka would entail no fields ever being accessed using the setter or getter, as \kafka forbids accessing untyped fields.
To overcome this issue rule \RuleRef{GRA4} is added, which allows the definition of self-referential field access. In a transient 
system, the only type that is absolutely known at any time is the self-reference, which is use to access fields on the 
self object. As a result, in \kafka the translation will wrap field accessors in method calls.

\begin{mathpar}
\IRule{GRAASC1}{
  \GenCast\K\E\e\ep\tp \\
  \K \vdash \tp \Sub \t
}{
  \AnaCast\K\E\e\ep\t
}

\IRule{GRAASC2}{
  \GenCast\K\E\e\ep\tp \\
  \consistent\K\tp\t
}{
  \AnaCast\K\E\e\ep\t
}
\end{mathpar}

The last notable rule in the transient translation is \RuleRef{GRAASC2}. In gradual type systems with consistency, such as the monotonic system, 
consistency is used to conclude an analytic judgment, as consistency allows the system to break type guarantees, adding and removing types from sub-parts of a program.
Consistency within \kafka is defined in a later section, detailing the monotonic cast semantic and the translation for the monotonic system.   
However, in the transient semantics, the rest of the program makes no type assumptions that may be violated by consistency. Even when the 
translation takes a particularly weak perspective on the interpretation of a transient type into \kafka. Even a type system that
fully represents a transient type (e.g. one that tracks only method names) will accept structurally consistent values under the 
same type. As a result, consistent values are allowed to be used with no additional casts.

\section{Translation: Typed Racket}


Typed Racket is not a typical gradually typed language, as it has no untyped code.
The gradual nature of Typed Racket, instead, comes from the interactions between Typed Racket modules and 
(untyped) Racket modules. Therefore, we refer to Typed Racket as the combination of both 
Typed Racket and (untyped) Racket. Typed Racket programs are typed on a module by module basis, 
rather than expression by expression.

Additionally, unlike the Thorn system, Typed Racket does not base its type 
system on object \emph{identity}, but rather on object \emph{behaviour}. If an 
untyped object is brought in from (untyped) Racket and a Typed Racket type 
applied to it, then Typed Racket cannot check it to ensure that the type 
assertion is statically verified, like Thorn can, but instead has to \emph{wrap}
it to verify that it will behave to the type specification in the future.

In our model of Typed Racket and Racket programs, we break from this ``macro''
model of gradual typing, as it does not effect the fundamental semantics of the
gradual typing system. Instead, we apply the same requirements that \kafka has
onto Typed Racket classes - that is, each function must either declare a type
or be fully dynamically typed, both options allowing mixed typed/untyped code
in their bodies.

In order to support this behavioural semantics, we will have to extend the core 
\kafka language with a new cast operation, ensuring that object {behaviour}
matches the types on the object. For an expression \e and type \t, we will 
write this as  \BehCast\t\e, and it has basic typing and semantic rules depicted 
in figure~\ref{fig:behrules}.

\begin{figure}[h!]
\begin{minipage}{0.35\textwidth}
\begin{mathpar}
\IRule{W10}{
  \EnvType \Env\s\K\e\tp
}{
  \EnvType \Env\s\K{\BehCast\t\e}\t
}
\end{mathpar}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\begin{tabular}{l@{}l@{~}l@{~}l}
\CondRule{E11}{  %% Behavioral cast  
  \behcast \a\t\s\K  \Kp\ap\sp    
}{    
  \ReduceA  \K{\BehCast \t\a}\s \Kp\ap\sp   
}
\end{tabular}
\end{minipage}
\caption{Behavioural cast static and dynamic rules}
\label{fig:behrules}
\end{figure}

We will go into the details of $\behcast\a\t\s\K$ later, but observe that, 
despite not performing any dynamic check, we are able to say that the type is
correct according to the \kafka type system. This arises from the wrapper 
ensuring that the object is observably type correct, with any mismatch between
the typed and untyped code getting caught before the bad value reaches typed
code.

As a result of the strong type invariants that are exposed to the static code,
our translation from our version of the Typed Racket language to \kafka is 
fairly simple, only differing substantially from the optionally-typed system in 
two key analytic cases.

\begin{mathpar}
\IRule{PT}{
  {\classtrans{\K}{\K}{\K'}} \\ \GenCast{\K}{\cdot}{\e}{\ep}{\t} 
}{\progtrans{\e~\K}{\e'~{\K'}}}

\IRule{CR1}{ 
  \b{\methtrans {\K}{\C}{\md}{\md'}{}} \\
  \classtrans {\K}{\Kp}\Kpp
}{
   \classtrans {\K}{{\Class \C{\b{\Ftype\f\t}}{\b\md}~\Kp}}{\Class \C {\b{\Ftype\f\t}}{\b{\md'}}~\Kpp}}

\IRule{CR2}{ 
}{
  \classtrans {\K}\cdot\cdot
}

\IRule{MT}{
  \AnaCast {\K}{\HT\this{\C}~\HT\x{\t}}{\e}\ep{\tp}
}{
  \methtrans {\K}{\C}{\Mdef\m\x{\t}{\tp}{\e}}{\Mdef\m\x\t\tp\ep}{}
}
\end{mathpar}

\begin{mathpar}
\IRule{TRA1}{\HasType{\Env}\x\t}{\GenCast{\K}\Env\x\x\t}

\IRule[width=30em]{TRA2}{
    \GenCast\K\Env{\e_1}{\e_3}{\C} \\ \n(\b{\t_1}):\t_2 \in \classoff\C\K \\ \b{\AnaCast\K\Env{\e_2}{\e_4}{\t_1}}
}{
    \GenCast\K\Env{\Call{\e_1}\n{\b{\e_2}}}{\Call{\e_3}\n{\b{\e_4}}}{\t_2}
}

\IRule{TRA3}{
    \GenCast\K\Env{\e_1}{\e_3}{\any} \\ {\AnaCast\K\Env{\e_2}{\e_4}{\any}}
}{
    \GenCast\K\Env{\Call{\e_1}\m{{\e_2}}}{\DynCall{\e_3}\m{{\e_4}}}{\any}
}

\IRule{TRA4}{
  \b{\AnaCast{\K}\Env{\e_1}{\e_2}\t} \\ 
  \Class \C {\b{\Ftype\f\t}} {\b{\md}}
  }{\GenCast\K\Env{\New\C{\b{\e_1}}}{\New\C{\b{\e_2}}}{\C}}
\end{mathpar}

\RuleRef{TRAASC2} and \RuleRef{TRAASC3} are the most important cases of cast 
insertion for our Typed Racket translation, and represent Racket objects 
crossing into Typed Racket and vice versa, respectively. In the case where we 
have an untyped object gaining a type assertion (\RuleRef{TRAASC2}), we use the
name cast to ensure that the value has all of the required method names 
(modelling Typed Racket's dynamics), and then use the behavioural cast operator.


\begin{mathpar}
\IRule{TRAASC1}{
  \GenCast\K\Env\e\ep\tp \\
  \K \vdash \tp \Sub \t
}{
  \AnaCast\K\Env\e\ep\t
}

\IRule{TRAASC2}{
  \GenCast\K\Env\e\ep\tp \\
  \t \neq \tp
}{
  \AnaCast\K\Env\e{\BehCast\t{\ShaCast\t\ep}}\t
}
\end{mathpar}

Now that we have seen how the guarantees provided by the behavioural casts can 
be used to ensure the safety of typed code, we will now examine how the 
behavioural cast can be implemented into \kafka.


\subsection{Behavioral Casts}

A behavioral cast \BehCast\t\a will return a fresh \ap that refers to an
object that behaves as if it was of type \t, and, if the underlying object
departs from the behaviour that was required of it, the wrapper object will get
stuck at an internal cast. Behavioural casts must be generative, as they produce
a new object which monitors the target object for conformance to the interface 
of \t. \figref{behave} details the semantics of this cast. \ruleref{BC1} is the
cast where an object \obj\C{\b\a} is cast to a class \Cp. This leads to the
creation of a wrapper class \k (under a new name \D). The class is appended
to the class table \K.  The cast returns a reference \ap to an instance of
this wrapper class pointing to the original object. The wrapper class is a
structural subtype of the target class, so \D\Sub\C holds. \ruleref{BC2}
handles the case where the target type of the cast is \any.


\begin{figure}[!ht]
\hrulefill
%%%%%%%%%%%%%%%%% BEHCAST %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\vspace{-2mm}

{  \small
  \begin{mathpar}
\IRule{BC1}{
  \App\s\a = \obj\C{\b{\a_1}}  \\
  \fresh\D \\\\
  \k = \wrap\C{\getmds\C\K}{\classoff\C\K}{\classoff\Cp\K}\D\\\\
  \fresh\app \\
  \sp = \Map \s{\Bind\app{\obj\D{\a}}} \\  
}{
  \behcast\a\Cp\s\K {\K\,\k}\app\sp
}

\IRule{BC2}{
  \App\s\a = \obj\C{\b{\a_1}}  \\
  \fresh\D \\\\
  \k = \wrapAny\C{\getmds\C\K}{\classoff\C\K}\D\\\\
  \fresh\ap \\
  \sp = \Map \s{\Bind\ap{\obj\D{\a}}} \\  
}{
  \behcast\a\any\s\K {\K\,\k}\ap\sp
}
\end{mathpar}}  

\vspace{-2mm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hrulefill
\caption{Behavioral casts.}\label{behave}
\end{figure}

\figref{wrap} details the construction of wrapper classes. A wrapper is a
class that has the distinguished field \that, at the type of the target
object and a set of methods that mirrors the methods of the target object
but with additionals casts to some of their arguments and return values.
For getters, setters and typed methods, the wrapper simply adds a behavioral
casts to argument, issues a typed call, and then casts of the result. For
untyped methods, a dynamic call is blanketed by casts to \any.

\newcommand{\rtranst}[6]{#1 \Rightarrow #2 ~ #3 / #4 \vdash #5 \looparrowright_{beh} #6}

\begin{figure}[!ht]
\hrulefill
\begin{mathpar}
\IRule{REW1}{ }{ \rtranst{\b{\mt}}{\b{\mtp}}\e\x\x{[\e/\x]\x} }

\IRule{REW2}{ \x \neq \x' }{ \rtranst{\b{\mt}}{\b{\mtp}}\e\x{\x'}{\x'} }
\\
\IRule[width=25em]{REW3}{ \Mtype\n{\b{\t_1}}{\tp_1} \in \b{\mt} \\ \Mtype\n{\b{\t_2}}{\tp_2} \in \b{\mtp} \\ \n = \f \vee \tp[2] \neq \any  \\ 
\b{\rtranst{\b{\mt}}{\b{\mtp}}\e\x{\e}{\ep}}}{\rtranst{\b{\mt}}{\b{\mtp}}\e\x{\Call{\this}\n{\b\e}}{\BehCast{\tp_1}{\Call{\this}\n{\b{\BehCast{\t_2}{\ep}}}}}}
\\
\IRule[width=18em]{REW4}{ \Mtype\m{{\t_1}}{\tp_1} \in \b{\mt} \\ \Mtype\m{{\any}}{\any} \in \b{\mtp} \\ 
\b{\rtranst{\b{\mt}}{\b{\mtp}}\e\x{\e}{\ep}}}{\rtranst{\b{\mt}}{\b{\mtp}}\e\x{\Call{\this}\m{\e}}{\BehCast{\tp_1}{\DynCall{\this}\m{{\BehCast{\any}{\ep}}}}}}

\IRule[width=25em]{REW5}{ \Mtype\n{\b{\t_1}}{\tp_1} \in \b{\mt} \\ \Mtype\n{\b{\t_2}}{\tp_2} \not\in \b{\mtp}  \\ 
\b{\rtranst{\b{\mt}}{\b{\mtp}}\e\x{\e}{\ep}}}{\rtranst{\b{\mt}}{\b{\mtp}}\e\x{\Call{\this}\n{\b\e}}{{\Call{\this}\n{\b{{\ep}}}}}}

\IRule[width=20em]{REW6}{ \e_1 \neq \this \\ \rtranst{\b{\mt}}{\b{\mtp}}\e\x{\e_1}{\e_2} \\ \b{\rtranst{\b{\mt}}{\b{\mtp}}\e\x{\ep_1}{\ep_2}}}{\rtranst{\b{\mt}}{\b{\mtp}}\e\x{\Call{\e_1}\n{\b{\ep_1}}}{\Call{\e_2}\n{\b{\ep_2}}}}

\IRule{REW7}{ \rtranst{\b{\mt}}{\b{\mtp}}\e\x{\e_1}{\e_2} \\ \rtranst{\b{\mt}}{\b{\mtp}}\e\x{\ep_1}{\ep_2}}{\rtranst{\b{\mt}}{\b{\mtp}}\e\x{\DynCall{\e_1}\m{\ep_1}}{\DynCall{\e_2}\m{\ep_2}}}

\IRule{REW8}{ \b{\rtranst{\b{\mt}}{\b{\mtp}}\e\x{\e}{\ep}} }{\rtranst{\b\mt}{\b\mtp}\e\x{\New\C{\b\e}}{\New\C{\b\ep}}}
\end{mathpar}

\vspace{-2mm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hrulefill
\caption{Behavioral dynamic expression translation.}\label{behtrans}
\end{figure}

A key issue that is encountered in any wrapper-based approach surrounds the 
handling of the \this keyword, and deciding what happens if the object ``under''
the type invariant calls itself. From a pure type correctness standpoint, 
the wrapped object need not observe the requirements of the type that it is
observed under, but Typed Racket requires that, if an object is called through a
warpper, then that object should observe the requirements of that wrapper 
internally.

\begin{figure}[!ht]
\begin{lstlisting}
class C { 
  m(x:*):* { this@n(x) }
  n(x:*):* { x }}
class D { 
  m(x:C):C { new C() }
  n(x:D):D { new D()}}
(<*>(<D>new C()))@m(new C())
\end{lstlisting}
\caption{Internal behaviour is effected by external types}
\label{fig:intbeh}
\end{figure}

This can be seen in in figure~\ref{fig:intbeh}. Here, the instance of \C will 
always return another instance of \C, using the internal method \n to actually
create the new object. However, if we then create another class \D that requires
\n to return type \D and apply a Typed Racket cast to \D on the instance of \C,
then call \m, we find that an error is produced when \C's implementation of \n
returns a \C instead of a \D.

Checking this functionality with wrappers is difficult, as \kafka does not allow
the wrapper to set the object identity for the called object, and therefore 
internal calls are left unchecked by the wrapper. To ensure that internal calls
are safe, we have to prevent the call from reaching the wrapped object, by 
lifting the body of the wrapped method into the wrapper object.

However, a considerable technical hurdle to this approach is that the expression
\e inside the called method is only well-typed with respect to the wrapped class
, not the wrapper that sits on top of it. We overcome this issue through a 
special ``type-fixing'' operation, shown in figure~\ref{behtrans}, which 
ensures the type correctness of wrapped method bodies once lifted into the 
wrapper.

To illustrate the operational principle behind the expression translation 
mechanism, consider figure~\ref{fig:intbeh}, where we call \n via \m. If we 
consider unrolling a wrapper intermediate between \m and \n into \m, we find 
that \m has body \BehCast\D{\Call\this\n{\BehCast\D\x}}, which is equivalent
to rule \RuleRef{REW3}.

\begin{figure}[!ht]
\hrulefill 
\scriptsize
\newcommand{\bscast}[2]{\EM{\BehCast{#1}{\ShaCast{#1}{#2}}}}
\vspace{4mm}
%%%%%%%%%%%%%%%%%%%%%% WRAP %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\IGNOREUNLESSNEEDED{
\[\begin{array}{@{}ll@{}l@{}r@{~}c@{~}r}
    \wrap\C{\b\md}\bmt\bmtp\D = \\
\SP \class ~\D ~ \{\\
\SPP \Fdef\that\C \\
\SPP \Mdefz\f{\tp}{~\bscast\tp{\Get{\Get\this\that}\f}~}
&    \All \f \f\neq\that\,\wedge~\Mtype\f{}\t\in\bmt &\wedge& \Mtype\f{}\tp \in \bmtp
\\
\SPP \Mdef\f\x\tp\tp {~\bscast\tp{\Set{\Get\this\that}\f{\bscast\t\x}}~}
&    \All \f \f\neq\that\wedge~\Mtype\f\t\t \in \bmt &\wedge& \Mtype\f\tp\tp \in \bmtp
\\
\SPP \Mdef\m\x\t\tp {~\bscast\tp{{\ep}}~}
&     \All \m \Mdef\m\x\Cp\Cpp\e\in\b\md &\wedge& \Mtype\m\t\tp\in\bmtp \\
&\multicolumn{5}{l}{~\wedge~\rtranst{\bmt}\bmtp{(\bscast\Cp\x)}\x{\e}{\ep}}
\\
\SPP \Mdef\m\x\any\any {~\SubCast\any{\Call\this\m{\bscast{\t}\x}}~}
&     \All \m \Mdef\m\x\Cp\Cpp\e\in\b\md &\wedge& \Mtype\m\t\tp\in\bmtp\\
&\multicolumn{5}{l}{~\wedge~\Mdef\m\x\any\any{\e'}\not\in\b\md}
\\
\SPP \Mdef\m\x\t\tp{~\bscast\tp{\ep}~}
&    \All \m \Mdef\m\x\any\any\e\in\b\md &\wedge& \Mtype\m\t\tp\in\bmtp \\
&\multicolumn{5}{l}{~\wedge~\rtranst{\bmt}\bmtp{(\bscast\any\x)}\x\e{\ep}}
\\
\SPP \Mdefz\f\t { ~\Get{\Get\this\that}\f~}
&    \All \f \f\neq\that\,\wedge~\Mtype\f{}\t \in \bmt &\wedge& \Mtype\f{}\tp \not\in \bmtp
\\
\SPP \Mdef\f\x\t\t { ~\Set{\Get\this\that}\f\x~}
&    \All \f \f\neq\that\,\wedge\,\Mtype\f\t\t \in \bmt&\wedge& \Mtype\f\tp\tp \not\in \bmtp
\\
\SPP \Mdef\m\x{\Cp}{\Cpp} {~\ep~}
&    \All \m  \Mdef\m\x\Cp\Cpp\e\in\b\md &\wedge& \Mtype\m\t\tp\not\in \bmtp \\
&\multicolumn{5}{l}{~\wedge~\rtranst{\bmt}\bmtp\x\x{\e}{\ep}}
\\
\SPP \Mdef\m\x\any\any {~\ep~}
&    \All \m  \Mdef\m\x\any\any\e\in\b\md  &\wedge& \Mtype\m\t\tp\not\in\bmtp \\
&\multicolumn{5}{l}{~\wedge~\rtranst{\bmt}\bmtp\x\x{\e}{\ep}}
\\
\SP \}
\\
\wrapAny\C\bmd\bmt\D = \\
\SP \class~\D~\{\\
\SPP \Fdef \that \C\\ 
\SPP   \Mdefz\f\any{~\BehCast\any{\Get{{\Get\this\that}}\f}~}
&  \All \f \f\neq\that\,\wedge\, \Mtype\f{}\t \in \bmt\\
\SPP   \Mdef\f\x\any\any{~\BehCast\any{\Set{\Get\this\that}\f{\bscast\t\x}}~}
&  \All \f  \f\neq\that\,\wedge\,\Mtype\f\t\t \in \bmt\\
\SPP   \Mdef\m\x\any\any {~\BehCast\any{{\ep}}~}
&  \All \m \Mdef\m\x\t\t\e\in\b\md \\
&\multicolumn{5}{l}{~\wedge~\rtranst{\bmt}{\dyn{\bmt}}{(\BehCast\t\x)}\x{\e}{\ep}}
\\
\SP \}\\
\end{array}\]
%}%%END IGNORE
%   \includegraphics[width=.9\textwidth]{figures/wrapDefinition}
% TODO: untyped(mt)
\hrulefill
%%%%%%%%%%%%%%%%%%%%%%%%%% WRAP %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \caption{Wrapper class generation.}\label{wrap}
\end{figure}

Another challenge is that multiple wrappers can be layered on top of a target object. Each time a
reference crosses a boundary between typed and untyped code, it will accrue
an additional wrapper. When a method is invoked on a wrapper chair, that
method will be invoked on every wrapper, until finding its way to the target
object. A key property of the wrapper generation functions of \figref{wrap}
is that methods should not be ``lost''. That is to say, any method in the
target object, even if it is not in the type it is being cast to, will be
retained in the wrapper.  This property is somewhat unconventional, and its
need is illustrated in \figref{ctod}. Class \C and \D are preexisting.  They
are not related by subtyping as \any is not a supertype of \E. The first
cast from \C to \D, results in the generation of class \EMxt{CtoD}. The
wrapper class is a subtype of \D but it also has method \mp only found in
class \C.  The cast from \EMxt{CtoD} back to \C leads to the generation of
wrapper class \EMxt{CtoDtoC}. The latter is a subtype of \C and has a rather
interesting method \m which is dynamic and thus must be invoked dynamically.
The receiver is cast to \any using a subtype cast. The argument on the other
hand is converted to dynamic with a behavioral cast. The return value is
converted to the expected return type with another behavioral cast.


%%%%%%%%%%%%%%%%% EXAMPLE  <C><D>new C %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}
\footnotesize
\begin{tabular}{ll}\begin{minipage}{6cm}
\[\begin{array}{l}
\class ~\C~ \{\\
\SP  \Mdef\m\e\x\E\x\\
\SP  \Mdef\mp\e\x\E\x\\
\}\\[2mm]
\class ~\EMxt{CtoD}~ \{\\
\SP  \Fdef\that\C\\
\SP  \Mdef \m\x\any\any{\Call{\Get\this\that}\m{\BehCast\E\x}}\\
\SP  \Mdef \mp\e\x\E{\Call{\Get\this\that}\mp\x}\\
\}\\
\end{array}\]
\end{minipage}
&
\begin{minipage}{5cm}
\[\begin{array}{l}
\class ~\D~ \{\\
\SP  \Mdef\m\x\any\any\x\\
\}
\\
\\[2mm]
\class ~\EMxt{CtoDtoC}~ \{\\
\SP  \Fdef\that{\EMxt{CtoD}}\\
\SP  \Mdef\m\e\x\E{ \BehCast\E{\DynCall{(\SubCast\any{\Get\this\that})}\m{\BehCast\any\x}}}\\
\SP  \Mdef\mp\e\x\E{ \Call{\Get\this\that}\mp{\x}}\\
\}\\
\end{array}\]
\end{minipage}
\end{tabular}
\caption{Classes generated by \BehCast\C{(\BehCast\D{\New\C{}})}.}
\label{ctod}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Translation: Reticulated Python - Monotonic Semantics}

At the surface language level, the Monotonic semantics are very similar to that used by the transient semantics and Typed Racket, 
as casts are inserted at type boundaries.

The most notable difference between Reticulated Python and other gradually typed languages is the use of \emph{consistency},
an operator broadly that means one type is compatible with another type. In our system, we define conistency as follows:
\begin{mathpar}
\IRule{C1}{\tmeet\t\tp\cdot\K = \tpp\,\Kp}{\consistent\K{\t}{\tp}}
\end{mathpar}

% broken: partially typed calls

\newcommand{\monowrap}[2]{\xt{mwrap}(#1,#2)}
\begin{mathpar}
\IRule{PT}{
  {\classtrans{\K}{\K}{\K'}} \\ \GenCast{\K}{\cdot}{\e}{\ep}{\t} 
}{\progtrans{\e~\K}{\e'~{\K'}}}

\IRule{MCT1}{
  \D \text{ fresh}\\
  \k = \classgen{\C,{\classoff\C\K},{\classoff\C\K},\D,\K}
}{
  \monowrap{\C}{\K} = \D~\k
}

\IRule{MCT2}{
}{
  \monowrap{\any}{\K} = \any
}

\IRule{CR1}{ 
  \b{\methtrans \K\C\md{\md'}{\K_m}} \\
  \classtrans \K\Kp\Kpp \\
  \b{\monowrap\t\Kpp = \tp~\Kppp}
}{
   \classtrans \K{\Class \C{\b{\Ftype\f\t}}{\b\md}~\Kp}{\Class \C {\b{\Ftype\f\tp}}{\b{\md'}}~\Kpp~\K_m~\b{\Kppp}}}

\IRule{CR2}{ 
}{
  \classtrans \K\cdot\cdot
}

\IRule{MT}{
  \AnaCast \K{\HT\this\C~\HT\x\t}\e\ep\tp \\
  \monowrap{\t_1}\K = \t_2~\K_1 \\
  \monowrap{\tp_1}\K = \tp_2~\K_2
}{
  \methtrans \K\C{\Mdef\m\x{\t_1}{\tp_1}\e}{\Mdef\m\x{\t_2}{\tp_2}\ep}{\K_1~\K_2}
}
\end{mathpar}


\newcommand{\isstatic}[3]{\text{static}(#1,#2,#3)}
\begin{mathpar}
\IRule{A1}{\HasType{\E}\x\t}{\GenCast{\K}\E\x\x\t}

\IRule[width=30em]{A2}{
    \GenCast\K\Env{\e_1}{\e_3}{\C} \\ \n(\b{\t_1}):\t_2 \in \classoff\C\K \\ \isstatic{\t_1}{\K}{\cdot} \vee \n=\f \\ \b{\AnaCast\K\Env{\e_2}{\e_4}{\t_1}}
}{
    \GenCast\K\Env{\Call{\e_1}\n{\b{\e_2}}}{\Call{\e_3}\n{\b{\e_4}}}{\t_2}
}

\IRule[width=30em]{A3}{
    \GenCast\K\Env{\e_1}{\e_3}{\C} \\ \m({\t_1}):\t_2 \in \classoff\C\K \\ \lnot\isstatic{\t_1}{\K}{\cdot} \\ \b{\AnaCast\K\Env{\e_2}{\e_4}{\any}}
}{
    \GenCast\K\Env{\Call{\e_1}\m{{\e_2}}}{\DynCall{(\MonCast\any\e_3)}\m{{\e_4}}}{\t_2}
}

\IRule{A8}{
    \GenCast\K\Env{\e_1}{\e_3}{\any} \\ {\AnaCast\K\Env{\e_2}{\e_4}{\any}}
}{
    \GenCast\K\Env{\Call{\e_1}\m{{\e_2}}}{\DynCall{\e_3}\m{{\e_4}}}{\any}
}

\IRule{A11}{
  \b{\AnaCast{\K}\E{\e_1}{\e_2}\t} \\ 
  \Class \C {\b{\Ftype\f\t}} {\b{\md}} \\
  \D~\text{fresh} \\
  \D = \classgen{\C,\classoff\C\K,\classoff\C\K,\D,\K} \\
  }{\GenCast\K\Env{\New\C{\b{\e_1}}}{\New\D{\New\C{\b{\e_2}}}}{\C}}
\end{mathpar}

\begin{mathpar}
\IRule{AASC1}{
  \GenCast\K\Env\e\ep\tp \\
  \K \vdash \tp \Sub \t
}{
  \AnaCast\K\Env\e\ep\t
}

\IRule{AASC2}{
  \GenCast\K\Env\e\ep\tp \\
  \consistent\K\t\tp
}{
  \AnaCast\K\Env\e{\MonCast\t\ep}\t
}
\end{mathpar}

\subsection{Monotone Casts}


The monotone cast \MonCast\C\a imposes the type \C onto the object
at \a, as well as every object transitively reachable from it. The motivation 
for this cast comes from~\cite{Siek2015}, where it is used to maintain the
type correctness of every reference in the program.

\begin{figure}[h!]
\begin{tabular}{ll}
\begin{minipage}[b]{4cm}
\lstset{framesep=4pt}
\begin{lstlisting}
class C { f : * }
class D { 
  m (x:*):* {x}
}
d:* = new D()
a:* = new C(d)
[heap snapshot 1]

class E { f : F }
class F { 
  m (x:E):E {x}
}

e:E = <E>a
[heap snapshot 2]
d.m(d)
\end{lstlisting}
\vspace{-9.2em}
\end{minipage}
&
\begin{tabular}{l}
Heap snapshot 1: \\
\begin{minipage}{8cm}
\begin{tikzpicture}[framed,my shape/.style={
rectangle split, rectangle split parts=#1, draw, anchor=text east}]
\node (ref) at (0,0) {$\HT\a\any$};
\node (refb) at (0,-1.5) {$\HT{\xt{d}}\any$};

\node (C1) [my shape=2,right of=ref, anchor = text west]
{\C\nodepart{two}$\f : \any$};

\node (D1) [my shape=2,right=of C1.two east, anchor=text west,shift={(0,-.1)}]
{\D\nodepart{two}$\Mtype\m\any\any$};

\draw[->,very thick] (ref.east) -> (C1.text west);
\draw[->,very thick] (refb.east) -> ($(D1.text west)+(0,-.1)$);
\draw[->,very thick] (C1.two east) -> ($(D1.text west)+(0,.1)$);
\end{tikzpicture}
\end{minipage}\\
Heap snapshot 2: \\
\begin{minipage}{8cm}
\begin{tikzpicture}[framed,my shape/.style={
rectangle split, rectangle split parts=#1, draw, anchor=text east}]
\node (ref) at (0,0) {$\HT\a\any$};
\node (refb) at (0,-1.5) {$\HT{\xt{d}}\any$};
\node (refe) at (0,-.5) {$\HT{\xt{e}}\E$};

\node (C1) [my shape=2,right of=ref, anchor = text west,shift={(0,-.1)}]
{\C\nodepart{two}$\f : \xt{F}$};

\node (D1) [my shape=2,right=of C1.two east, anchor=text west,shift={(0,-.1)}]
{\D\nodepart{two}$\Mtype\m{\xt{E}}{\xt{E}}$};

\draw[->,very thick] (ref.east) -> ($(C1.text west)+(0,.1)$);
\draw[->,very thick] (refb.east) -> ($(D1.text west)+(0,-.1)$);
\draw[->,very thick] (refe.east) -> ($(C1.text west)+(0,-.1)$);
\draw[->,very thick] (C1.two east) -> ($(D1.text west)+(0,.1)$);
\end{tikzpicture}
\end{minipage}
\end{tabular}
\vspace{1em}
\end{tabular}
\caption{Execution under the monotonic semantics}
\label{fig:mono_ex1}
\end{figure}

This is illustrated in figure~\ref{fig:mono_ex1}. Here, we create a new 
instance of class \D, then create an instance of class \C that points at that
object. At this point, the field \f on \C has type \any, and the method \m
on \D has fully dynamic argument and return type.

However, we then introduce classes \E and \xt{F}, which are structurally 
identical to \C and \D, but specify types for the field and method. If we then
cast our instance of \C, \a in the program, to \C, monotonic will ensure that
any access to field \f or to method \m from anywhere else in the program will
follow the type invariants asserted by the cast to \E.

As a result, our reference to the instance of \D, named \xt{d} and saved from
earlier in the program, now has hidden invariants applied to it. Despite being
under type \any, when we try to invoke method \m on this apparently dynamic 
object, we will get a cast failure, when monotonic checks to make sure that the
provided argument is of type \E. 

Because of this property, the monotone cast is generative. In order to guarantee
the future type correctness of all references, monotonic has to generate guards
that check the argument and return type of every method, and at least check the
type of any field set, ensuring that they maintain consistency with the 
maximally static type. Additionally, because monotonic has to ensure that 
prior references respect future type invariants, it has to do in-place updates
of any object whose type is altered by a cast update.

In the extreme, one cast could cause all objects in the heap to be
retyped. To prevent pathological cases, monotone casts, only modify the heap
if the target \C has fewer occurences of \any than the original type of the
object at \a (and transitively so for types appearing in \t and reachable
from \a).  When a type \C does not have any occurence of the dynamic type,
denoted by \statictype\C\K\V, monotone casts will leave the object and the
heap unchanged.

The key challenge is that after a monotone
cast in a heap \s, every reference should still be valid.  If a reference
has a type other than \any, then the cast will preserve correctness of that
reference. To accomplish this, the cast ensure two properties hold:
\begin{itemize}
\item The values that \emph{currently} exist cannot violate any of the types
  that point to them. Casting needs to recursively ensure that all values
  referred to by the current object are of the claimed type.
\item Functions can not be called with or return values that violate any of
  the types that they are referred to with. The behaviour of the class needs
  to check that its types are not violated by lesser-typed call sites.
\end{itemize}
The second property is strongly reminisicent of the behavioural semantics,
though with the interesting caveat that we now need to make sure that
\emph{all} method invocations follow the typed calling conventions, rather
than just the ones that inherit this particular type assertion.

In \kafka, we implement the monotonic cast in a generative manner, as noted 
previously. However, we cannot take the simple in-place replacement route, as
\cite{Siek2015} did, due to the nature of \kafka. In order to ensure that the
type of a field is respected, the monotonic cast will have to add in a setter
that checks the value that it is given against the type of the field, when
a lesser-typed call site is used to set the field. However, \kafka prohibits
both a field and a getter or setter from existing, as a concequence of its 
treatment of fields and getters and setters uniformly. 

Because of this issue, we instead implement the monotonic cast by adding a 
single wrapper over each object, similar to the ``identity preserving membrane''
described in \cite{keil_et_al:DARTS:2015:5511}. The wrappers will preserve the
externally-facing interface (up to a point) and the relations between classes,
while ensuring that all properties guaranteed in the monotonic system remain.

As a result of this (and the static translation required to allow the monotonic
semantics to work correctly), instead of the simple figure~\ref{fig:mono_ex1}, 
\kafka will actually execute as depicted in figure~\ref{fig:mono_ex2}. Note that
for compactness, we elide class definitions that are in figure
~\ref{fig:mono_ex1}, and class definitions that will be generated but that
do not appear in the dynamic execution of the program.

\begin{figure}[h!]
FIXME
\begin{tabular}{ll}
\begin{minipage}[b]{4.5cm}
\lstset{framesep=4pt}
\begin{lstlisting}
class CW { f : * }
class DW { 
  m (x:*):* {x}
}
d:* = new DW(new D())
a:* = new CW(new C(d))
[heap snapshot 1]

class EW { f : F }
class FW { 
  m (x:E):E {x}
}

e:E = <E>a
[heap snapshot 2]
d.m(d)
\end{lstlisting}
\vspace{-9.2em}
\end{minipage}
&
\begin{tabular}{l}
Heap snapshot 1: \\
\begin{minipage}{8cm}
\begin{tikzpicture}[framed,my shape/.style={
rectangle split, rectangle split parts=#1, draw, anchor=text east}]
\node (ref) at (0,0) {$\HT\a\any$};
\node (refb) at (0,-1.5) {$\HT{\xt{d}}\any$};

\node (C1) [my shape=2,right of=ref, anchor = text west]
{\C\nodepart{two}$\f : \any$};

\node (D1) [my shape=2,right=of C1.two east, anchor=text west,shift={(0,-.1)}]
{\D\nodepart{two}$\Mtype\m\any\any$};

\draw[->,very thick] (ref.east) -> (C1.text west);
\draw[->,very thick] (refb.east) -> ($(D1.text west)+(0,-.1)$);
\draw[->,very thick] (C1.two east) -> ($(D1.text west)+(0,.1)$);
\end{tikzpicture}
\end{minipage}\\
Heap snapshot 2: \\
\begin{minipage}{8cm}
\begin{tikzpicture}[framed,my shape/.style={
rectangle split, rectangle split parts=#1, draw, anchor=text east}]
\node (ref) at (0,0) {$\HT\a\any$};
\node (refb) at (0,-1.5) {$\HT{\xt{d}}\any$};
\node (refe) at (0,-.5) {$\HT{\xt{e}}\E$};

\node (C1) [my shape=2,right of=ref, anchor = text west,shift={(0,-.1)}]
{\C\nodepart{two}$\f : \xt{F}$};

\node (D1) [my shape=2,right=of C1.two east, anchor=text west,shift={(0,-.1)}]
{\D\nodepart{two}$\Mtype\m{\xt{E}}{\xt{E}}$};

\draw[->,very thick] (ref.east) -> ($(C1.text west)+(0,.1)$);
\draw[->,very thick] (refb.east) -> ($(D1.text west)+(0,-.1)$);
\draw[->,very thick] (refe.east) -> ($(C1.text west)+(0,-.1)$);
\draw[->,very thick] (C1.two east) -> ($(D1.text west)+(0,.1)$);
\end{tikzpicture}
\end{minipage}
\end{tabular}
\vspace{1em}
\end{tabular}
\caption{Execution under the monotonic semantics}
\label{fig:mono_ex2}
\end{figure}

Meta-variable \S denotes a map from addresses to classes, thus
\Map\S{\Bind\a\C} gives type \C to address \a. The function \htype\a\S\s\K
returns the class of the object at address \a.  \htype\a\S\s\K is \C if \C =
\App\S\a or if $\a\not\in\S$ and \obj\C{\b\a}=\App\s\a.


The monotone cast function \moncast\a\t\s\K\Kp\sp takes the address of the
cast target \a, a target type \t, the current heap \s and class table \K, and
will return an update heap \sp and an updated class table \Kp.

We use \Dom\S to get a sequence of addresses that have to be retyped.

\begin{mathpar}
\IRule{CM}{
  \retype \a\t\cdot\s\K = \S\,\Kp\\
  \spec {\Dom\S} \S\s\Kp = \sp~\Kpp
}{
  \moncast \a\t\s\K \Kpp \sp\\
}
\end{mathpar}


We write \t\EQ\tp to denote that both \StrSub{}\K\t\tp and
\StrSub{}\K\tp\t hold.

The retype function \retype{\b\a}{\b\t}\S\s\K, take a list of object
addresses \b\a and a list of types to ascribe to them \b\t, and updates the
heap \s and class table \K.

% TODO: Gettype from mtype

\begin{mathpar}
\IRule{CRM1}{
%   \unwrap{\htype \a\S\s}{\K} = \C~\Kp\\
  \htype \a\S\s\K = \C~\Kp\\
  \tmeet\C\t\cdot\Kp = \D\,\Kpp\\ 
  \C\not\EQ\D  \\
  \ftypes \a\D \s\Kpp = \b\ap~\b\tp \\
  \Sp = \Map\S{\Bind\a\D } \\
  \retype{\b\ap}{\b\tp}\Sp\s\K = \Spp\,\K'''
}{
  \retype \a\t\S\s\K = \Spp\,\K'''
}

\IRule{CRM2}{
%   \unwrap{\htype \a\S\s}{\K} = \tp\,\Kp\\
%   \tmeet\tp\t\cdot\Kp = \tpp\,\Kpp \\
  \htype \a\S\s\K = \tp\,\Kp\\
  \tmeet\tp\t\cdot\Kp = \tpp\,\Kp \\
  \tp\EQ\tpp \\
}{
  \retype \a\t\S\s\K = \S~\Kpp
}

\IRule{CRM3}{
  \retype\a\t\S\s\K = \Sp\,\Kp\\
  \retype{\b\a}{\b\t}\Sp\s\Kp = \Spp\,\Kpp
}{
  \retype {\a\,\b\a}{\t\,\b\t}\S\s\K = \Spp\,\Kpp
}
\end{mathpar}

The heap specialization function \spec{\b\a}\S\s\K takes a
sequence of object addresses \b\a, a heap typing \S, a heap \s
and a class table \K and returns a new heap where the objects
have been retyped.

\begin{mathpar}
\IRule{CMS1}{
  \E \text{ fresh}\\
  \D = \App\S\a \\
  \obj\C{\ap} = \App\s\a \\
  \obj\Cp{\b\app} = \App\s\ap \\
  \classoff\Cp\Kpp = \b\mt \\
  \classoff\D\Kpp = \b\mtp \\  
  \names{\b\mtp} \subseteq \names{\b\mt}\\
  \Kp = \K~\classgen{\Cp,\b\mt,\b\mtp,\E,\K} \\
  \sp = \Map\s{\Bind\a{\E\{\ap\}}}
}{
  \spec \a\S\s\K = \sp~\Kp
}

\IRule{CMS2}{
  \spec \a\S\s\K = \sp\\
  \spec {\b\a}\S\sp\K =\spp
}{
   \spec {\a\,\b\a}\S\s\K = \spp
}
\end{mathpar}


% The \texttt{typemeet} function \tmeet\P\K\t\tp compute the meet of types \t
% and \tp, it returns a new type if needed and an updated class table.
% 
% For the case we call \tmeet\P\K\C\D, the function will have to create a new
% class \E that is the result of meeting \C with \D.

The \texttt{tmeet} function takes four arguments, the original type
$\t$, the cast type $\tp$, an environment $\P$, a class table $\K$, and
outputs a type $\tpp$ and a class table $\Kp$. The environment $\P$ is a set
of mappings from a pair of types ($\t,\tp$) to a type $\tpp$. 

In effect, \texttt{tmeet} takes the place of the $\sqcap$ operator in~\cite{Siek2015},
fufilling the same purpose. In short, the \texttt{tmeet} operator takes two types
and finds a third type that retains all of the type assertions in the two input types.

For example, consider figure~\ref{fig:tmeet_ex}, where we compute the meet of two types,
both of which have the same function, but alternate the typing for that function, where
\texttt{A} has the return type typed, whereas \texttt{B} has the argument typed. \texttt{tmeet}
will compute the result type as a new \texttt{C}, where both the argument and return type 
are typed.

\begin{figure}[!ht]
\begin{tabular}{r@{\hspace{1mm}}l@{}l@{}l@{}l@{\hspace{1.5mm}}l@{\hspace{1mm}}l@{}l}
\texttt{tmeet(}
& \texttt{A}
  & \texttt{,}
  \texttt{B}
  & \texttt{,}
  $\cdot$
  & \texttt{,}
  &
  \begin{minipage}{4.3cm}
    \begin{lstlisting}
class A {
   m(x: *): A {this}}

class B {
   m(x: B): * {this}}
      \end{lstlisting}    
  \end{minipage}
& 
\texttt{) = C,}
  &
  \begin{minipage}{4.3cm}
    \begin{lstlisting}
class A { ... }
class B { ... }
class C {
  m(x: B): A {this}
}
    \end{lstlisting}    
  \end{minipage}
\end{tabular}
\caption{Simple example of \texttt{tmeet} use}
\label{fig:tmeet_ex}
\end{figure}

This example uses 3 of \texttt{tmeet}'s 4 arugments, with an empty \P, first invoking \RuleRef{TM4},
which, via \xt{mmeet}, computes the meet of each of the arguments to \xt{m}, invoking \RuleRef{TM1}
and \RuleRef{TM2} for the argument and return type of \xt{m}.

\begin{figure}[!ht]
\begin{tabular}{r@{\hspace{1mm}}l@{}l@{}l@{}l@{\hspace{1.5mm}}l@{\hspace{1mm}}l@{}l}
\texttt{tmeet(}
& \texttt{A}
  & \texttt{,}
  \texttt{B}
  & \texttt{,}
  $\cdot$
  & \texttt{,}
  &
  \begin{minipage}{4.3cm}
    \begin{lstlisting}
class A {
   m(x: A): * {this}}

class B {
   m(x: B): * {this}}
      \end{lstlisting}    
  \end{minipage}
& 
\texttt{) = E,}
  &
  \begin{minipage}{4.3cm}
    \begin{lstlisting}
class A { ... }
class B { ... }
class E {
  m(x: E): * {this}
}
    \end{lstlisting}    
  \end{minipage}
\end{tabular}
\caption{\texttt{tmeet} over recursive classes}
\label{fig:tmeet_rec_ex}
\end{figure}

The third argument, \P, becomes important when we consider programs like the one in example~\ref{fig:tmeet_rec_ex}, where the meet 
of \xt{A} and \xt{B} recursively depends on the meet of \xt{A} and \xt{B}. If we proceeded naievely, without \P, \RuleRef{TM4} would
invoke \RuleRef{TM4} again to compute the meet of the arugments to \m. We use \P and \RuleRef{TM5} to avoid this.

\RuleRef{TM4} invokes \xt{mmeet} with an enriched \P, in much the same manner that the subtyping relation does, inserting the future
result of the meet of \xt{A} and \xt{B} (which, in this example, is \xt{E}) into \P, which will then be used by \RuleRef{TM5} to terminate
the recursion. We make a notable simplifcation in figure \ref{fig:tmeet_rec_ex}, however, where the covariant and contravariant cases of meet
produce the same result - our formal system instead generates different classes (which are identical to the \xt{E} in the figure) for each of 
these cases.

This last property comes out of a property of conistency. If we consider two types, $\C = \Type{\Mtype\m\any\any}$ and 
$\D = \Type{\Mtype\m\any\any, \Mtype\n\any\any}$, clearly $\D <: \C$ but not $\C <: \D$, and therefore, using the consistent subtyping relation from~\cite{SiekTaha07}, 
$\D \lesssim \C$ but not $\C \lesssim \D$. As a concequence, 

The \texttt{mtypes} function takes a class name $\C$ and the class table
$\K$, and outputs a list of typing signatures $\b\mt$ for every method in
class $\C$, which includes the implicit getter and setter methods for every
field in the definition of class $\C$.  (\textbf{Note}: An user cannot
define a getter or setter method for any field that already exists in the
class. Similarly, a field cannot be declared in a class that already has a
getter or setter method for that field. This is enforced by the
\texttt{overloading} function in class well-formedness.)

\begin{figure}[!ht]
\hrulefill

\opdef{
  $\tmeet{\t}{\tp}\P\K = \tpp\,\Kp$
}{
}
\begin{align*}
\P &::= \cdot \B \Map\P{\Bind{(\C,\D)}\Dp}
\end{align*}
\begin{mathpar}
\IRule{TM1}{ }{\tmeet\C\any\P\K = \C\,\K}

\IRule{TM2}{ }{\tmeet\any\C\P\K = \C\,\K}

\IRule{TM3}{ }{\tmeet\t\t\P\K = \t\,\K}

\IRule{TM4}{
  \fresh\E\\
  (\C,\D) \not\in\P \\
  \Pp = \Map\P{\Bind{(\C,\D)}\E} \\
  \mtypes\C\K = {\b\mt}\\
  \mtypes\D\K = {\b\mtp}\\
  \mmeet{\b\mt}{\b\mtp}\Pp\K = \b\mtpp\,\Kp\\
  \Kpp = \Kp~\typegen{\b\mtpp}\E\\
}{
    \tmeet\C\D\P\K = \E\,\Kpp
}

\IRule{TM5}{
    \P(\C,\D) = \E
}{
    \tmeet\C\D\P\K = \E\,\K
}
\end{mathpar}

\vspace{-2mm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hrulefill
\caption{Type meet.}\label{monmeet}
\end{figure}


The \texttt{methmeet} function is used by the \texttt{typemeet} functions to
perform the meet over the typing of each method within a class definition.
The \texttt{methmeet} function also takes four arguments, the method
signatures of the original class $\b\mt$, the method signatures of the cast
class $\b\mtp$, the environment $\P$, a class table $\K$, and outputs method
types $\b\mtpp$ and a class table $\Kp$. The \texttt{MM2} rule operators
over the method typing signature of field setter, field getter, and regular
method.

The function \ftypes\a\C\s\K returns the old references and the new types
for them according to the new wrapper \C.

\newcommand{\rtranstz}[4]{#1 \Rightarrow #2 \vdash #3 \looparrowright_{mon} #4}

\begin{figure}[!ht]
\hrulefill
\begin{mathpar}
\IRule{MREW1}{ }{ \rtranstz{\b{\mt}}{\b{\mtp}}\x\x }
\\
\IRule[width=25em]{MREW2}{ 
  \Mtype\n{\b{\t_1}}{\tp_1} \in \b{\mt} \\ 
  \Mtype\n{\b{\t_2}}{\tp_2} \in \b{\mtp} \\ 
  \n = \f \vee \t_1 \neq \any  \\ 
  \b{\rtranstz{\b{\mt}}{\b{\mtp}}{\e}{\ep}}
}{
  \rtranstz{\b{\mt}}{\b{\mtp}}{\Call{\this}\n{\b\e}}{\MonCast{\tp_1}{\Call{\this}\n{\b{\MonCast{\t_2}{\ep}}}}}
}
\\

\IRule[width=20em]{MREW3}{ 
  \e_1 \neq \this \\ \rtranstz{\b{\mt}}{\b{\mtp}}{\e_1}{\e_2} \\ 
  \b{\rtranstz{\b{\mt}}{\b{\mtp}}{\ep_1}{\ep_2}}
}{
  \rtranstz{\b{\mt}}{\b{\mtp}}{\Call{\e_1}\n{\b{\ep_1}}}{\Call{\e_2}\n{\b{\ep_2}}}
}

\IRule{MREW4}{ 
  \rtranstz{\b{\mt}}{\b{\mtp}}{\e_1}{\e_2} \\ 	
  \rtranstz{\b{\mt}}{\b{\mtp}}{\ep_1}{\ep_2}
}{
  \rtranstz{\b{\mt}}{\b{\mtp}}{\DynCall{\e_1}\m{\ep_1}}{\DynCall{\e_2}\m{\ep_2}}
}

\IRule{MREW5}{
  \b{\rtranstz{\b{\mt}}{\b{\mtp}}{\e}{\ep}} 
}{
  \rtranstz{\b\mt}{\b\mtp}{\New\C{\b\e}}{\New\C{\b\ep}}
}
\end{mathpar}

\vspace{-2mm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hrulefill
\caption{Monotonic dynamic expression translation.}\label{montrans}
\end{figure}

\begin{figure}[!ht]
\hrulefill
\footnotesize
%\IGNOREUNLESSNEEDED{
\[\begin{array}{l@{~}r@{}r@{~}r@{~}r@{~}rr}
\arrayrulecolor{white}
\classgen{\C, \b\md, \bmt, \bmtp, \D, \K}= \\
\SP \class~\D~\{ \\
\SPP \Fdef\that\C
\\[1mm]
\SPP \Mdef\f\x\any\any {\SubCast\any{\MonCast\tp{
      \Set{\Get\this\that}\f{\MonCast\t{\MonCast\tp\x}}}}}
&
\All f \Mtype\f\t\t\in\bmt &\wedge& \Mtype\f\tp\tp\in\bmtp
\\[1mm]\hline
\SPP \Mdefz\f\any{\SubCast\any{\MonCast\tp{\Get{\Get\this\that}\f}}}
&
 \All f \Mtype\f{}\t \in \bmt &\wedge& \Mtype\f{}\tp \in \bmtp
\\[1mm]\hline
\SPP \Mdef\m\x\any\any {~\SubCast\any{\MonCast\tp{{[{(\MonCast\t\x)}/\x]\ep}}}~}
&     \All \m \Mdef\m\x\t\tp\e\in\b\md &\wedge& \Mtype\m\t\tp\in\bmtp \\
&&&&\wedge&\rtranstz{\bmt}\bmtp{[{(\MonCast\t\x)}/\x]\e}{\ep}
\\[1mm]\hline
\SPP \Mdef\m\x\t\tp {\ep~}
&     \All \m \Mdef\m\x\t\tp{\e}\in\b\md &\wedge& \Mtype\m\t\tp\in\bmtp \\
&&&&\wedge&\rtranstz{\bmt}\bmtp{\e}{\ep} \\
&&&&\wedge&\statictype{\C}{\K}{\cdot}
\\[1mm]\hline
\SP\}
\end{array}
\]
%} 
\hrulefill
\caption{Monotonic class generation.}\label{classgen}
\end{figure}

\begin{figure}
\hrulefill
\footnotesize
\vspace{4mm}
\[\begin{array}{l@{~}r@{}r@{~}r@{~}r@{~}rr}
\arrayrulecolor{white}
\typegen{\bmt}{\D} = \\
\SP \class~\D~\{
\\[1mm]
\SPP \Mdef\m\x\t\tp {{\MonCast\tp{\x}}} 
&
\All m \Mtype\m\t\tp\in\bmt
\\[1mm]\hline
\SPP \Mdef\f\x\t\t {\x}
&
\All f \Mtype\f\t\t\in\bmt
\\[1mm]\hline
\SPP \Mdefz\f\t{{\MonCast\t{\New\D{}}}}
&
 \All f \Mtype\f{}\t \in \bmt
\\[1mm]
\SP\}
\end{array}
\]
\hrulefill
\caption{Equivalent Type Generation} \label{typegen}
\end{figure}


\section{Related Work}
% gradualisor
% AGT
% Blame calculus

\section{Conclusion}


\bibliographystyle{unsrturl}
\bibliography{../bib/jv,../bib/all,../bib/ben}

\appendix
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Auxiliary Definitions}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Subtyping}

The structural subtype relation, written \StrSub\M\K\t\tp, asserts that \t
is a subtype of \tp in the environment composed of a set of subtyping \M and
a class table \K.   The set of subtypings can be omitted if empty.

~\\

\opdef{\StrSub\M\K\t\tp}{\t is a subtype of \tp}
\begin{mathpar}
\IRule{SRef}{
}{
 \StrSub\M\K \t \t
}

\IRule{SAss}{
\C \Sub \D \in \M
}{
 \StrSub \M\K \C \D
}

\IRule{SRec}{
 \M' = \M~\C\Sub\D\\
\mt \in \classoff\D\K \implies \exists \mt' \in \classoff\C\K. \StrSub{\M'}\K\mt{\mt'}
}{
 \StrSub \M\K \C \D 
}
\end{mathpar}

Several auxiliary rules are used in the subtype judgement. 

\begin{mathpar}
\IRule{SMet}{
  \StrSub \M\K {\t[1]} {\t[2]} \\
  \StrSub \M\K {\tp[2]} {\tp[1]}
}{
 \StrSub \M\K {\Mtype\m{\t[1]}{\tp[1]}} {\Mtype\m{\t[2]}{\tp[2]}}
}

\IRule{SGet}{
  \StrSub \M\K {\t[1]} {\t[2]}
}{
 \StrSub \M\K {\Mtype\f{}{\t[1]}} {\Mtype\f{}{\t[2]}}
}

\IRule{SSet}{
  \StrSub \M\K {\t[1]} {\t[2]}
}{
 \StrSub \M\K {\Mtype\f{\t[1]}{\t[1]}} {\Mtype\f{\t[2]}{\t[2]}}
}

\IRule{SThat}{
}{
  \StrSub\M\K{\Mtype\that{\b{\t[1]}}{\t[1]}}{\mt}
}
\end{mathpar}

\subsection{Well-formedness}

The overloading function is meant to check that every typed method is
defined once. Every untyped method is defined once. A class has either a
field \f or a pair of getter and setters.

\opdef{\WFp\e\K}{Well-formed program}

\begin{mathpar}
\IRule{WP}{
  \k \in \K \implies \WF{}\cdot\K\k \\
  \EnvType\Env\cdot\K\e\t
}{
  \WFp\e\K
}
\end{mathpar}

\opdef{\WF{}\s\K {\Class\C{\b\fd}{\b\md}}}{Well-formed class}

\begin{mathpar}
\IRule{WC}{
 \xt{overloading}(\b\fd,\b\md)\OK \\
 \fd\in\b\fd\implies \WF \none\s\K \fd \\
 \md\in\b\md\implies \WF \none\s\K \md 
}{
 \WF {}\s\K {\Class \C {\b\fd}{\b\md}}
}
\end{mathpar}

We have some auxiliary judgements.

\begin{mathpar}
\IRule[width=18em]{WT}{
 \EnvType {\Env{\Ftype\x\C}}\s\K\e\D\\
 \WFtype\K\C \\
 \WFtype\K\D \\
}{
 \WF \Env\s\K {\Mdef\m\x\C\D\e}
}

\IRule[width=18em]{WU}{
 \EnvType {\Env \Ftype\x\any}\s\K \e\any\\
}{
 \WF \Env\s\K{\Mdef\m\x\any\any\e}
}

\IRule{WS}{
 \EnvType {\Env{\Ftype\x\tp}}\s\K \e\t \\
 \WFtype \K\t 
}{
 \WF  \Env\s\K {\Mdef\f\x\t\t\e}
}

\IRule{WF}{
 \WFtype \K\t 
}{
 \WF  \Env\s\K {\Fdef\f\t}
}

\IRule{WG}{
 \EnvType \Env\s\K\e\t \\
 \WFtype \K\t
}{
 \WF \Env\s\K {\Mdefz\f\t\e}
}


\IRule{WA}{
}{
 \WFtype \K \any
}

\IRule{WC}{
 \C \in \K
}{
 \WFtype  \K\C
}
\end{mathpar}



\subsection{Typing}

Field accessor rules W3 and W4 require a typed receiver, since \any does
not have any methods a receiver typed at \any will never typecheck.

Shallow casts, W9, do not change the type of the expression. We are casting
to the name of \t not to \t.  In practice that means that all expression
types in Transient will drift towards \any.

~\\

\opdef{\EnvType\Env\s\K\e\t}{\e has type \t in environment \Env against heap \s}
\begin{mathpar}

\IRule{W1}{
   \HasType \Env\x\t
 }{
   \EnvType \Env\s\K\x\t
}

\IRule{W2}{
 }{
   \EnvType \Env\s\K\a\any
}

\IRule{W3}{
  \EnvType \Env\s\K\e\tp \\
 \StrSub \M\K \tp \t
 }{
  \EnvType \Env\s\K\e\t 
}   

\IRule{W4}{
  \EnvType \Env\s\K\e\C \\
  \Mtype \f{}\tp \in \classoff\C\K
}{
  \EnvType \Env\s\K{\Get\e\f}\tp
}    

\IRule{W5}{
  \EnvType \Env\s\K\e\C \\
  \Mtype \f\tp\tp \in \classoff\C\K  \\
  \EnvType \Env\s\K\ep\tp
}{
  \EnvType \Env\s\K{\Set\e\f\ep}\tp
}    

\IRule{W6}{
  \EnvType \Env\s\K\e\C \\
  \Mtype \m\tp\tpp\in \classoff\C\K  \\
  \EnvType \Env\s\K\ep\tp
}{
  \EnvType \Env\s\K{\Call\e\m\ep}\tpp
}    

\IRule{W7}{
  \EnvType \Env\s\K\e\any \\
  \EnvType \Env\s\K\ep\any
}{
  \EnvType \Env\s\K{\DynCall\e\m\ep}\any
}    

\IRule{W8}{
 \EnvType \Env\s\K{\e_1}{\t_1}\dots 
 \EnvType \Env\s\K{\e_n}{\t_n}\ \\ 
 \b\fd=\Fdef{\f_1}{\t_1}\dots\Fdef{\f_n}{\t_n} \\ 
  \Class \C {\b\fd}{\b\md} \in \K
}{
  \EnvType \Env\s\K{\New\C{\e_1\dots\e_n}}\C
}

\IRule{W9}{
  \EnvType \Env\s\K\e\tp
}{
  \EnvType \Env\s\K{\SubCast\t\e}\t
}

\IRule{W10}{
  \EnvType \Env\s\K\e\tp
}{
  \EnvType \Env\s\K{\ShaCast\t\e}\any  %%!!!  not \t !!!
}

\IRule{W11}{
  \EnvType \Env\s\K\e\tp
}{
  \EnvType \Env\s\K{\MonCast\t\e}\t
}

\IRule{W12}{
  \s(\a) = \obj\C{\b\ap}
}{
  \EnvType \Env\s\K\a\C
}
\end{mathpar}


\subsection{Field read}

We write \readf\s\a\f\K to denote a read of field \f from the object
stored at \a in \s.

\begin{equation*}
\readf \s\a\f\K = \ap ~~\mathit{if}~~  \s(\a) = \obj\C{\a_1\dots\a_n \ap \dots} \AND
 \Class\C {\Fdef{\f_1}{\t_1}\dots\Fdef{\f_n}{\t_n}\Ftype\f\t\dots}{\b\md}\in\K
\end{equation*}

\subsection{Write field}

We write \setf\s\a\f\ap\K to denote the write of value \ap into field \f of
the object stored at \a in \s.

\begin{equation*}
\setf \s\a\f\ap\K= \Map\s{\Bind{\a}{\obj\C{\a_1\dots\a_n\,\ap\dots}}}
  ~~\mathit{if}~~ \begin{cases}
   \s(\a) = \obj\C{\a_1\dots\a_n\,\app\dots}\\
   \Class\C{\Fdef{\f_1}{\t_1}\dots\Fdef{\f_n}{\t_n}\,\Fdef\f\t\dots}{\b\md}\in\K
\end{cases}
\end{equation*}

\section{Generative Monotone Casts}

The \texttt{mmeet} function is used by the \texttt{tmeet} functions to
perform the meet over the typing of each method within a class definition.
The \texttt{mmeet} function also takes four arguments, the method
signatures of the original class $\b\mt$, the method signatures of the cast
class $\b\mtp$, the environment $\P$, a class table $\K$, and outputs method
types $\b\mtpp$ and a class table $\Kp$. 

\hrulefill

\opdef{
  $\mmeet{\b\mt}{\b\mtp}\P\K = \b\mtpp\,\Kp$
}{
}
\begin{mathpar}
\IRule{MM1}{
}{
  \mmeet{\b\mt}{\cdot}\P\K =\b{\mt} ~\K
}

\IRule{MM2}{
}{
  \mmeet{\cdot}{\b\mt}\P\K =\b{\mt} ~\K
}

\IRule{MM3}{ 
  \Mtype\f{}{\t} = \mt \\
  \Mtype\f{}{\tp} \in \b{\mtp} \\
  \tmeet{\t}{\tp}\P\K = \tpp~\Kp \\
  \Mtype\f{}{\tpp} = \mtpp
}{ 
   \mmeet{\mt}{\b{\mtp}}\P\K = \mtpp\,\Kp
}

\IRule{MM4}{ 
  \Mtype\f{\t}{\t} = \mt \\
  \Mtype\f{\tp}{\tp} \in \b{\mtp} \\
  \tmeet{\t}{\tp}\P\K = \tpp~\Kp \\
  \Mtype\f{\tpp}{\tpp} = \mtpp
}{ 
   \mmeet{\mt}{\b{\mtp}}\P\K = \mtpp\,\Kp
}


\IRule{MM5}{ 
  \Mtype\m{\t_1}{\t_2} = \mt \\
  \Mtype\m{\t_3}{\t_4} \in \b{\mtp} \\
  \tmeet{\t_3}{\t_1}\P\K = \t_5~\Kp \\
  \tmeet{\t_2}{\t_4}\P\Kp = {\t_6}~{\Kpp} \\
  \Mtype\n{\t_5}{\t_6} = \mtpp
}{ 
   \mmeet{\mt}{\b{\mtp}}\P\K = \mtpp\,\Kpp 
}

\IRule{MM6}{
  \mmeet{\mt}{\b{\mt_2}}\P\K = \mt_3~\Kp\\
  \mmeet{\b{\mt_1}}{\b{\mt_2}}\P\Kp = \b{\mt_4}~\Kpp
}{
  \mmeet{\mt~\b{\mt_1}}{\b{\mt_2}}\P\K =\mt_3\b{\mt_4} ~\Kpp
}
\end{mathpar}
\\

\hrulefill

\begin{mathpar}
\IRule{HT1}{
  \a \not\in \text{addr}(\S) \\
  \enfortype\C\cdot\K = \D\,\W\,\Kp
}{
  \htype\a\S{\sigma[\a \mapsto \C\{\ap\}]}\K = \D~\Kp
}

\IRule{HT2}{
  \S(\a) = \t
}{
  \htype{\a}{\S}{\sigma}\K = \t~\K
}
\end{mathpar}

\hrulefill
\begin{align*}
\W &::= \cdot \B \Map\W{\Bind\C\D}
\end{align*}
\begin{mathpar}
\IRule{ENT1}{ 
  \Class\C{\hspace{-0.3em}}{\Fdef\that\Cp ~ \b\md} \in \K \\ 
  \C \notin \text{dom}(\W) \\
  \D\text{ fresh} \\
  \Wp = \W\,\Bind\C\D \\
  \Kp = \K\,\Class\D{\hspace{-0.3em}}{\Fdef\that\Cp ~ \enformt{\b{\md}}{\Wp}{\K}} \\ 
}{
  \enfortype{\C}{\W}{\K} = \D\,\Wp\,\Kp
}

\IRule{ENT2}{ 
  \W(\C) = \D \\
}{
  \enfortype{\C}{\W}{\K} = \D\,\W\,\K
}

\IRule{ENT3}{ 
}{
  \enfortype{\any}{\W}{\K} = \any\,\W\,\K
}
\end{mathpar}
\\

\hrulefill

\begin{mathpar}
\IRule{ENMT1}{
  \md =  \Mdef\m\x\any\any {~\SubCast\any{\MonCast\tp{{[{(\MonCast\t\x)}/\x]\ep}}}~} \\
  \enfortype\t\W\K = \tpp\,\Wp\,\Kp \\
  \enfortype\tp\Wp\Kp = \tppp\,\Wpp\Kpp \\
  \mdpp = \Mdef\m\x\tpp\tppp {\MonCast\tppp\x} \\
  \enformt{\b\md}{\Wpp}{\Kpp} = \b\mddp \\
}{
  \enformt{\md\,\b\md}{\W}{\K} = \mdpp\,\b\mddp
}

\IRule{ENMT2}{
  \md = \Mdef\m\x\t\tp {\ep~}\\ 
  \enfortype\t\W\K = \tpp\,\Wp\,\Kp \\
  \enfortype\tp\Wp\Kp = \tppp\,\Wpp\Kpp \\  
  \mdpp =\Mdef\m\x\tpp\tppp {\MonCast\tppp\x}\\
  \enformt{\b\md}{\Wpp}{\Kpp} = \b\mddp \\
}{
  \enformt{\md\,\b\md}{\W}{\K} = \mdpp\,\b\mddp
}

\IRule{ENFS}{
  \md = \Mdef\f\x\any\any {\SubCast\any{\MonCast\tp{\Set{\Get\this\that}\f{\MonCast\t{\MonCast\tp\x}}}}} \\ 
  \enfortype\t\W\K = \tpp\,\Wp\,\Kp \\
  \enfortype\tp\Wp\Kp = \tppp\,\Wpp\Kpp \\   
  \mdpp = \Mdef\f\x\tpp\tppp {\MonCast\tppp\x} \\
  \enformt{\b\md}{\Wpp}{\Kpp} = \b\mddp \\
}{
  \enformt{\md\,\b\md}{\W}{\K} = \mdpp\,\b\mddp
}

\IRule{ENFG}{
  \md =  \Mdefz\f\any{\SubCast\any{\MonCast\t{\Get{\Get\this\that}\f}}} \\ 
  \enfortype\t\W\K = \tp\,\Wp\,\Kp \\
  \mdpp = \Mdefz\f\tp {\MonCast\tp{\Get{\Get\this\that}\f}} \\
  \enformt{\b\md}{\Wp}{\Kp} = \b\mddp \\
}{
  \enformt{\md\,\b\md}{\W}{\K} = \mdpp\,\b\mddp
}

\IRule{ENE}{
}{
  \enformt{\cdot}{\W}{\K} = \cdot
}
\end{mathpar}

\hrulefill

\opdef{
  $\statictype\D\K{\b\C} = \texttt{Bool}$
}{
}

\begin{mathpar}
\IRule{ST1}{ 
}{ 
  \statictype\any\K{\b\C} = \texttt{False} 
}

\IRule{ST2}{ 
 \D \in {\b\C}
}{ 
  \statictype\D\K{\b\C} = \texttt{True} 
}

\IRule{ST3}{
  \D ~\text{empty}
}{ 
  \statictype\D\K{\b\C} = \texttt{True} 
}

\IRule{ST4}{
 \Class \C {\b{\Ftype\f\t}}{\b\md} \in \K \\
 \sign{\b\md} = \b{\Mtype\m\tp\tpp} \\ 
 \b\Cp = \b\C, \b\t, \b\tp, \b\tpp 
}{ 
  \statictype\D\K{\b\C} = \statictype{\b\t}\K{\b\Cp} \cap \statictype{\b\tp}\K{\b\Cp} \cap \statictype{\b\tpp}\K{\b\Cp}
}
\end{mathpar}
\\


We write \wftype{\b\f}\C\K to denote the type lookup for a particular set of fields in \C.

\begin{equation*}
\wftype{\b\f}\C\K = \b\t ~~\mathit{if}~~ \begin{cases}

 \Class \C {\b{\Ftype\fp\tp}}{\b\md} \in \K\\
 \b\t = \{ \b\t \subseteq \b\tp ~|~ \forall~ \f \in \b\f ~.~ \f \in \names{\b{\Ftype\fp\tp}} \} \\
 
\end{cases}
\end{equation*}


We write \classoff\C\K to denote the signutare lookup for every method, including field getters and setters, in \C.

\begin{equation*}
\classoff\C\K = \b\mt ~~\mathit{if}~~ \begin{cases}

 \Class \C {\b{\Ftype\f\t}}{\b\md} \in \K\\
 \b\mt = \sign{\b\md} \oplus \forall ~\Ftype\fp\tp \in \b{\Ftype\f\t} ~|~ \fp \notin \names{\b\md} ~.~ \typez{\Ftype\fp\tp}

\end{cases}
\end{equation*}

$\getmds(\C,\K)$ refers to the method definitions that are explicitly written inside of the class \C, according to the class table \K.

\begin{equation*}
\getmds\C\K = \b\md ~~\mathit{if}~~ \Class\C{\b{\fd}}{\b\md} \in \K
\end{equation*}

\hrulefill

\begin{mathpar}
\IRule{FT1}{
 \App\s\a=\obj\D{\ap} \\ % we know that a refers to a wrapper with a that field of the wrapped object
  \App\s\ap =\obj\E{\b\app}  \\ % getting the fields out of ap
 \Class \E {\b{\Fdef\f\t}}{\b\md} \in\K \\
 \wftype{\b\f}\C\K =\b\tp
}{
  \ftypes \a\C\s\K = \b\app~\b\tp
}
\end{mathpar}

\hrulefill

% &\B~   &\B \Mtype\f{}\t

\begin{mathpar}
\IRule{DYN1}{
 \dyn{\b\mt} = \b{\mtp} \\
}{
  \dyn{\Mtype{\m}{\t}{\t} ~\,\b\mt} = \Mtype{\m}{\any}{\any}~\,\b\mtp
}

\IRule{DYN2}{
 \dyn{\b\mt} = \b{\mtp} \\
}{
  \dyn{\Mtype{\f}{\t}{\t} ~\,\b\mt} = \Mtype{\f}{\any}{\any}~\,\b\mtp
}

\IRule{DYN3}{
 \dyn{\b\mt} = \b{\mtp} \\
}{
  \dyn{\Mtype{\f}{}{\t} ~\,\b\mt} = \Mtype{\f}{}{\any}~\,\b\mtp
}

\IRule{DYNE}{
}{
  \dyn{\cdot} = \cdot
}
\end{mathpar}



\section{Monotonic figure scratch}

%% Example -- please check

%%class A {
%%  m(x:*):* { x }  
%%}
%% a = new A()
%% a.m(new A()) -- works fine
%%class B {
%%  m(x:B):B { x }  
%%}
%% b = <|B|> a
%% b.m(new B()) -- works
%% a.m(new A()) -- fails

% translated version

%%class wA {
%%  that : A
%%  m(x:*):* { this.that().m(x) }
%%}
%%a = new wA(new A())
%%(<*>a)@(<*>new wA(new A()))
%%class AmB {
%%  m(x:B):B{ ... }
%%}
%%class AwAmB {
%%  that : A
%%  m(x:*):* { <|*|><|B|>(<|*|>this.that())@m(<|*|><|B|>x) }
%%  m(x:B):B { <|B|>(<|*|>this.that())@m(<|*|>x)}  
%%}
%% b = <|B|> a -- b and a instance of AwAmB
%% b.m(new B()) -- works
%% a.m(new A()) -- fails

% example 2

%% class T { }
%% class A { f : * }
%% class B { f : A }
%% class C { f : B }
%% a1 = new A(new T())
%% a2 = new A(a1)
%% a3 = new A(a2)
%% b = <|B|> a3
%% c = <|C|> a3

% translated

%% class WA { that : A f():* { <|*|><|*|> this.that().f() } f(x:*):* { <|*|><|*|> this.that().f(<|*|><|*|>s x)} }
%% class WAmB { that:A f():* { <|*|><|A|>this.that().f() } f(x:*):* {<|*|><|A|> this.that().f(<|*|><|A|> x) } }
%% class WAmBmC { that:A f():* {<|*|> <|B|> this.that().f() } f(x:*):* { <|*|> <|B|> this.that().f(<|*|><|B|> x)} }
%% a1 = new WA(new A(new WT(new T())))
%% a2 = new WA(new A(a1))
%% a3 = new WA(new A(a2))
%% b = <|B|> a3 -- s(b) : WAmB
%% a3.f(new T()) -- boom
%% a2.f(new T()) -- ok
%% c = <|C|> b -- s(b) : WAmBmC, s(a2) : WAmB
%% a3.f(new T()) -- boom
%% a3.f(new WA(new A(new T))) -- boom
%% a2.f(new T()) -- boom

%% class A {
%%   fa : B
%%   ma(x : A): B { fa.mb(a) }
%% }
%% class B {
%%   fb : any
%%   mb(x:A):B { this }
%% }
%% class C {}

%% class Ap {
%%   fa : Bp
%%   ma(x : Ap): Bp {...}
%% }
%% class Bp {
%%   fb: C 
%%   ma(x : Ap): Bp {...}
%% }

%% a = new A(new B(new C()))
%% ap = <| Ap |> a

%% class WA {
%%   that : A
%%   fa() : B { that.fa() }
%%   fa(x:B):B { that.fa(x) }
%%   ma(x:B):B { that.ma(x) }
%% }
%% class WB {
%%   that : any
%%   fb() : any { that.fb() }
%%   fb(x:any):any { that.fb(x) }
%%   mb(x:B):B { that.mb(x) }
%% }
%% class WBp {
%%   that : A
%%   ...


\section{Proofs of Related Theorems}
\subsection{Accessory Lemmas}

\paragraph{Evaluation Extends Class Tables}

If $\Reduce \K\e\s \Kp\ep\sp$ then $\Kp = \K~\Kpp$ for some $\Kpp$.

\paragraph{Weakening of Subtyping}

If $\StrSub\cdot\K\t\tp$ then $\StrSub\cdot{\K~\Kp}\t\tp$.

\paragraph{Correctness of \classoff{\C}{\K}}

If $\Mtype\n{\b\t}\tp \in \classoff{\C}{\K}$, $\EnvType\cdot\s\K\e\C$ and (if applicable) $\EnvType\cdot\s\K\ep\t$, then $\Reduce \K{\Call\e\n{\b\ep}}\s \K\epp\s$ where $\EnvType\cdot\s\K\epp\tp$

\subsection{Soundness of \kafka Typing}

Given that $\WFp\K\e\s$ and $\EnvType\cdot\s\K\e\t$, then either there is some $\ep$ such that $\Reduce \K\e\s \Kp\ep\sp$ and $\WFp\Kp\ep\sp$ and $\EnvType\cdot\sp\Kp\ep\t$ hold, or $\e$ is of one of the following forms:
\begin{itemize} 
\item $\a$
\item $\DynCall\ep\m{\epp}$
\item $\SubCast\tp\ep$
\item $\ShaCast\tp\ep$
\item $\BehCast\tp\ep$
\item $\MonCast\tp\ep $
\end{itemize}
We proceed with rule induction on the judgement used to conclude $\EnvType\Env\s\K\e\t$. Note that we refer to rule preconditions from left to right.
\begin{itemize}
  \item W1

        Not applicable, since $\Gamma = \cdot$ and therefore contains no variables.
  \item W2

        We apply the IH to the first precondition. If we get stuck in the IH, then the entire expression gets stuck or terminates, trivially. Therefore, the interesting case is when $\Reduce \K\e\s \Kp\ep\sp$, $\WFp\Kp\ep\sp$ and $\EnvType\cdot\sp\Kp\ep\tp$. By 
  \item W3, W4, W5
  \item W6
  \item W7
  \item W8
  \item W9
  \item W10
  \item W11
  \item W12
\end{itemize}

\subsection{Type Correctness of Translation}


\end{document}

%######## ##    ## ########      #######  ########    ########   #######   ######  ##     ## ##     ## ######## ##    ## ######## 
%##       ###   ## ##     ##    ##     ## ##          ##     ## ##     ## ##    ## ##     ## ###   ### ##       ###   ##    ##    
%##       ####  ## ##     ##    ##     ## ##          ##     ## ##     ## ##       ##     ## #### #### ##       ####  ##    ##    
%######   ## ## ## ##     ##    ##     ## ######      ##     ## ##     ## ##       ##     ## ## ### ## ######   ## ## ##    ##    
%##       ##  #### ##     ##    ##     ## ##          ##     ## ##     ## ##       ##     ## ##     ## ##       ##  ####    ##    
%##       ##   ### ##     ##    ##     ## ##          ##     ## ##     ## ##    ## ##     ## ##     ## ##       ##   ###    ##    
%######## ##    ## ########      #######  ##          ########   #######   ######   #######  ##     ## ######## ##    ##    ##    




\subsection{others}

%TODO Fix ME \mtype\m\C\K = \convert{\methz\m\C\K} 

\hrulefill

\opdef{\classoff\C\K}{Auxiliary function: Type definition}

\begin{equation*}
\classoff\C\K = \EMxt{MT} ~~s.t.~~ \begin{cases}

 \K(\C) = \Class \C {\b{\Ftype\f\t}}{\b\md} \\
 \EMxt{MT} = \{\convert{\b\md} \oplus \forall ~\Ftype\fp\tp \in \b{\Ftype\f\t} ~|~ \fp \notin \b{\names{\md}} ~.~ \convertFD{\Ftype\fp\tp}\}

\end{cases}
\end{equation*}

\hrulefill


\opdef{\classoffs\a\s\K}{Auxiliary function: Type definition}

\begin{equation*}
\classoffs\a\s\K = \EMxt{MT} ~~s.t.~~ \begin{cases}

 \s(\a) = \obj\C{\b\a} \\
 \K(\C) = \Class \C {\b{\Ftype\f\t}}{\b\md} \\
 \EMxt{MT} = \{\convert{\b\md} \oplus \forall ~\Ftype\fp\tp \in \b{\Ftype\f\t} ~|~ \fp \notin \b{\names{\md}} ~.~ \convertFD{\Ftype\fp\tp}\}

\end{cases}
\end{equation*}

\hrulefill

\opdef{\ftype\f\C\K}{Auxiliary function: Field type lookup}

\begin{equation*}
\ftype\f\C\K = \t ~~s.t.~~ \begin{cases}

 \K(\C) = \Class \C {\ldots ~ \Ftype\f\t ~ \ldots}{\b\md}
\end{cases}
\end{equation*}

\hrulefill

\opdef{\field\C\K}{Auxiliary function: Field definition}

\begin{equation*}
\field\C\K = \b{\Ftype\f\t} ~~s.t.~~ \begin{cases}

 \K(\C) = \Class \C {\b{\Ftype\f\t}}{\b\md}
\end{cases}
\end{equation*}




This common core is focused on the basics of object functionality, with a
simple example being a \xt{Point} class.\footnote{For our examples we use
  integers and common arithmetic operations even if they are not in core
  calculus.}

%%% FIXME: formatting
\begin{verbatim}
class Point {
  x : Int
  y : Int
  addx( v : Int ) : Int {
       this.x!( this.x() + v )
  }
  addy( v : Int ) : Int {
       this.y!( this.y() + v )
  }
}
\end{verbatim}

The type system ensures that, if \xt{pt} is declared to be of type
\xt{Point}, an operation such as \xt{pt.addx(42)} will not get stuck.  As
this small language requires all variables to be initialized, there checking
for \xt{null} is not needed as it likely would in a full fledged language.

The language also supports a single unconstrained type, denote \any (pronounced
dyn), thus one could write the following method

%%% FIXME: formatting
\begin{verbatim}
  mkPt( u : * ) : Point {
      new Point( u.x() 
                 (<Point> u).y() )
  }
\end{verbatim}

This method will accept an instance of any class and will return a new
\xt{Point}. At run-time, the code will get stuck if the dynamic cast
\xt{\Cast{\xt{Point}}{\xt{u}}} fails. If \x is a declared of type \any, an
expression such as \xt{u.x()} will fail if the object bound to \xt{u} does
not have a getter \xt{x()}.


%%%%%%%%%%%%%%%%%%%%%% DYNAMIC SEMANTICS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The dynamic semantics evaluates expression extended with object references,
denoted \a, and errors, denoted \err, together with a heap \s mapping
references to object values. Object values contain all fields, methods, a
type, and a class; they are denoted \obj\C{\b\a}. The class is used for
locating methods and the type is used for type casts. The need for keeping
them separate will become clear later.

The semantics uses evaluation context \E[\e], meaning that $\e$ is in the
hole of $\E$. Selecting an object from the heap is written \Sel\s\a, while a
heap is extended with a new object by \Map{\s}{\Bind{\a}{\obj\C{\dots}}}.

For an object reference \a, such that \EM{\Sel\s\a=\obj\C\dots}, we have 
\classofis{\Sel\s\a}\C and \typeofis\s\a\t.

We use the notation \Mdef\m\x\t\t \in\C to select a method in a class
definition and \Fdef\f\t\a\in\obj\C\dots to express the selection of a
field. Lastly a field of an object can be update with the notation
\Update{\obj\C\dots}\f\a.

\subsection{Core Type System}

As a basis for our gradual type system, we will use a simple static
type system, ensuring that the program will not get stuck, but while
simultaneously is entirely up-front and not gradual, shown in
figure~\ref{fig:basetyp}.

This basic type system is typical of calculi that support objects, notably
including subtyping. Subtyping in our system is defined in
figure~\ref{fig:sub}, which defines a simple structual subtyping system with
names (to provide for recursive types) as well as the Amber rule to support
recursive types. Notably, however, because there are no valid operations on
$\any$ other than casting, this type system cannot be called a
\emph{gradual} type system, as a gradual type system should allow $\any$
typed-terms to coexist with fully typed ones.

Soundness for this base system is typical. We combine the progress and
preservation lemmas to come up with an aggregate small step soundness
theorem, which we then extend with the typical cast failure carve-out to
enable casts to fail without the program getting stuck.

\begin{thm}
If $\EnvType\Es\e\t$, then one of the following holds:
\begin{itemize}
\item $\e \rightarrow \e'$ and $\EnvType\Es{\e'}\t$
\item $\e \rightarrow \xt{v}$ and $\EnvType\Es{\xt{v}}\t$
\item $\e$ is $\Cast{\t}{\e'}$ and $\e \rightarrow \err$
\end{itemize}
\end{thm}

The proof of this theorem is simple and is included in the appendix.

\begin{figure}
\input{figures/basetype}
\caption{Typing rules for the base langauge}
\label{fig:basetyp}
\end{figure}


\section{Gradual Typing}
In order to extend the core calculus to enable programmers to write
gradually typed code without having to insert a great number of casts
manually, we use gradual type systems to add casts where required,
presenting a unified gradual semantics to the programmer while relying on
the core system for soundness.

Our characterization of gradual typing is \emph{gradual typing by translation},
using an approach similar to that of~\cite{Bierman10}, adding gradual
types to the underlying fully typed language. In this vein,
we define our gradual typing extensions as \emph{cast insertion} phases.

\subsection{Cast Insertion}

The user-facing component of a gradual typing system is its type checker,
or the surface type system, which is then complemented by a type-driven
cast insertion mechanism ``behind the scenes''. In our approach, these two
steps are combined into a cast insertion system.

Cast insertion is fundamentally \emph{type driven}. In our type system, it is
required to have a cast whenever a type needs to be altered, and therefore in
inserting casts we need to know every site where one type is required to be another.
Our system handles this through an \emph{bidirectional cast insertion} system,
introduced by~\cite{lti-pierce}

Our choice comes from an observation about the nature of traditional
bottom-up type systems. The fundamental building block is judgements of the
form $\E \vdash \e : \t$, which means that $\e$ inherently has type
$\t$. For example, a type mismatch would look like trying to conclude a
judgement $\E \vdash \e : \any$ when only $\E \vdash \e : \xt{int}$ holds.

Other systems have solved this problem through the introduction of
nondeterministic rules such as subsumption, but nondeterminism in cast
insertion creates problems where a single program can be typed in multiple
different ways (EXAMPLE).

To solve this problem, we use the aforementioned bidirectional cast
insertion mechanism. Ina bidirectional system, we have two judgements:

\begin{itemize}
\item The \emph{analytic} judgement $\E \vdash \e \Rightarrow \t$, which says that
$\e$ inherently has type $\t$ against environment $\E$, equivalently to the
traditional bottom-up type system.
\item The \emph{synthetic} judgement $\E \vdash \e \Leftarrow \t$, which implies that
$\e$ can potentially have type $\t$ against environment $\E$.
\end{itemize}

For example, consider the function call $\Call{\ep1}{\m}{\ep2}$. A
bidirectional type system will begin with seeing what type $\ep1$ has, with
the judgment $\E \vdash \ep1 \Rightarrow \t$.  From this, the bidirectional
type system will check what type the method $\m$ has in $\t$, here denoted
$\Mtype\m{\tp1}{\tp2} \in \t$, then ensure that the arguments make sense
with that type.

In a bottom-up type system, we would write $\E \vdash \ep2 : \tp1$, but, as
commonly noted with subsumption, this can require the introduction of a
nonalgorithmic rule to conclude this final judgment. Instead, in a
bidirectional type system, we can simply ensure that the type of $\ep2$ is
consistent with $\tp1$ through the judgment $\E \vdash \ep2 \Leftarrow
\tp2$.

Finally, we will be able to conclude that $\E \vdash \Call{\ep1}{\m}{\ep2}
\Rightarrow \tp2$. This is a synthetic judgement as $\tp2$ is the type that
the expression can be known to have in the absence of any external
information.

To support cast insertion, we extend these basic type checking judgements
with an output term, of the form $\GenCast{\E}{\ep1}{\ep2}{\t}$ for the
synthetic case and $\AnaCast{\E}{\ep1}{\ep2}{\t}$ for the analytic, case,
where the former translates $\ep1$ to $\ep2$ producting type $\t$, and the
latter translates the same ensuring type $\t$.

An important note in the construction of our bidirectional type system is
that our handling of the key case, function application, is less specific
than it could be, as we ignore the analytic case. Other works in this area,
including~\cite{bidir-typing} use a third bidirectional judgment to handle
function application, largely to handle the analytic case. If we are trying
to typecheck a function call against some known type, then we can infer a
type for the receiver by using synthetic type checking on the arguments.
However, in our context, detailed handling of this case is not required, as
our type inference does not need to be as precise as it does for Dunfield
and Krishnaswami's type inference.

\subsection{Class Translation}

A key component of many gradual type systems is enabling checks for every
field access or modification, ensuring type invariants about the heap. To
enable these checks, we cannot expose ``raw'' field access and modification
in our calculus, as otherwise these checks could be easily bypassed.

As a result, we expose no typing judgment for field manipulation, and
instead auto-generate getter and setter methods in a phase we call
\emph{class translation}, occuring at the same time as cast insertion.

Another issue solved by class translation is that raised by calling a method
on a dynamic receiver type.  Consider the invocation $\Call{\e}{\m}{\e'}$
where $\EnvType{\Es}{\e}{\any}$ and $\EnvType{\Es}{\e'}{\any}$.  Now,
suppose that we have a method on $\e$ $\m(\x:\C)$. Using casting, we can
figure out that the method exists, and that the arity is correct, but there
is no static way to know the argument types of $\m$ statically to insert
checks.

Class translation solves this problem by creating a ``guard'' method
$\m_\xt{u}$ that will have the same arity and a related name, but only has
arguments of type $\any$. We then translate every call to a method $\m$ on
an untyped receiver to a call to a call to $\m_\xt{u}$, which then does the
approperiate type check before calling the typed method. Likewise, method reads and writes are protected by getters and setters added
during the class translation phase.

%%%%%%%%%%%%%%%%%%%%%%%% SUBTYPING %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}
%\input{figures/subtyping}
\caption{Subtyping}
\label{fig:sub}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%% WELLFORMDNESS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{figure}
%\input{figures/syncast}
\caption{Synthetic cast insertion}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%% CLASS TRANSLATION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}
%\input{figures/anacast}
\caption{Analytic Cast Insertion}
\end{figure}

\begin{figure}
%\input{figures/classtrans}
\caption{Class Translation}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

At this point, we have defined a not-very-useful semantics for gradual typing, 
with all of the key components but providing no additional functionality
beyond what our original statically typed core. This semantics has us
applying class translation, $\TransClass\C\C$, expression translation,
$\GenCast\E\e\e\t$ and $\AnaCast\E\e\e\t$, a dynamic semantics $\e 
\rightarrow \e$, and finally a subtyping relationship $\t <: \t$, defining the
architecture that we will follow for the remainder of the languages.


By following this structure, we can describe a semantics for our language
with the 5-tuple $(\rightharpoonup, \hookrightarrow, \rightsquigarrow, <:, \rightarrow)$.
The core would be defined as (TODO)


\subsection{Type soundness:}
Theorem 1: Type translation. If $\EnvType{\Es}\e\t$ and $\TransExp\E\e{\e'}\t$ then $\EnvType{\E ~ \cdot}{\e'}\t$.

Theorem 2: Progress. If $\EnvType{\Es}{\e}{\t}$ then $\s,\e \rightarrow \s',\e'$ for $\e'$ expression or $\e' ~ \err$.

Theorem 3: Preservation. If $\s,\e \rightarrow \s',\e'$ and $\EnvType{\Es}{\e}{\t}$ then $\EnvType{\E~\s'}{\e'}{\t}$.

For a list of classes $\bar{\c}$ such that $\b{\c ~~ WF}$ and an expression $e$ such that $\EnvnvType\cdot\e\t$ and $\b{\TransClass\c{\c'}}$, we have $\cdot~e \rightarrow^* \sigma~r$ (against $\b{\c'}$) where $r$ is either a value or $\err$.


\begin{figure}
\input{figures/trtrans}
\caption{Translation for Typed Racket}
\end{figure}

Typed Racket uses a much stricter definition of where $\any$ types can go, where every class is either fully typed or fully untyped. To describe this, we alter definition 1 and 2 to


\begin{definition} A Typed Racket class table is well-formed if for every class \C  in
the class table, every method is of the form \Mdef\d\x{\tp1}{\tp2}\e where
\EnvType{\this:\C,\b{\x:\tp1}}\e{\tp2} holds in \C, and all types in \C are either $\any$ or all not $\any$
\end{definition}

Typed Racket uses wrappers to ensure that typed code type guarantees are not violated, and that untyped code follows the types that it is casted to. We generate these wrappers using the following mechanism.

\begin{definition}
Every place a type \Type{\mt} where $\mt=\Mtype\m{\b{\tp1}}{\tp2}$ flows from typed into untyped code, generate a wrapper $\Class{\C'}{~\xt{orig}:\t,\b{\md}}$ where $\md = \Mdef\m\x{\any}{\any}{\Cast{\any}{\xt{this}.\xt{orig}.\m(\b{\Cast{\tp1}x})}}$.
\end{definition}

To model Typed Racket, we then need to enforce the property that objects are wrapped at typed/untyped boundaries, and ensuring that untyped code cannot use typed code internally through casts. We do this by altering the completion process, giving us a new definition. We use the wrappers we generated using definition 4 to enforce the type guarantees


\begin{definition} A Typed Racket class table is completed if for every 
 \Class \C {\b{\fd}} {\b{\md}} in the class table: 
 \begin{itemize}
 \item for every type \Type{\b{\md}}, add a class \xt{D} such that 
 \begin{itemize}
 \item for every method $\Mtype\m{\tp1}{\tp2} \in \b{\md}$, generate a function in \xt{D} $\Mdef\m{x}{\any}{\any}{\Cast{\any}{\New{\xt{D}}{\xt{this}.\xt{orig}.\m(\New\C{\b{\Cast{\tp1}x}})}}}$
 \end{itemize}
 \item for every field \Ftype\f\t\in\C, we add to \C:
 \begin{itemize}
 \item A setter \SMdef\f\x\t\t{\Set\this\f\x} 
 \item A getter \GMdef\f\t{\Get\this\f}; 
 \end{itemize}
 \item For every method definition \Mdef\d\x\t{\tp1}\e\in\C:
 \begin{itemize}
 \item A dynamic method \Mdef{\Dyn\d}\x\any\any{\Cast\any{\Call\this\d{\b{\Cast\t\x }} }} is added to \C 
 \item We replace the body \e of \m is replaced by \ep1 where \TransClass\e{\ep1}.
 \end{itemize}
 \end{itemize}
\end{definition}

One of the issues inherent to the Strongscript approach (and is apparent in
the common core as well) is that a strict interpretation of the static type
system causes the programmer to have to write a very large number of
``obvious'' casts, breaking untyped code and seemingly-sensible typed
code. We can solve this by having the compilation process insert the types
for the programmer, which we describe using a cast insertion system.

Our cast insertion approach is based on a bidirectional type
system~\cite{}, where each expression either \emph{synthesizes}, or
inherently makes, a type, or is \emph{analyzed} against a type where the
type system checks to make sure that the expression still ``works'' under
the given type. This approach has been used for a number of other tasks,
including inferring types to select sub-languages~\cite{}, infer
types for higher rank languages~\cite{}. In our case, they allow us
to simply specify in an extensible manner where to insert casts.

Synthetic cast insertion is closer to a traditional type system, as it
produces types from terms in a similar manner. However, instead of having
non algorithmic cases where types are known (for example, in the arguments
to a typed function), the synthetic cast insertion judgment defers to the
analytic cast insertion mechanism with the known type. Importantly for us,
the basic semantics of the static type system does not change between any of
the type systems under consideration, and as a result the synthetic cases
are not changed by any of the systems.

Analytic cast insertion ensures that an expression is of a given type. We use analytic cast insertion when a type is known for an expression and we want to force that expression to be of the correct type, which we do by inserting the appropriate cast. The actual details of analytic cast insertion vary depending on the system under consideration (most notably, the monotonic semantics has a notion of consistency that differs from the other two systems).

\begin{figure}
$\t = \ldots \B {\WType{\Mtype\m\t\t}}$
\caption{Strongscript}
\end{figure}

\begin{figure}
%\input{figures/transtrans}
\caption{Transient}
\end{figure}


\section{Monotonic}

%%%%%%%%%%%%%%%% Monotonic Statics

\begin{figure}[h]
%\input{figures/conssub}
\caption{Consistent Subtyping}
\end{figure}

The key static difference between the monotonic semantics and the other systems we have considered is the consistent subtyping relationship. Traditional subtyping can be thought of as if a value satisfies one type, then it will satisfy any supertype of that type. Consistent subtyping encapsulates both this notion and the new idea of consistency. Consistency for objects means that two types have static type information that does not conflict - e.g. $\Type{\Ftype\f\any}$ could very well be able to replace $\Type{\Ftype\f\C}$, though we are unable to tell statically. Consistency allows us to interchange these types, inserting a cast where required.

Subtype consistency combines the two properties. Subtyping lets us add and remove fields from a type, and consistency allows us to make the type we are going to more or less dynamic. Going by the above intuition, a value of type $\any$ could work with any other type and vice versa, and clearly two identical types are compatible. The most complex case is when we have two class types, both with the same method $\m$, which we resolve by ensuring that $\m$ has parameters and return types that are consistent and continuing on through the rest of the class.

Adding this to our static type system is simple. We just introduce the rule that allows types to be converted via $\stcons{}{}$. The details of how to make the dynamics work with this static addition will be covered later.

\begin{figure}[h]
%\input{figures/monomeet}
\caption{Meet for the monotonic system}
\end{figure}

This idea leads us into the core of the monotonic idea. Under this system, if we have a field of some given type $\t$, we do not know if the value of that field is truly of the expected type (since the class could have been cast to one where that field is $\any$ and the field updated), and therefore have to check the value of $\f$ at every point it is used. The solution used by the monotonic approach is to ensure that if a type is given to a field, then that type is never violated.

Consistency allows us to convert between, for example, $\Type{\Ftype\f\any, \Ftype{\xt{g}}\C}$ and $\Type{\Ftype\f\C, \Ftype{\xt{g}}\any}$, as neither has static typing information that would rule out a value that satisfied the other type. However, if we have a value that satisfied both, we would end up with a type that had neither type exactly - we would have $\Type{\Ftype\f\C, \Ftype{\xt{g}}\C}$. This is the key to the monotonic system - we never throw away any type information away. If, at any point in the program, we have an object with some specialized (e.g. not all $\any$) type, then those type assumptions will never be violated. As a result, we can ensure that no get operation will need to be checked.


\begin{figure}

For every class $\C$ and every $\t$ where $\stcons\C\t$, we can generate a most specific type as $\t' \equiv \meet\C{\t^i}$. We then produce a wrapper class $\refine\C\t$ such that

%\input{figures/monotrans}
\caption{Monotonic translation}
\end{figure}

\begin{figure}
%\input{figures/casts}
\end{figure}


\begin{figure}
%\input{figures/castins}
\end{figure}

%% Example -- please check

%% class A {
%%   fa : B
%%   ma(x : A): B { fa.mb(a) }
%% }
%% class B {
%%   fb : any
%%   mb(x:A):B { this }
%% }
%% class C {}

%% class Ap {
%%   fa : Bp
%%   ma(x : Ap): Bp {...}
%% }
%% class Bp {
%%   fb: C 
%%   ma(x : Ap): Bp {...}
%% }

%% a = new A(new B(new C()))
%% ap = <| Ap |> a

%% class WA {
%%   that : A
%%   fa() : B { that.fa() }
%%   fa(x:B):B { that.fa(x) }
%%   ma(x:B):B { that.ma(x) }
%% }
%% class WB {
%%   that : any
%%   fb() : any { that.fb() }
%%   fb(x:any):any { that.fb(x) }
%%   mb(x:B):B { that.mb(x) }
%% }
%% class WBp {
%%   that : A
%%   ...
