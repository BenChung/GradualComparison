\documentclass[a4paper,USenglish]{tex/lipics-v2016}
\usepackage{xspace,listings,url,framed,amssymb,colortbl,
            amsmath,tex/mathpartir,hyperref,doi,
            stmaryrd, graphicx, tikz, colortbl, xparse} % double brackets llbracket
\usepackage[customcolors,norndcorners]{hf-tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{shapes.multipart}
\usetikzlibrary{positioning}
\usetikzlibrary{calc}
\usetikzlibrary{backgrounds}
\input{macros}

\definecolor{Gray}{gray}{0.9}

\usepackage{epigraph}
\setlength{\epigraphwidth}{0.75\linewidth}
\setlength{\epigraphrule}{0pt}
\renewcommand*{\textflush}{flushright}
\renewcommand*{\epigraphsize}{\normalsize\itshape}

\definecolor{vlightgray}{gray}{0.93}

\lstdefinelanguage{JavaScript}{
  keywords={typeof,new,true,false,instanceof,catch,function,return,null, 
    catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{darkgray},
  ndkeywords={class,def,interface,export,boolean,throw,extends,implements,import,this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,  comment=[l]{//},  morecomment=[s]{/*}{*/},
  commentstyle=\color{gray}\ttfamily,  stringstyle=\color{gray}\ttfamily,
  morestring=[b]',  morestring=[b]",
  backgroundcolor=\color{vlightgray},
  aboveskip=\medskipamount, %0em,
  belowskip=\smallskipamount %0em
}
\lstset{
  language=JavaScript,  extendedchars=true,  basicstyle=\footnotesize\ttfamily,
  showstringspaces=false,   showspaces=false,  numberstyle=\small,
  numbersep=9pt,  tabsize=2, breaklines=true,  showtabs=false, captionpos=b
}


\usepackage[textsize=tiny]{todonotes}

% Author macros::begin %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Gradual Types for Objects Redux}
\titlerunning{Gradual Types for Objects Redux}
%% provide for each author the \author and \affil macro, even if same
\author[1]{Ano Nymous, et al.}
%% Benjamin Chung, Paley Li, Jan Vitek
%\affil[1]{}
\authorrunning{Anon} %mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et. al.'
\Copyright{Anon}%mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/
%\subjclass{Dummy classification -- please refer to \url{http://www.acm.org/about/class/ccs98-html}}% mandatory: Please choose ACM 1998 classifications from http://www.acm.org/about/class/ccs98-html . E.g., cite as "F.1.1 Models of Computation". 
%\keywords{Dummy keyword -- please provide 1--5 keywords}% mandatory: Please provide 1-5 keywords
% Author macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Editor-only macros:: begin (do not touch as author)%%%%%%%%
\EventEditors{Anon}
\EventNoEds{2}
\EventLongTitle{}
\EventShortTitle{ECOOP 2017}
\EventAcronym{ECOOP}
\EventYear{2017}
\EventDate{}
\EventLocation{}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
% Editor-only macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}
\maketitle

\begin{abstract}
The enduring popularity of dynamically typed languages has given rise to a
cottage industry of static type systems, referred to as \emph{gradual type
  systems}, that let developers annotate legacy code piecemeal. Soundness
for programs which mix typed and untyped code means that some errors will
caught at type checking time and while other will be caught as the program
executes. After a decade of research on gradual types it has become clear
that the combination of mutable state, self references and subtyping
presents serious challenges to implementers of gradual type systems.  This
papers reviews the state of the art in gradual typing for objects. We
introduce \kafka, a class-based object calculus with a static type system,
dynamic method dispatch, transparent wrappers and dynamic class
generation. We model key features of several type systems for dynamic
languages by translation to \kafka and discuss the implications of the
respective designs.
\end{abstract} 



\section{Introduction}

\vspace{-5mm}

\epigraph{``Because half the problem is seeing the problem''}

\vspace{-5mm}

\noindent
A decade ago Siek and Taha~\cite{SiekTaha07} presented a gradual type system
for a variant of Abadi and Cardelli's object-based
calculus~\cite{cardelli:1996:theory-of-objects}. Their system featured a
dynamic type, denoted \any, and a subtype relation that combined structural
subtyping with a consistency relation between terms that differ in dynamic
type annotations.  Soundness at the boundaries between typed and untyped
code is ensured by inserting casts as was already done in their previous
work that targeted functional languages~\cite{SiekTaha06}.  Ten years later,
many systems support the gradual addition of types to untyped
object-oriented programs.\footnote{Languages which allow mixing typed and
  untyped with objects include
%%
C\#~\cite{Bierman10},
Dart~\cite{dart13}, 
DRuby~\cite{FurrAF2009},
Hack~\cite{hack13}, 
Gradualtalk~\cite{GS13},
Reticulated Python~\cite{siek14}, 
Safe Typescript~\cite{safe-typescript},
StrongScript~\cite{ecoop15}, 
Thorn~\cite{oopsla09}, 
Typed Racket~\cite{Takikawa:2012}, 
TypeScript~\cite{BAT14}.}
%%
Yet, faithful realizations of Seik and Taha's elegant idea have proved to be
surprisingly elusive.  One reason for this may be that the paper did not
consider state.  The combination of mutable state, aliasing and subtyping
complicates enforcement strategies as one must consider situations where an
object is being accessed at different types. While several solutions have
been proposed to address this, the performance implications of the
implementation strategies implied by these solutions seem
daunting.\footnote{Most practical \emph{sound} type system reports order of
  magnitude pathologies, e.g.~5x slow downs for
  Gradualtalk~\cite{allende13}, 10x for Reticulated Python~\cite{siek14},
  22x for Safe Typescript~\cite{safe-typescript}, and 121x for Typed
  Racket~\cite{popl16}. These numbers merely indicate the existence of
  configurations that hurt performance.  They are neither comparable nor
  worst case indicators.  Most systems lack rigorous evaluations.  }
Predictably, industry has chosen to compromise on soundness to avoid
degrading performance.\footnote{Industrial languages (Dart, Typescript,
  Hack) have unchecked modes that won't catch all type errors.}

The goal of this paper is to explore the design space of gradual type system
for object-oriented languages. We aim to expose some of the forces that have
influenced existing systems and discuss the implication of key design
decisions. While there are significant challenges that, in the end, may
prevent adoption of some of the more ambitious type systems, there are are
also opportunities for improving on existing techniques.  This paper will
hopefully lay out an agenda for future investigations.

In order to capture the essence of gradual typing for objects and to
highlight the challenges implementers face, we present translations of
gradual type system into a common target language. Targeting a common
language lets us reason about the different systems in the same framework
and makes comparisons possible. But which language should we target?  While
the common language should be simple to avoid linguistic clutter, key
features of object-oriented languages should be expressed directly rather
than by encoding. We propose to target a typed object-oriented language
inspired by modern runtime systems such as the Java Virtual Machine and the
.Net environment.  Both have reasonably efficient implementations. They have
a static type systems with classes and subtyping but allow for dynamically
resolved method dispatch.\footnote{Both languages can invoke methods
  reflectively based on the method's name. Since C\# 4.0, dynamic resolution
  is part of the language~\cite{BAT14}. In Java, \xt{invokedynamic} allows
  for custom method dispatch.} In both environments, primitive types can be
unboxed as the static typing an accurately final types.

One contribution of this work is thus the design of \kafka, a statically
typed object calculus.  \kafka is class based (with an explicit class table
\K), has mutable state (a heap address \a refers to an object, each field \f
is reifed into a pair of getter and setter methods), and allows the dynamic
generation of wrapper classes (by update of the class table \K and
allocation of new objects \a).  Methods can be statically resolved, denoted
by a simple call \Call\a\m\x, or can be dynamically resolved, denoted by a
dynamic call \DynCall\a\m\x. The \kafka type system is based on structural
type equivalence (although not essential, it could just as well use nominal
types with multiple subtyping \`a la Java).  The dynamic type is written
\any. To support transparent wrappers, a distinguished \that field is
available to wrapper classes without but does not show up in the class' type
signature.


The heart of a gradual type system implementation is the insertion of
explicit casts at type boundaries.  Four different casts are built-in the
language, two of these are called structural because they only inspect the
structure of the objects, the other two are generative as they create
wrappers.  The subtype cast \SubCast\t\a is a structural cast that checks if
the object references by \a is a subtype of type \t, \t can be either a
class \C or the dynamic type \any.  The shallow cast \ShaCast\t\a merely
checks that the object has all the methods of type \t without looking at
their signatures. A behavioral cast \BehCast\t\a generates a wrapper object
that monitors that methods invoked on \a abide by the interface of type
\t. The monotone cast \MonCast\t\a returns a wrapper which monitors all
invocations to the object referenced by \a, furthermore the wrapper can only
be refined by removing occurences of \any in its type.

\renewcommand{\u}[1]{\underline{#1}\xspace}

Another contribution of the work is the translation of gradual type
systems. Each gradually typed expression \HT{\u\e}{\u\T} is translated to a
\kafka term, \HT\e\T, each type \u\T has a corresponding \kafka type \T,
and, similarly, each expression \u\e has an equivalent \e. While soundness
in \kafka is straightforward (except the generative casts which have more
involved proofs), the soundnes of the gradual type system is more
interesting.  In \kafka, a well-typed program can only get stuck at a cast
or a dynamically resolved call.  With gradual types, an expression
\Call{\u\x}\m{\u{\x'}} where \u\x is declared to be of class \u\C can have
significantly different behavior depending on choices made while designing
the type system. TypeScript and Dart have \emph{optional types}; a
well-typed program can get stuck at any method call as \u\C translates to
\any. Languages such as C\# and StrongScript have \emph{concrete types}; a
well-typed program will not get stuck at statically resolved method calls,
\u\C maps to itself \C. Typed Racket has \emph{promised types}; a well-typed
program will not get stuck at the call to \m, because \u\x is guarantee to
refer to a \u\C or to a wrapper that implements all the methods of \u\C.  A
wrapper has a target object, the wrapper's role is to check if the target
behaves like an instance of \u\C.


\section{Background}


\vspace{-5mm}

\epigraph{ ``If you know the enemy and know yourself...''}

\vspace{-5mm}

\noindent The intellectual lineage of gradual types can be traced back to
attempts to add types to Smalltalk and LISP. A highlight on the Smalltalk
side is the Strongtalk optional type system~\cite{Bracha93} which led to
Bracha's notion of pluggable types~\cite{pluggabletypes}. For him, types are
solely to catch errors at checking time, they should never affect the
runtime behavior of programs. The rationale for this is that types are
viewed as an add-on that can be turned off without affecting semantics.  In
the words of Richards~\emph{et al.}~\cite{ecoop15}, an optional type system
is \emph{trace preserving}, which means that if a term \e reduces to value
\a, adding type annotations will never cause \e to get stuck. This property
is valuable to developers as it prevents type annotations from introducing
errors, also it follows that type annotations do not effect performance. The
optional type systems currently in wide use include Hack~\cite{hack13},
TypeScript~\cite{BAT14} and Dart~\cite{dart13}.  StrongScript~\cite{ecoop15}
and Thorn~\cite{popl10} allow programmers to choose between optional and
concrete types.

On the functional side, the ancestry is dominated by the work of Felleisen
and his students.  The Typed Scheme~\cite{tf-popl08} design that later
became Typed Racket is strongly influenced by their earlier work on
higher-order contracts~\cite{ff-icfp02}. Typed Racket was envisioned as a
vehicle for teaching programming to high-school students and undergraduates.
For that reason, being able to explain the source of errors was viewed as an
important design constraint as well as preventing surprises -- a variable
annotated as a \C should behave as a \C. If it doesn't, then that should be
reported at the first discrepancy. The approach to typing is thus quite
different from optional types. In Typed Racket, whenever a value crosses a
boundary between typed and untyped code, the value will be wrapped in a
contract that monitors it's behavior. This allows to ensure that the type of
mutable values remains consistent with their declared type and that
functions respect their declared interface. When a value misbehaves, blame
can be assigned to module where the value originated. In Typed Racket, the
granularity of typing is the module, thus each module is either entirely
typed or entirely untyped.

Siek and Taha coined the term gradual typing in~\cite{SiekTaha06} as any
type system that allows programmers to control the degree of static checking
for a program by choosing to annotate function parameters with types, or
not. Their contribution was formalization in a lambda calculus with
references and a proof of soundness that stated that all type errors would
be caught. They defined the type consistency relation $\t \sim \tp$ which
states that a type that agree on non-\any position are compatible.  In their
follow up~\cite{SiekTaha07} they extended the work to a stateless object
calculus and combined consistency with structural subtyping. Extending the
approach to mutable objects proved challenging. Reticulated
Python~\cite{siek14} attempts to find a reasonable compromise between
soundness and efficiency.  The language has three modes: in \emph{guarded}
mode, Python behaves as Typed Racket with contracts applied to values,
\emph{transient} mode performs first order checks before each call, and the
\emph{monotonic} mode is similar to guarded except there is at most one
wrapper per object and casts can only remove occurences of \any from its
type.

Other noteworthy systems include Gradualtalk~\cite{GS13}, C\#
4.0~\cite{Bierman10}, Thorn~\cite{oopsla09},
StrongScript~\cite{ecoop15}. Gradualtalk is a variant of Smalltalk with
Felleisen-style contracts and mostly nominal type equivalence. C\# 4.0 adds
the type {\sf dynamic} (i.e.~\any) to the language and dynamically resolved
method invocation when the receiver is of type \any.  This means C\# has a
dynamic sublanguage that allows developer to write unchecked code, but it
also has a strongly type sublanguage in which values are guaranteed to be of
their declared type.  Thorn and StrongScript extend the C\# approach with
the addition of optional types (called like types).  Thorn is a new language
implemented by translation to the JVM.\footnote{The translation strategy is
  quite close to that presented here.} The presence of concrete types means
that the compiler can optimize code (unbox data and inline methods) and
programmers are guaranteed that type errors will not occur within concretely
typed code.  StrongScript takes Thorn and reimplements it within the context
of TypeScript.  The interesting design choices there are that while
TypeScript originally relied on structural subtyping, StrongScript changed
the language to follow a nominal discipline. It is interesting to note that
this change did not affect the semantics of benchmark
applications. Moreover, to deal with higher-order functions which TypeScript
inherits from JavaScript, the language does use contract for functions.


\subsection{Surveying the design space}

\figref{over} gives a synthetic overview of systems with publicly available
implementations. All languages here are class-based, except TypeScript which
also has types for plain JavaScript objects. Most languages base subtyping
on the name of classes and on explicit subtype declarations, rather than on
structural similarities between classes.  Exceptions include Gradualtalk
which is nominal but also supports structural subtype if programmers want to
use it.  TypeScript uses structural subtyping, but does not implement a
runtime structural check. This is probably because of the JavaScript roots
of the language, annecdotal evidence suggests that structural subtyping is
not always exercised~\cite{ecoop15}.  The consistency relation used in
Reticulated Python is fundamentally structural.  For Racket, the heavy use
of first-class classes and class generation naturally leads to choosing
structural subtyping as many of the classes being manipulated have no names.


\newcommand{\rot}[1]{\begin{rotate}{80} #1 \end{rotate}}
\newcommand{\X}{\EM{\bullet}}
\newcommand{\XX}{\EM{\bullet^2}}
\newcommand{\XY}{\EM{\bullet^1}}

\begin{figure}[!ht]
  \center
~ \\[2cm]
  {\small
\begin{tabular}{r|lllllllllllllr}
& & \rot{Nominal}
  & \rot{Optional types}
  & \rot{Concrete types}
  & \rot{Promised types}
  & \rot{Class based}
  & \rot{First-class Class}
  & \rot{Soundness claim}
  & \rot{Unboxed prim.}
  & \rot{Subtype cast}
  & \rot{Shallow cast}
  & \rot{Generative cast}
  & \rot{Blame assignment}
  & \rot{Pathologies}
  \\
Dart         &&\X &\X &   &   &\X &   &    &    &\X &   &   &   &  - 
\\\hline
Hack         &&\X &\X &   &   &\X &   &    &    &\X &   &   &   &  -  
\\\hline
TypeScript   &&   &\X &   &   &\X &   &    &    &   &   &   &   &  -  
\\\hline
C\#          &&\X &\X &\X &   &\X &   &\XX & \X &\X &   &   &   &  -  
\\\hline
Thorn        &&\X &\X &\X &   &\X &   &\XX & \X &\X &   &   &   & 0.8x
\\\hline
StrongScript &&\X &\X &\X &\X &\X &   &\XX &    &\X &   &\X &   & 1.1x   
\\\hline
Gradualtalk  &&\XY&   &   &\X &\X &   & \X &    &   &   &\X &\X &  5x
\\\hline
Typed Racket &&   &   &   &\X &\X &\X &\X  &    &   &\X &\X &\X & 121x 
\\\hline
Reticulated Python    \\
\it Transient&&   &\X &   &   & \X &  & \X &    &   &\X &   &\X & 10x \\
\it Monotonic&&   &   &   &\X & \X &  & \X &    &   &   &\X &\X &  27x\\
\it Guarded  &&   &   &   &\X & \X &  & \X &    &   &   &\X &\X &  21x\\
\end{tabular}}
  \caption{Overview of implemented systems. (1) Gradualtalk has optional
    structural constraints. (2) Concretely typed expressions are sound in
    C\#, Thorn and StrongScript.}\label{over}
\end{figure}

Optional types are the default execution mode for Dart, Hack and TypeScript.
Dart has a checked mode that can be turned on to catch some type errors.
The Transient variant of Reticulated Python is essentially optionally typed,
any value can flow into a variable regardless of its type
annotation. Run-time checks are applied before method invocation.  C\#,
StrongScript and Thorn support both optional and concrete types.  In the
case of Thorn and C\#, when primitives are concretely typed they can be
unboxed and do not require tagging.

The choice of casts follows from other design decisions. Languages with
concrete types naturally tend to use subtype casts to establish the type of
values. For nominal systems there are highly optimized algorithms. Shallow
casts are casts that only checking the presence of methods not their
signature. These are used by Racket and Python to ensure some basic form of
type conformance. Generative casts are used when information such as a type
or a blame label must be associated with a reference or an object.

The last column of \figref{over} lists self-reported performance
pathologies.  These numbers are not comparable as they refer to different
programs and different configurations of type annotations. They are also not
likely to be worst case scenarios as many of these languages do not have a
sufficient corpus of code written in them to conduct a thorough evaluation.
Lastly, these implementations have not been optimized.  Nevertheless, one
can observe that for optional types no overhead is expected as the type
annotations are erased during compilation. Concrete types introduce very
cheap casts, and lead to code that is can be compiled more efficiently. So
experiments suggest performance improvements.  The Transient Reticulated
Python performance can be viewed as a worst case scenario for concrete types
-- i.e. there is a shallow cast at almost every call. Finally languages
with generative casts tend to suffer prohibitive slow downs in pathological 
cases.

\subsection{Blame}
Blame assignment is a topic of investigation in its own right
(e.g.~\cite{Wadler09,SW09,Ahmed09}). Anecdotal evidence from Typed Racket
users suggests that context provided by blame when a run-time type error
occurs is valuable. It helps developers pinpoint the provenance of the
ill-typed value or function that caused the error. A fitting analogy are the
stack traces printed by Java when a program terminates abruptly. Developers
working with languages like C++ must run their program in a debugger to
obtain the same information. In Java, stack traces have little run-time cost
because they piggyback on another feature of the language, namely precise
exceptions.\footnote{ Java's precise exceptions have a price, they inhibit
  some compiler optimizations, but for stack traces the compiler only need
  retain names of methods on the stack and record them on {\sf throw}.} It
is likely that recording blame may be more costly as some information must
be associated with values at every cast.

[Do: fix references to the most recent results on Blame.]

\subsection{Trace preservation}

The semantics of the various type systems have subtle distinctions. Ideally,
one would like to reject programs that will fail, but there is a tension
because some of the dynamically typed code exploits the fact that it is
dynamically typed.  Type systems are correctly pesmistic and will flag
potential errors.

To illustrate the difficulties we provide four litmus tests, these are small
programs written in \kafka syntax but that can also be expressed in all the
languages of interest.

Each of these programs consists of a class table composed of the respective
litmus classes, some auxiliary code and a main expression.

In all cases the main expression is a call to the method t of class T with an argument of class A.

In all cases, the program is well typed statically.

In the optionally typed semantics of e.g. Dart, all tests run to
completition without getting stuck.

Using concrete types in Thorn, all of these programs will get stuck with
subtype cast expression error. As class A is not a subtype of I, nor I'.
Thus in each test the program qill get stuck when A is passed where an I
expected.

With optional types and the Transient RP semantics, L1 fails because transient
checks that A has all the method names of I. Which it does not.
L2,L3 and L4 succeed, because Transient only checks names at calls.



\begin{figure}[!ht]
\begin{tabular}{cc}
  \begin{tabular}{|@{}cc@{\hspace{1mm}}|}\hline
  \begin{minipage}{4.3cm}
    \begin{lstlisting}
class A {
   m(x: A): A {this}}

class I {
   n(x: I): I {this}}

class T {
   t(x: I): T {this}}
      \end{lstlisting}    
  \end{minipage}
&
  \begin{minipage}{4.6cm}
    \begin{lstlisting}
class A {
  m(x: A): A {this}}

class I {
  m(x: C): I {this}}

class T {
  t(x: I): T {this}}
      \end{lstlisting}    
  \end{minipage}
\\[2mm]
(Litmus test 1) & (Litmus test 2)\\[3mm]
  \begin{minipage}{4.3cm}
    \begin{lstlisting}
class A {
  m(x: *): * {this}}

class I {
  m(x: C): C {this}}

class I2 {
  m(x: D): D {this}}

class E {f: I g: I2}

class T {
  t(x: A): E {
      new E(x,x)}}
      \end{lstlisting}    
  \end{minipage}
&
  \begin{minipage}{4.6cm}
    \begin{lstlisting}
class A {
  f: *
  m(x: A): A {
    this.f(
      new A(new C())}}


class I {
  f: D
  m(x: I): I {this}}


class T {
  t(x: I): I {x.m(x)}
      \end{lstlisting}    
  \end{minipage}
\\[2mm]
(Litmus test 3) &  (Litmus test 4)\\\hline
  \end{tabular}
  &
\begin{minipage}{4cm}
\begin{tabular}{|@{}c@{\hspace{1mm}}|}\hline
  \begin{minipage}{4cm}
    \begin{lstlisting}
class C { 
  n(x: C): C {this}}

class D {
  o(x: D): D {this}}
    \end{lstlisting}    
  \end{minipage}
 \\
  (Auxiliary classes)\\\hline
\end{tabular}
\\ \\ \\  
\begin{tabular}{|@{}c@{\hspace{1mm}}|}\hline
  \begin{minipage}{4cm}
    \begin{lstlisting}
new T().t(new A())
    \end{lstlisting}    
  \end{minipage}
  \\
  (Program 1-3)\\\hline
\end{tabular}
\\ \\ \\  
\begin{tabular}{|@{}c@{\hspace{1mm}}|}\hline
  \begin{minipage}{4cm}
    \begin{lstlisting}
new T().t(
    new A(new D()))
    \end{lstlisting}    
  \end{minipage}
  \\
  (Program 4)\\\hline
\end{tabular}
\end{minipage}
\end{tabular}

~\\

\center
\renewcommand{\V}{\EM{\checkmark}}
\begin{tabular}{|r|l@{~}l@{~}l@{~}l|}\hline
                     & L1 & L2 & L3 & L4\\\hline\rowcolor{Gray}
Thorn                &    &    &    &   \\
Typed Racket         &    & \V & \V &  \\\rowcolor{Gray}
Monotonic  RetPy     &    & \V &    &   \\
Transient RetPy      &    & \V & \V & \V \\\rowcolor{Gray}
TypeScript           & \V & \V & \V & \V \\\hline
\end{tabular}  
  \caption{Semantic litmus tests.}\label{litmus}
\end{figure}




[Say: OOP with structural subtyping makes it easier to make contract errors.]


\subsection{Soundness}

[Say: All dynamic OO language have a dynamic type system that catches type errors.  So the difference between Sound and unsound is (a) the place where the error is caught, (b) cases when the gradul type system departs from the underlying type system.]  

\subsection{Performance}

The only exhaustive study of performance of gradual typing~\cite{popl16} was
provocatively titled ``Is sound gradual typing dead?''.  Takikawa~\emph{et
  al.}  reported that 14 out of 16 small real-world programs had performance
cliffs past which partially typed code would run between 2x and 121x slower
than untyped code. Few if any commercial system could justify that increased
assurance is worth is worth a performance regression of this
scale.\footnote{Otherwise one would accept some of the research prototypes
  adding memory safety to C would have become mainstream.} While there is
ongoing research towards reducing the overheads of
contracts~\cite{pycket15}, preliminary results suggest that the ...


[Say: primitive and immutable value checks are cheap]

[Say: first order functions w/o recursion are cheap ]

[Say: higher order/recursive functions are expensive]

[Say: TR works well as long as you don't exchange large mutable values or hof]

[Say: OOP is all about large graphs and hof ==> ouch ]

[Say: consistency makes it impossible to unbox.]

\section{Gradual Typing in Practice}

We review five type systems.

We use the \kafka syntax for our examples even if it will only be explained later.

It should be self explanatory.

\newcommand{\code}[1]{{\tt #1}\xspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{TypeScript}

Typescript~\cite{BAT14} is a backwards compatible extension of JavaScript
with classes and type annotations. Type equivalence is structural and
subtyping of recursive types is supported (types arise from class
declarations). Missing annotations are treated as \any. The role of types is
to catch simple errors such the misspelling of the method of class \code A:

\begin{lstlisting}
  class A { }
    m(x: C): A { this } }

  new A().n(new C())
\end{lstlisting}

Well-typed code is translated to plain JavaScript with all types erased and
methods resolved dynamically. In our translation to \kafka the above program
(with the correct method name \code m) translate to the following.

\begin{lstlisting}
  class A { }
    m(x: *): * { this } }

  new A()@m(new C())
\end{lstlisting}

The snippet now uses dynamic calls (written \code @) and methods signature
are set to \any. It is easy to trick the compiler into accepting incorrect
cdoe, the following would be compile and would throw a JavaScript exception.

\begin{lstlisting}
  (<*>new A()) . n(new C())
\end{lstlisting}

TypeScript's designers saw unsoundness as a way to ensure that (a) types do
not prevent a program from running, e.g. when importing a new library with
type annotations inconsistent with clent code; and that (b) existing
browsers can run TypeScript code with no overheads.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Thorn}

Thorn~\cite{oopsla09} is an object-oriented language with multiple
inheritance, nominal type equivalence and a combination of optional and
concrete types.  Optional types (written here \code{?T}) are treated exactly
as in TypeScript, they are translated to dynamic and method invocations are
resolved dynamically. Concrete types (written \code{T}), on the other hand,
are treated as they would be in Java. A variable \code{x:~C} is guaranteed
to be of class \code C or of a subtype thereof.

\begin{lstlisting}
class A {
  m(x: ?C): ?C { x }
  n(x:  C):  C { x }
}

new A().m( new D() )  // OK -- warning
new A().m( new C() )  // OK -- C <: ?C
new A().n( new D() )  // ERR -- D !<: C
\end{lstlisting}

In the above code snippet, class \code A has one method taking an optional
type and the other taking a concrete type. Assume \code C and \code D are
unrelated. The first call is allowed because the type of \code m is treated
as \any (the Thorn compiler does emit a warning). The second call is ruled
out as incorrect.

Translating Thorn to \kafka is straightforward. Optional types are translated
to \any. Method calls with either receiver 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Typed Racket}

Typed Racket is an extension of Racket, designed to allow programmers to
type their untyped Racket code. It differs in two key ways from
Strongscript, using \emph{promised types}, as mentioned before, but also in
where it allows programmers to add types in the first place. Gradual typing
evokes images of programmers altering their programs to add more
types. However, an important question arises about that mental picture: what
does it mean to gradually add types to a program?

The answer taken by Strongscript and the other gradual typing systems we
discuss in this paper is that programmers should be able to add a type
anywhere one is syntactically valid. However, this idea is somewhat
artificial - some programmers will add types slowly, one function at a time,
while others will type whole compilation modules at a time.

The approach taken by Typed Racket is built around this latter style of
gradual typing.  Instead of adding types to individual functions, it allows
programmers to type their programs one module at a time, where each module
is a separate compilation unit.  This approach constrains the way that
programmers can add types to programs, and one that avoids having to reason
about what it means to have a partially typed method, since in Typed Racket
everything in a module is either fully typed or completely untyped.

Additionally, Typed Racket is the first of the \emph{promised type} systems
we will be discussing. Suppose that you have a variable $\x$ under type $\t$
where $\t$ has some method $\xt{f}$. Naturally, you would expect to be able
to call $\xt{f}$ (as \verb|(send x f)|), and would expect that your type
would guarantee that this function call would both work and return a value
of the correct type.

However, there are a number of places where this basic assumption can be
violated, as a result of the interaction of typed and untyped code. If the
underlying value has no function \xt{f}, then this call will fail, but this
would be a runtime type error, exactly the kind of problem that we wish to
avoid.

The solution to this problem comes from how Typed Racket controls the
interaction between modules, at the \emph{module boundaries}, where the
system has to ensure that the untyped code respects the type annotations. To
ensure that the type annotations are respected, Typed Racket uses
contracts. The idea behind using contracts~\cite{ff-icfp02} that they allow
the system to check the types on the values going into typed code from
untyped code, and values flowing out of untyped code into typed code.

\begin{figure}[h]
% to generate, run
% racket format-racket.rkt ../examples/typed_racket/untyped1.rkt untyped-rkt1.pdf
% racket format-racket.rkt ../examples/typed_racket/typed1.rkt typed-rkt1.pdf
\includegraphics{figures/untyped-rkt1.pdf}
\caption{untyped1.rkt: a simple Racket file}
\label{fig:ut1r}
\end{figure}

\begin{figure}
\includegraphics{figures/typed-rkt1.pdf}
\caption{typed1.rkt: Typed Racket file using untyped1.rkt}
\label{fig:t1r}
\end{figure}

This construction, whereby every module is either entirely typed or entirely
untyped allows Typed Racket to take a unique approach to enforcement, built
around contracts~\cite{tf-popl08} applied at the points where modules
interact. Types of values are checked at boundaries, and methods are
effectively wrapped as they cross between modules.

The key drawback to this approach is that a wrapper cannot establish
\emph{actual identity} the same way that \emph{concrete} type systems like
Strongscript can. Instead, wrapper or guard based systems like the Typed
Racket approach can only prove that a given untyped function will \emph{act
  like} a typed function, up to cast errors, and have to be executed every
time a value passes through a typed-untyped boundary.

As a demonstration of this, consider figure~\ref{fig:tr2}. Here we import
the same untyped function, but instead of using the correct type annotation
for the (untyped) identity function, we assert that it takes an integer and
makes it into a string. This type annotation is clearly wrong, but Typed
Racket has no way of checking that it is correct when it is applied. Rather,
we are allowed to use the \xt{id} function, and only find out that the type
is wrong when it returns a number where we expected a string.

\begin{figure}[h]
% racket format-racket.rkt ../examples/typed_racket/typed2.rkt typed-rkt2.pdf
\includegraphics{figures/typed-rkt2.pdf}
\caption{typed2.rkt: Invalid type annotation}
\label{fig:tr2}
\end{figure}

However, the use of promised typing provides a major advantage: untyped code
does not need to be aware of types. In order to use a \emph{concrete} type
system, even untyped code must exist in at least an inheritance hierarchy
that can be reasoned about by the runtime type checking system. As a result,
promised typing can be used in languages that do not have class hierarchies.

While promised type systems can successfully type more code, they are
limited in that they cannot absolutely establish type correctness across
casts, unlike concrete type systems. As a result, errors occur when untyped
code is used, rather than at the boundary crossing.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Reticulated Python}

Reticulated Python is an extension of Python adding sound gradual types by
Vitousek et al~\cite{siek14}, providing Python programmers with
the ability to add types to their programs. Unlike the other languages we
have examined here, though, Reticulated Python supports multiple different
semantics for these types, providing different guarantees and imposing
different restrictions.

Three different gradual typing semantics are currently avaliable in
Reticulated Python: transient, monotonic, and guarded. All three systems are
promised typing approaches, checking to ensure that untyped code behaves as
if it were typed from the perspective of a typed observer. However, the
mechanism for achieving this differs in each case.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Transient}

In both the Strongscript and Typed Racket approaches, if you wrote a method
(denoted $\m$ here) under type $\xt{int} \rightarrow \xt{int}$, you could be
assured that you would only ever be called with an argument that was
actually an int. To achieve this guarantee, the systems alternately
performed inline runtime casts based on runtime type information and
inserted wrappers to check that the types were respected \emph{before} an
actual function call was made. Likewise, a function that was declared to
return an int would always return an int, ensured either by wrapping or by
adding casts inside of it.

Transient takes the opposite perspective. Instead of the caller being
responsible for checking the types on the arguments and the callee ensuring
the return type is correct, the transient semantics for Reticulated Python
has the callee enforce the types on the arguments and the caller enforce the
type of the return value.

To illustrate this, consider figure~\ref{fig:guard2}. If we look at the
execution trace that produces the error, we find the following sequence of
events happened:
\begin{enumerate}
\item Evaluate \verb|A1()| to value \xt{v}
\item Wrap \xt{v} with wrapper \xt{A2W}, producing \xt{vw}
\item Invoke \verb|test| with \xt{vw}
\item Call \verb|a| with 2 on \xt{vw}
\item \xt{A2W} checks that 2 is an integer
\item Append 2 to the string ``foo'' inside \xt{A1.a}
\item Return ``2foo'' 
\item \xt{A2W} finds that ``2foo'' is not an integer, and errors.
\end{enumerate}

Likewise, in figure~\ref{fig:guard3}, we would end up with steps 5 and (a
successful) step 8 repeated 1000 times in the execution trace. However, we
can ``bake in'' the checks added by \xt{A2W} into the program itself,
resulting in figure~\ref{fig:trans1}.

\begin{figure}[h]
\begin{verbatim}
class A1:
  def a(a : Any) : Any:
    return a + "foo"
class A2:
  def a(a : Int) : Int:
    check(a, Int)
    return a + 2

def test(a:A2):Int
  return check(a.a(2), Int) + 1

test(A1())
\end{verbatim}
\caption{Transient: Type checks baked into source.}
\label{fig:trans1}
\end{figure}

This embedding preserves the execution trace that we saw in the guarded
semantics, but also completely avoids the problems inherent to having
wrappers added at type transitions. However, while the transient semantics
is able to preserve the execution trace, the site at which the error happens
is somewhat different.

In the guarded semantics, step 8 happened \emph{before} the function
\verb|a| was able to return, and therefore the caller effectively never saw
the wrong type. In the transient semantics, the caller is now responsible
for ensuring that the types of the values passed into it are correct, which
has two key implications.

The first is that the site where errors occur is now slightly
different. When a function returns a value that does not match up with the
type that it produces, that discrepancy is now noticed in the caller,
instead of inside of the wrapper.

This leads to the second implication of the transient semantics: all typed
code now has to add type checks, as seen in \verb|A2.a| in
figure~\ref{fig:trans1}. No typed code can trust any type, be that a type
that is passed in (for the case where untyped code calls typed code), or a
type returned from another function (as the other function could be
untyped).

While this approach completely avoids the problem identified in
figure~\ref{fig:guard3}, it raises a new performance issue: this check
cannot be statically removed. Any nominally typed variable can now no longer
be statically trusted to respect its type, and as a result, every invocation
must be checked for type safety. Therefore, the transient semantics will run
into performance issues, if naievly implemented, as more types are added,
contradicting the typical wisdom about types and performance. While a more
sophisticated implementation may be able to avoid some of these checks, even
better performance of typed code can be made possible by using a different
type safety guarantee.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Monotonic}
A key downfall of the approaches we discussed previously is that they
cause performance impacts in fully-typed code, especially at heap access
sites.The monotonic semantics for Reticulated Python aims to recover this,
in exchange for a new dynamically-enforced guarantee.

To see why the impact exists, consider the following code

\begin{verbatim}
function evil(x : *) : * {
	x := "foo bar"
}

Ref<Int> a = Ref(3)
evil(a)
Int y = !x + 2
\end{verbatim}

If we stripped all checks from this code, we would end up with a stuck
state, since we would be adding a string to an integer, despite statically
typing the value of $\a$ as an integer, as we were able to assign to the
underlying reference from an untyped context.

The approaches discussed for Typed Racket and the transient semantics
handle this case differently, but both require that the typed code perform
a typecheck at the dereference of $\x$. Problematically, these checks
have to be performed even in a fully typed program, because it is impossible
to know which pointers have been exposed to dynamic code.

The key feature of the monotonic semantics is that it imposes these checks
on the dynamic code - any dynamic reference has to respect the types imposed
by a typed reference. In the above example, the monotonic semantics would
produce an error when we tried to assign a string into $\x$ - despite the
static typing working out, because the reference has a type which is
incompatible with our new type, monotonic will reject it at that point.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Kafka: A Core Calculus}

We propose to explore the semantics of gradually typed object-oriented
languages by compilation to a core calculus, named \kafka.

Following the design of C\# 4.0, \kafka is a statically typed class-based
calculus with dynamic dispatch.

In order to support the notion of consistency, we choose a structural type
system for \kafka.  The calculus does not have inheritance between classes.

\kafka does not have null values.\footnote{What would the type of null be?}

Fields are accessed by getter and setter methods, their presence in class
types is observed by the presence of the respective getters and setters.


Following C\#, \kafka allows a dynamic type, denoted \any. 

Statically dispatched method calls (i.e. calls where the type of the
receiver is not \any) are denoted \Call\x\m\e. Methods are limited to a
single argument for simplicity.

Dynamically dispatched method calls (i.e. call where the type of the receiver
is \any) are denoted \DynCall\x\m\e.

A new object is created with a class name and a sequence of arguments in the
order of definition of fields, denoted \New\C{\b\e}.

Meta-variable \x ranges over argument names, \a over memory locations, \f
over field names (as well as getter and setter methods), \m over method
names, \C, \D, and \E over class names.  We use \n to refer either to
methods or field names.

\this is a distinguished variable name that denotes the current object.

\that is a distinguished field name that denotes the target of a wrapper.

\D is a meta-variable used to range over dynamically generated class names.

\a is ranges over heap addresses.

\k ranges over class definitions consisting of a class name, followed by
a, possibly empty, sequence of field definitions, \fd, and a, possibly empty,
sequence of method definitions, \md.

\begin{figure}[!h]
\hrulefill

\begin{minipage}{6.3cm}\begin{tabular}{@{}l@{~}l@{}l@{}l@{}ll}
\e &::=  \x         &\B \this         &\B \that        &\B \New\C{\b\e} \\
   &\B \Get\e\f     &\B \Set\e\f\e    &\B \Call\e\m\e  &\B \DynCall\e\m\e \\
   &\B \SubCast\t\e &\B \ShaCast\t\e  &\B \BehCast\t\e &\B  \MonCast\t\e \\
   &\B \a \\ 
\end{tabular}\end{minipage}
\begin{minipage}{6cm}\begin{tabular}{l@{~}l@{}l@{}l}
   ~ \k &::= \Class \C {\b\fd}{\b\md}
\end{tabular}
\begin{tabular}{l@{~}l@{}l@{}l}
\md &::= \Mdef\m\x\t\t\e   &\B  \Mdef\f\x\t\t\e &\B \Mdefz\f\t\e \\
\mt &::= \Mtype\m\t\t &\B~  \Mtype\f\t\t  &\B \Mtype\f{}\t  \\
~ \t&::= ~ \any  \B   \C  & \fd~ ::= ~ \Fdef\f\t \\ 
\end{tabular}\end{minipage}

\hrulefill

\caption{\kafka Syntax.}\label{syn}
\end{figure}

%% TODO Put somewhere????
%\E  &::= \Ftype\x\t  \B \none\\
% \s  &::= ~~\none ~~ \B ~~  {\Bind{\a}{\obj\C{\b\a}}}~\s


\kafka has four different kinds of cast expressions, two are structural and
two are generative. The structural subtype cast, denoted \SubCast\t\a,
asserts that the object at location \a is of type \t.  The structural
shallow cast, denoted \ShaCast\t\a, asserts that the object at location \a
has methods with names matching those of \t. This does not make any
guarantee about the type of arguments.  The generative behavioral cast,
denoted \BehCast\t\a, will ensure that either \a behaves as a \t or that it
get stuck. The generative monotonic cast, denoted \MonCast\t\a, is a
behavioral cast that, in addition, imposes constraints on fields.


\subsection{Semantics}

\begin{tikzpicture}
% states
\draw (0,0) node[anchor=west] {$\K~\e$}
      (2,0) node[anchor=west] {$\Kp~\ep$}
      (4,0) node[anchor=west] {$\Kpp~\a$};

% transitions
\draw (1-0.1,-0.1) node[anchor=west] {$\progtrans{}{}$}
      (3,0) node[anchor=west] {$\longrightarrow^*$};

%requirements
\draw (2,-0.5) node[anchor=west] {$\WFp\Kp\ep$};
\draw (2-0.1,-1) node[anchor=west] {$\EnvType {}{}\Kp\ep\t$};

\draw (4-0.1,-1) node[anchor=west] {$\EnvType {}{}\Kpp\a\t$};
\end{tikzpicture}

The semantics of \kafka is defined by a small step operational semantics with
evaluation contexts.

Evaluation context deterministically identifiy the next expression to evaluate.

Program error is denoted by a stuck term.

The semantics operate over an explicit class table, denoted \K, which is a
sequence of class definitions.

A heap, denoted \s, maps memory locations to
objects. We use the notation \Map\s{\Bind\a{\obj\C{\b\a}}} to denote the
heap \s extended by the binding of location \a to object \obj\C{\b\a}.

A configuration \K\e\s evaluates in one step to a new configuration, denoted
\Reduce \K\e\s \Kp\ep\sp.

Execution terminate if \ep\xspace is a value, \a, or if there is no applicable
reduction, in which case the program is stuck.\footnote{Intuitively we would
  expect that the program can only get stuck at dynamic calls or at
  structural casts. But generative casts add some complexity to that
  statement.}

New object creation picks a fresh memory location  and binds it to the
newly created.

Operations on fields require a typed receiver, for example in the expression
\Get\this\f, \this is always of the type of the current class. Field access
through a getter method, works as follows. If the receiver's class has a
getter method, that method is evaluated, otherwise the field corresponding
the getter's name is updated.

Methods are segregated into typed method (methods whose argument is not
\any) and untyped method (methods whose argument is \any). The former can be
called by statically resolved method, the latter must be called by
dynamically resolved methods.

The function \names{} returns the names of methods. 

The function \untyped{} returns the methods whose types are \any.

The auxiliary function \xt{read} return the location \ap pointing to the
field \f of the object at location \a. The auxiliary function \xt{write}
return the heap \sp with the field \f of the object at location \a updated
to the location \ap.

We write \App\K\C to denote the lookup of class \C in class table \K.

We write  \Mdef\m\x\t\tp\e \In \k to denote that method \m occurs in class \k.

Ordering within lists of fields and methods definition is not relevant. (ie we can reorder when convenient)


\begin{figure}[!h]
\hrulefill

\begin{minipage}{8cm}
  \opdef{\Reduce \K\e\s \Kp\ep\sp}
        {\e\s evaluates to \ep\xspace in a step}\\[-1mm]
\begin{tabular}{l@{}l@{~}l@{~}l}
\CondRule{E1}{  %% new C -> a
   \fresh\ap 
}{ 
  \ReduceA \K{\New\C{\b\a}}\s \K\ap{\Map\s{\Bind\ap{\obj\C{\b\a}}}}
}
\CondRule{E2}{  %% a.f() -> e
    \Mdefz\f\t\e \In \App\K\C \AND  \App\s\a =\obj\C{\b\a}
}{
   \ReduceA \K{\Get\a\f}\s \K{[\a/\this]\e}\s
}
\CondRule{E3}{  %% a.f(a) -> e
    \Mdef\f\x\t\t\e \In \App\K\C \AND  \App\s\a=\obj\C{\b\a}
}{
   \ReduceA \K{\Set\a\f\ap}\s \K{[\a/\this~{\ap/\x}]\e}\s
}
\CondRule{E4}{  %% a.f() -> e
 \readf \s\a\f\K =  \ap 
}{
  \ReduceA \K{\Get\a{\f}}\s  \K\ap\s
}
\CondRule{E5}{  %% a.f(e) -> e
 \setf \s\a\f\ap\K =  \sp
}{
  \ReduceA \K{\Set\a{\f}\ap}\s \K\ap\sp
}
\CondRule{E6}{  %% a.m(a) -> e
  \Mdef\m\x\D\Dp\e  \In \App\K\C \AND \App\s\a=\obj\C{\b\a}
}{
 \ReduceA \K{\Call\a\m\ap}\s \K{[\a/\this~{\ap/\x}]\e}\s
}
\CondRule{E7}{  %% a@m(a) -> e
    \Mdef\m\x\any\any\e \In \App\K\C \AND \App\s\a=\obj\C{\b\a}
}{
  \ReduceA \K{\DynCall\a\m\ap}\s \K{[\a/\this~{\ap/\x}]\e}\s
}
\CondRule{E8}{  %% Subtypecast
}{ 
  \ReduceA \K{\SubCast \any\a}\s \K\a\s
}
\CondRule{E9}{  %% Subtypecast
  \StrSub {}\K\C \D \AND \App\s\a=\obj\C{\b\a} 
}{ 
  \ReduceA \K{\SubCast \D\a}\s \K\a\s
}
\CondRule{E10}{  %% Shallow Structural
}{ 
  \ReduceA \K{\ShaCast \any\a}\s \K\a\s
}
\CondRule{E10b}{  %% Shallow Structural
 \names{\untyped{\App\K\C}}  $\supseteq$  \names{\untyped{\App\K\D}} \AND \App\s\a=\obj\C{\b\a} 
}{ 
  \ReduceA \K{\ShaCast \D\a}\s \K\a\s
}
\CondRule{E11}{  %% Behavioral cast
  \behcast \a\t\s\K  \Kp\ap\sp
}{ 
  \ReduceA  \K{\BehCast \t\a}\s \Kp\ap\sp
}
\CondRule{E12}{  %% Monotonic cast
  \moncast \a\t\s\K  \Kp\sp
}{ 
  \ReduceA \K{\MonCast\t\a}\s \Kp\a\sp
}
\CondRule{E13}{  %% E[e] -> E[e']
  \Reduce \K\e\s \Kp\ep\sp
}{
 \ReduceA \K{\EE[\e]}\s \Kp{\EE[\ep]}\sp
}
\end{tabular}\end{minipage}

%%%%%%%%%%%%%%%%%%% CONTEXTS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
~\\[2mm]

\begin{minipage}{4cm}\begin{tabular}{l@{~~}l@{~}l@{~}l@{~}l@{~}l@{~}l@{~}l}
\EE &::= \Get\EE\f     &\B
        \Set\EE\f\e   &\B
        \Set\a\f\EE   &\B  
        \Call\EE\m\e  &\B
        \Call\a\m{\EE} &\B
        \DynCall\EE\m\e   &\B
        \DynCall\a\m\EE   \\
   &\B~
       \SubCast\t\EE  &\B
       \ShaCast\t\EE  &\B
       \BehCast\t\EE &\B
       \MonCast\t\EE  &\B
       \New\C{\b \a\,\EE\,\b\e}
  &\B \EM{\square}
\end{tabular}
\end{minipage}

\hrulefill
\caption{\kafka Semantics.}
\end{figure}


\subsection{Structural Casts}

\kafka offers two kinds of structural casts. One which performs a structural
subtype check and one that only check for the persence of methods with given
names.



\subsection{Generative Casts}

Casts are the key to the different interpretations of gradual typing, as
they are one of the two places that, in \kafka, a program can get stuck
at. The approaches that we will be comparing have different definitions of
casting, and their varying approach to runtime type assertions forms an
important part of how they interact with untyped parts of the program.

\subsubsection{Behavioral Casts}

A behavioral cast \BehCast\t\a will return a fresh \ap that refers to an
object that behaves as if it was of type \t. In case, the underlying object
departs from that expected behavior, the computation will get
stuck. Behavioral casts are generative as they create a new wrapper class
which monitors the target object for conformance to the interface of \t.
\figref{behave} details the semantics of this cast. \ruleref{BC1} is the
cast where an object \obj\C{\b\a} is cast to a class \Cp. This leads to the
creation of a wrapper class \k (under a new name \D). The class is appended
to the class table \K.  The cast returns a reference \ap to an instance of
this wrapper class pointing to the original object. The wrapper class is a
structural subtype of the target class, so \D\Sub\C holds. \ruleref{BC2}
handles the case where the target type of the cast is \any.


\begin{figure}[!ht]
\hrulefill
%%%%%%%%%%%%%%%%% BEHCAST %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\vspace{-2mm}

{  \small
  \begin{mathpar}
\IRule{BC1}{
  \App\s\a = \obj\C{\b\a}  \\
  \fresh\D \\\\
  \k = \wrap\C{\getmds\C\K}{\classoff\C\K}{\classoff\Cp\K}\D\\\\
  \fresh\ap \\
  \sp = \Map \s{\Bind\ap{\obj\D{\a}}} \\  
}{
  \behcast\a\Cp\s\K {\K\,\k}\ap\sp
}

\IRule{BC2}{
  \App\s\a = \obj\C{\b{\a_1}}  \\
  \fresh\D \\\\
  \k = \wrapAny\C{\getmds\C\K}{\classoff\C\K}\D\\\\
  \fresh\ap \\
  \sp = \Map \s{\Bind\ap{\obj\D{\a}}} \\  
}{
  \behcast\a\any\s\K {\K\,\k}\ap\sp
}
\end{mathpar}}  

\vspace{-2mm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hrulefill
\caption{Behavioral casts.}\label{behave}
\end{figure}

\figref{wrap} details the construction of wrapper classes. A wrapper is a
class that has the distinguished field \that, at the type of the target
object and a set of methods that mirrors the methods of the target object
but with additionals casts to some of their arguments and return values.
For getters, setters and typed methods, the wrapper simply adds a behavioral
casts to argument, issues a typed call, and then casts of the result. For
untyped methods, a dynamic call is blanketed by casts to \any.

\newcommand{\rtranst}[6]{#1 \Rightarrow #2 ~ #3 / #4 \vdash #5 \looparrowright_{beh} #6}

\begin{figure}[!ht]
\hrulefill
\begin{mathpar}
\IRule{REW1}{ }{ \rtranst{\b{\mt}}{\b{\mtp}}\e\x\x{[\e/\x]\x} }
\\
\IRule[width=25em]{REW2}{ \Mtype\n{\b{\t_1}}{\tp_1} \in \b{\mt} \\ \Mtype\n{\b{\t_2}}{\tp_2} \in \b{\mtp} \\ \n = \f \vee \t_1 \neq \any  \\ 
\b{\rtranst{\b{\mt}}{\b{\mtp}}\e\x{\e}{\ep}}}{\rtranst{\b{\mt}}{\b{\mtp}}\e\x{\Call{\this}\n{\b\e}}{\BehCast{\tp_1}{\Call{\this}\n{\b{\BehCast{\t_2}{\ep}}}}}}
\\
\IRule[width=18em]{REW3}{ \Mtype\m{{\t_1}}{\tp_1} \in \b{\mt} \\ \Mtype\m{{\any}}{\any} \in \b{\mtp} \\ 
\b{\rtranst{\b{\mt}}{\b{\mtp}}\e\x{\e}{\ep}}}{\rtranst{\b{\mt}}{\b{\mtp}}\e\x{\Call{\this}\m{\e}}{\BehCast{\tp_1}{\DynCall{\this}\m{{\BehCast{\any}{\ep}}}}}}

\IRule[width=25em]{REW4}{ \Mtype\n{\b{\t_1}}{\tp_1} \in \b{\mt} \\ \Mtype\n{\b{\t_2}}{\tp_2} \not\in \b{\mtp}  \\ 
\b{\rtranst{\b{\mt}}{\b{\mtp}}\e\x{\e}{\ep}}}{\rtranst{\b{\mt}}{\b{\mtp}}\e\x{\Call{\this}\n{\b\e}}{{\Call{\this}\n{\b{{\ep}}}}}}

\IRule[width=20em]{REW5}{ \e_1 \neq \this \\ \rtranst{\b{\mt}}{\b{\mtp}}\e\x{\e_1}{\e_2} \\ \b{\rtranst{\b{\mt}}{\b{\mtp}}\e\x{\ep_1}{\ep_2}}}{\rtranst{\b{\mt}}{\b{\mtp}}\e\x{\Call{\e_1}\n{\b{\ep_1}}}{\Call{\e_2}\n{\b{\ep_2}}}}

\IRule{REW6}{ \rtranst{\b{\mt}}{\b{\mtp}}\e\x{\e_1}{\e_2} \\ \rtranst{\b{\mt}}{\b{\mtp}}\e\x{\ep_1}{\ep_2}}{\rtranst{\b{\mt}}{\b{\mtp}}\e\x{\DynCall{\e_1}\m{\ep_1}}{\DynCall{\e_2}\m{\ep_2}}}

\IRule{REW7}{ \b{\rtranst{\b{\mt}}{\b{\mtp}}\e\x{\e}{\ep}} }{\rtranst{\b\mt}{\b\mtp}\e\x{\New\C{\b\e}}{\New\C{\b\ep}}}
\end{mathpar}

\vspace{-2mm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hrulefill
\caption{Behavioral dynamic expression translation.}\label{behtrans}
\end{figure}

\begin{figure}[!ht]
\hrulefill 
\footnotesize

\vspace{4mm}
%%%%%%%%%%%%%%%%%%%%%% WRAP %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\IGNOREUNLESSNEEDED{
\[\begin{array}{@{}ll@{}l@{}r@{~}c@{~}r}
    \wrap\C{\b\md}\bmt\bmtp\D = \\
\SP \class ~\D ~ \{\\
\SPP \Fdef\that\C \\
\SPP \Mdefz\f{\tp}{~\BehCast\tp{\Get{\Get\this\that}\f}~}
&    \All \f \Mtype\f{}\t\in\bmt &\wedge& \Mtype\f{}\tp \in \bmtp
\\
\SPP \Mdef\f\x\tp\tp {~\BehCast\tp{\Set{\Get\this\that}\f{\BehCast\t\x}}~}
&    \All \f \Mtype\f\t\t \in \bmt &\wedge& \Mtype\f\tp\tp \in \bmtp
\\
\SPP \Mdef\m\x\t\tp {~\BehCast\tp{{\ep}}~}
&     \All \m \Mdef\m\x\Cp\Cpp\e\in\b\md &\wedge& \Mtype\m\t\tp\in\bmtp \\
&&&&\wedge&\rtranst{\bmt}\bmtp{(\BehCast\Cp\x)}\x{\e}{\ep}
\\
\SPP \Mdef\m\x\any\any {~\SubCast\any{\Call\this\m{\BehCast{\t}\x}}~}
&     \All \m \Mdef\m\x\Cp\Cpp\e\in\b\md &\wedge& \Mtype\m\t\tp\in\bmtp\\
&&&&\wedge&\Mdef\m\x\any\any{\e'}\not\in\b\md
\\
\SPP \Mdef\m\x\t\tp{~\BehCast\tp{\ep}~}
&     \All \m \Mdef\m\x\any\any\e\in\b\md &\wedge& \Mtype\m\t\tp\in\bmtp \\
&&&&\wedge&\rtranst{\bmt}\bmtp{(\BehCast\any\x)}\x\e{\ep}
\\
\SPP \Mdefz\f\t { ~\Get{\Get\this\that}\f~}
&    \All \f \Mtype\f{}\t \in \bmt &\wedge& \Mtype\f{}\tp \not\in \bmtp
\\
\SPP \Mdef\f\x\t\t { ~\Set{\Get\this\that}\f\x~}
&    \All \f \Mtype\f\t\t \in \bmt&\wedge& \Mtype\f\tp\tp \not\in \bmtp
\\
\SPP \Mdef\m\x{\Cp}{\Cpp} {~\ep~}
&    \All \m  \Mdef\m\x\Cp\Cpp\e\in\b\md &\wedge& \Mtype\m\t\tp\not\in \bmtp \\
&&&&\wedge&\rtranst{\bmt}\bmtp\x\x{\e}{\ep}
\\
\SPP \Mdef\m\x\any\any {~\ep~}
&    \All \m  \Mdef\m\x\any\any\e\in\b\md  &\wedge& \Mtype\m\t\tp\not\in\bmtp \\
&&&&\wedge&\rtranst{\bmt}\bmtp\x\x{\e}{\ep}
\\
\SP \}
\\
\wrapAny\C\bmd\bmt\D = \\
\SP \class~\D~\{\\
\SPP \Fdef \that \C\\ 
\SPP   \Mdefz\f\any{~\BehCast\any{\Get{{\Get\this\that}}\f}~}
&  \All \m  \Mtype\f{}\t \in \bmt\\
\SPP   \Mdef\f\x\any\any{~\BehCast\any{\Set{\Get\this\that}\f{\BehCast\t\x}}~}
&  \All \f  \Mtype\f\t\t \in \bmt\\
\SPP   \Mdef\m\x\any\any {~\BehCast\any{{\ep}}~}
&  \All \m \Mdef\m\x\t\t\e\in\b\md  &\wedge& \rtranst{\bmt}{\dyn{\bmt}}{(\BehCast\t\x)}\x{\e}{\ep}\\
\SP \}\\
\end{array}\]
%}%%END IGNORE
%   \includegraphics[width=.9\textwidth]{figures/wrapDefinition}
% TODO: untyped(mt)
\hrulefill
%%%%%%%%%%%%%%%%%%%%%%%%%% WRAP %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \caption{Wrapper class generation.}\label{wrap}
\end{figure}

Multiple wrappers can be layered on top of a target object. Each time a
reference crosses a boundary between typed and untyped code, it will accrue
an additional wrapper. When a method is invoked on a wrapper chair, that
method will be invoked on every wrapper, until finding its way to the target
object. A key property of the wrapper generation functions of \figref{wrap}
is that methods should not be ``lost''. That is to say, any method in the
target object, even if it is not in the type it is being cast to, will be
retained in the wrapper.  This property is somewhat unconventional, and its
need is illustrated in \figref{ctod}. Class \C and \D are preexisting.  They
are not related by subtyping as \any is not a supertype of \E. The first
cast from \C to \D, results in the generation of class \EMxt{CtoD}. The
wrapper class is a subtype of \D but it also has method \mp only found in
class \C.  The cast from \EMxt{CtoD} back to \C leads to the generation of
wrapper class \EMxt{CtoDtoC}. The latter is a subtype of \C and has a rather
interesting method \m which is dynamic and thus must be invoked dynamically.
The receiver is cast to \any using a subtype cast. The argument on the other
hand is converted to dynamic with a behavioral cast. The return value is
converted to the expected return type with another behavioral cast.


%%%%%%%%%%%%%%%%% EXAMPLE  <C><D>new C %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}
\footnotesize
\begin{tabular}{ll}\begin{minipage}{6cm}
\[\begin{array}{l}
\class ~\C~ \{\\
\SP  \Mdef\m\e\x\E\x\\
\SP  \Mdef\mp\e\x\E\x\\
\}\\[2mm]
\class ~\EMxt{CtoD}~ \{\\
\SP  \Fdef\that\C\\
\SP  \Mdef \m\x\any\any{\Call{\Get\this\that}\m{\BehCast\E\x}}\\
\SP  \Mdef \mp\e\x\E{\Call{\Get\this\that}\mp\x}\\
\}\\
\end{array}\]
\end{minipage}
&
\begin{minipage}{5cm}
\[\begin{array}{l}
\class ~\D~ \{\\
\SP  \Mdef\m\x\any\any\x\\
\}
\\
\\[2mm]
\class ~\EMxt{CtoDtoC}~ \{\\
\SP  \Fdef\that{\EMxt{CtoD}}\\
\SP  \Mdef\m\e\x\E{ \BehCast\E{\DynCall{(\SubCast\any{\Get\this\that})}\m{\BehCast\any\x}}}\\
\SP  \Mdef\mp\e\x\E{ \Call{\Get\this\that}\mp{\x}}\\
\}\\
\end{array}\]
\end{minipage}
\end{tabular}
\caption{Classes generated by \BehCast\C{(\BehCast\D{\New\C{}})}.}
\label{ctod}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsubsection{Monotone Casts}


The monotone cast \MonCast\C\a imposes the type \C onto the object
at \a, as well as every object transitively reachable from it. The motivation 
for this cast comes from~\cite{Siek2015}, where it is used to maintain the
type correctness of every reference in the program.

\begin{figure}[h!]
\begin{tabular}{ll}
\begin{minipage}[b]{4cm}
\vspace{1em}\lstset{framesep=4pt}
\begin{lstlisting}
class C { f : * }
class D { 
  m (x:*):* {x}
}
d:* = new D()
a:* = new C(d)
\end{lstlisting}
\end{minipage}
&
\begin{tikzpicture}[framed,my shape/.style={
rectangle split, rectangle split parts=#1, draw, anchor=text east}]
\node (ref) at (0,0) {$\HT\a\any$};
\node (refb) at (0,-1.5) {$\HT{\xt{d}}\any$};

\node (C1) [my shape=2,right of=ref, anchor = text west]
{\C\nodepart{two}$\f : \any$};

\node (D1) [my shape=2,right=of C1.two east, anchor=text west,shift={(0,-.1)}]
{\D\nodepart{two}$\Mtype\m\any\any$};

\draw[->,very thick] (ref.east) -> (C1.text west);
\draw[->,very thick] (refb.east) -> ($(D1.text west)+(0,-.1)$);
\draw[->,very thick] (C1.two east) -> ($(D1.text west)+(0,.1)$);
\end{tikzpicture}
\end{tabular}
\end{figure}

The monotone cast is generative, as it triggers the creation of new classes
that are the meet of the existing types and the requested type. Generativity
is required when objects are aliased at different types.  This cast also
perform update in place of the class of objects, for example \obj\C{\a}
becomes \obj\D{\a}. To deal correctly with fields, we restrict monotone
casts to wrapper objects.


In the extreme, one cast could cause all objects in the heap to be
retyped. To prevent pathological cases, monotone casts, only modify the heap
if the target \C has fewer occurences of \any than the original type of the
object at \a (and transitively so for types appearing in \t and reachable
from \a).  When a type \C does not have any occurence of the dynamic type,
denoted by \statictype\C\K\V, monotone casts will leave the object and the
heap unchanged.

The key challenge is that after a monotone
cast in a heap \s, every reference should still be valid.  If a reference
has a type other than \any, then the cast will preserve correctness of that
reference. To accomplish this, the cast ensure two properties hold:
\begin{itemize}
\item The values that \emph{currently} exist cannot violate any of the types
  that point to them. Casting needs to recursively ensure that all values
  referred to by the current object are of the claimed type.
\item Functions can not be called with or return values that violate any of
  the types that they are referred to with. The behaviour of the class needs
  to check that its types are not violated by lesser-typed call sites.
\end{itemize}
The second property is strongly reminisicent of the behavioural semantics,
though with the interesting caveat that we now need to make sure that
\emph{all} method invocations follow the typed calling conventions, rather
than just the ones that inherit this particular type assertion.


Meta-variable \S denotes a map from addresses to classes, thus
\Map\S{\Bind\a\C} gives type \C to address \a. The function \htype\a\S\s\K
returns the class of the object at address \a.  \htype\a\S\s\K is \C if \C =
\App\S\a or if $\a\not\in\S$ and \obj\C{\b\a}=\App\s\a.


The monotone cast function \moncast\a\t\s\K\Kp\sp takes the address of the
cast target \a, a target type \t, the current heap \s and class table \K, and
will return an update heap \sp and an updated class table \Kp.

We use \Dom\S to get a sequence of addresses that have to be retyped.

\begin{mathpar}
\IRule{CM}{
  \retype \a\t\cdot\s\K = \S\,\Kp\\
  \spec {\Dom\S} \S\s\Kp = \sp~\Kpp
}{
  \moncast \a\t\s\K \Kpp \sp\\
}
\end{mathpar}


We write \t\EQ\tp to denote that both \StrSub{}\K\t\tp and
\StrSub{}\K\tp\t hold.

The retype function \retype{\b\a}{\b\t}\S\s\K, take a list of object
addresses \b\a and a list of types to ascribe to them \b\t, and updates the
heap \s and class table \K.

% TODO: Gettype from mtype

\begin{mathpar}
\IRule{CRM1}{
%   \unwrap{\htype \a\S\s}{\K} = \C~\Kp\\
  \htype \a\S\s\K = \C~\Kp\\
  \tmeet\C\t\cdot\Kp = \D\,\Kpp\\ 
  \C\not\EQ\D  \\
  \ftypes \a\D \s\Kpp = \b\ap~\b\tp \\
  \Sp = \Map\S{\Bind\a\D } \\
  \retype{\b\ap}{\b\tp}\Sp\s\K = \Spp\,\K'''
}{
  \retype \a\t\S\s\K = \Spp\,\K'''
}

\IRule{CRM2}{
%   \unwrap{\htype \a\S\s}{\K} = \tp\,\Kp\\
%   \tmeet\tp\t\cdot\Kp = \tpp\,\Kpp \\
  \htype \a\S\s\K = \tp\,\Kp\\
  \tmeet\tp\t\cdot\Kp = \tpp\,\Kp \\
  \tp\EQ\tpp \\
}{
  \retype \a\t\S\s\K = \S~\Kpp
}

\IRule{CRM3}{
  \retype\a\t\S\s\K = \Sp\,\Kp\\
  \retype{\b\a}{\b\t}\Sp\s\Kp = \Spp\,\Kpp
}{
  \retype {\a\,\b\a}{\t\,\b\t}\S\s\K = \Spp\,\Kpp
}
\end{mathpar}

The heap specialization function \spec{\b\a}\S\s\K takes a
sequence of object addresses \b\a, a heap typing \S, a heap \s
and a class table \K and returns a new heap where the objects
have been retyped.

\begin{mathpar}
\IRule{CMS1}{
  \E \text{ fresh}\\
  \D = \App\S\a \\
  \obj\C{\ap} = \App\s\a \\
  \obj\Cp{\b\app} = \App\s\ap \\
  \classoff\Cp\Kpp = \b\mt \\
  \classoff\D\Kpp = \b\mtp \\  
  \names{\b\mtp} \subseteq \names{\b\mt}\\
  \Kp = \K~\classgen{\Cp,\b\mt,\b\mtp,\E,\K} \\
  \sp = \Map\s{\Bind\a{\E\{\ap\}}}
}{
  \spec \a\S\s\K = \sp~\Kp
}

\IRule{CMS2}{
  \spec \a\S\s\K = \sp\\
  \spec {\b\a}\S\sp\K =\spp
}{
   \spec {\a\,\b\a}\S\s\K = \spp
}
\end{mathpar}


% The \texttt{typemeet} function \tmeet\P\K\t\tp compute the meet of types \t
% and \tp, it returns a new type if needed and an updated class table.
% 
% For the case we call \tmeet\P\K\C\D, the function will have to create a new
% class \E that is the result of meeting \C with \D.

The \texttt{tmeet} function takes four arguments, the original type
$\t$, the cast type $\tp$, an environment $\P$, a class table $\K$, and
outputs a type $\tpp$ and a class table $\Kp$. The environment $\P$ is a set
of mappings from a pair of types ($\t,\tp$) to a type $\tpp$. 

In effect, \texttt{tmeet} takes the place of the $\sqcap$ operator in~\cite{Siek2015},
fufilling the same purpose. In short, the \texttt{tmeet} operator takes two types
and finds a third type that retains all of the type assertions in the two input types.

For example, consider figure~\ref{fig:tmeet_ex}, where we compute the meet of two types,
both of which have the same function, but alternate the typing for that function, where
\texttt{A} has the return type typed, whereas \texttt{B} has the argument typed. \texttt{tmeet}
will compute the result type as a new \texttt{C}, where both the argument and return type 
are typed.

\begin{figure}[!ht]
\begin{tabular}{r@{\hspace{1mm}}l@{}l@{}l@{}l@{\hspace{1.5mm}}l@{\hspace{1mm}}l@{}l}
\texttt{tmeet(}
& \texttt{A}
  & \texttt{,}
  \texttt{B}
  & \texttt{,}
  $\cdot$
  & \texttt{,}
  &
  \begin{minipage}{4.3cm}
    \begin{lstlisting}
class A {
   m(x: *): A {this}}

class B {
   m(x: B): * {this}}
      \end{lstlisting}    
  \end{minipage}
& 
\texttt{) = C,}
  &
  \begin{minipage}{4.3cm}
    \begin{lstlisting}
class A { ... }
class B { ... }
class C {
  m(x: B): A {this}
}
    \end{lstlisting}    
  \end{minipage}
\end{tabular}
\caption{Simple example of \texttt{tmeet} use}
\label{fig:tmeet_ex}
\end{figure}

This example uses 3 of \texttt{tmeet}'s 4 arugments, with an empty \P, first invoking \RuleRef{TM4},
which, via \xt{mmeet}, computes the meet of each of the arguments to \xt{m}, invoking \RuleRef{TM1}
and \RuleRef{TM2} for the argument and return type of \xt{m}.

\begin{figure}[!ht]
\begin{tabular}{r@{\hspace{1mm}}l@{}l@{}l@{}l@{\hspace{1.5mm}}l@{\hspace{1mm}}l@{}l}
\texttt{tmeet(}
& \texttt{A}
  & \texttt{,}
  \texttt{B}
  & \texttt{,}
  $\cdot$
  & \texttt{,}
  &
  \begin{minipage}{4.3cm}
    \begin{lstlisting}
class A {
   m(x: A): * {this}}

class B {
   m(x: B): * {this}}
      \end{lstlisting}    
  \end{minipage}
& 
\texttt{) = E,}
  &
  \begin{minipage}{4.3cm}
    \begin{lstlisting}
class A { ... }
class B { ... }
class E {
  m(x: E): * {this}
}
    \end{lstlisting}    
  \end{minipage}
\end{tabular}
\caption{\texttt{tmeet} over recursive classes}
\label{fig:tmeet_rec_ex}
\end{figure}

The third argument, \P, becomes important when we consider programs like the one in example~\ref{fig:tmeet_rec_ex}, where the meet 
of \xt{A} and \xt{B} recursively depends on the meet of \xt{A} and \xt{B}. If we proceeded naievely, without \P, \RuleRef{TM4} would
invoke \RuleRef{TM4} again to compute the meet of the arugments to \m. We use \P and \RuleRef{TM5} to avoid this.

\RuleRef{TM4} invokes \xt{mmeet} with an enriched \P, in much the same manner that the subtyping relation does, inserting the future
result of the meet of \xt{A} and \xt{B} (which, in this example, is \xt{E}) into \P, which will then be used by \RuleRef{TM5} to terminate
the recursion. We make a notable simplifcation in figure \ref{fig:tmeet_rec_ex}, however, where the covariant and contravariant cases of meet
produce the same result - our formal system instead generates different classes (which are identical to the \xt{E} in the figure) for each of 
these cases.

This last property comes out of a property of conistency. If we consider two types, $\C = \Type{\Mtype\m\any\any}$ and $\D = \Type{\Mtype\m\any\any, \Mtype\n\any\any}$, clearly $\D <: \C$ but not $\C <: \D$, and therefore, using the consistent subtyping relation from~\cite{SiekTaha07}, 
$\D \lesssim \C$ but not $\C \lesssim \D$. As a concequence, 

The \texttt{mtypes} function takes a class name $\C$ and the class table
$\K$, and outputs a list of typing signatures $\b\mt$ for every method in
class $\C$, which includes the implicit getter and setter methods for every
field in the definition of class $\C$.  (\textbf{Note}: An user cannot
define a getter or setter method for any field that already exists in the
class. Similarly, a field cannot be declared in a class that already has a
getter or setter method for that field. This is enforced by the
\texttt{overloading} function in class well-formedness.)

\begin{figure}[!ht]
\hrulefill

\opdef{
  $\tmeet{\t}{\tp}\P\K = \tpp\,\Kp$
}{
}
\begin{align*}
\P &::= \cdot \B \Map\P{\Bind{(\C,\D)}\Dp}
\end{align*}
\begin{mathpar}
\IRule{TM1}{ }{\tmeet\C\any\P\K = \C\,\K}

\IRule{TM2}{ }{\tmeet\any\C\P\K = \C\,\K}

\IRule{TM3}{ }{\tmeet\t\t\P\K = \t\,\K}

\IRule{TM4}{
  \fresh\E\\
  (\C,\D) \not\in\P \\
  \Pp = \Map\P{\Bind{(\C,\D)}\E} \\
  \mtypes\C\K = {\b\mt}\\
  \mtypes\D\K = {\b\mtp}\\
  \mmeet{\b\mt}{\b\mtp}\Pp\K = \b\mtpp\,\Kp\\
  \Kpp = \Kp~\typegen{\b\mtpp}\E\\
}{
    \tmeet\C\D\P\K = \E\,\Kpp
}

\IRule{TM5}{
    \P(\C,\D) = \E
}{
    \tmeet\C\D\P\K = \E\,\K
}
\end{mathpar}

\vspace{-2mm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hrulefill
\caption{Type meet.}\label{monmeet}
\end{figure}


The \texttt{methmeet} function is used by the \texttt{typemeet} functions to
perform the meet over the typing of each method within a class definition.
The \texttt{methmeet} function also takes four arguments, the method
signatures of the original class $\b\mt$, the method signatures of the cast
class $\b\mtp$, the environment $\P$, a class table $\K$, and outputs method
types $\b\mtpp$ and a class table $\Kp$. The \texttt{MM2} rule operators
over the method typing signature of field setter, field getter, and regular
method.

The function \ftypes\a\C\s\K returns the old references and the new types
for them according to the new wrapper \C.

\newcommand{\rtranstz}[4]{#1 \Rightarrow #2 \vdash #3 \looparrowright_{mon} #4}

\begin{figure}[!ht]
\hrulefill
\begin{mathpar}
\IRule{MREW1}{ }{ \rtranstz{\b{\mt}}{\b{\mtp}}\x\x }
\\
\IRule[width=25em]{MREW2}{ 
  \Mtype\n{\b{\t_1}}{\tp_1} \in \b{\mt} \\ 
  \Mtype\n{\b{\t_2}}{\tp_2} \in \b{\mtp} \\ 
  \n = \f \vee \t_1 \neq \any  \\ 
  \b{\rtranstz{\b{\mt}}{\b{\mtp}}{\e}{\ep}}
}{
  \rtranstz{\b{\mt}}{\b{\mtp}}{\Call{\this}\n{\b\e}}{\MonCast{\tp_1}{\Call{\this}\n{\b{\MonCast{\t_2}{\ep}}}}}
}
\\

\IRule[width=20em]{MREW3}{ 
  \e_1 \neq \this \\ \rtranstz{\b{\mt}}{\b{\mtp}}{\e_1}{\e_2} \\ 
  \b{\rtranstz{\b{\mt}}{\b{\mtp}}{\ep_1}{\ep_2}}
}{
  \rtranstz{\b{\mt}}{\b{\mtp}}{\Call{\e_1}\n{\b{\ep_1}}}{\Call{\e_2}\n{\b{\ep_2}}}
}

\IRule{MREW4}{ 
  \rtranstz{\b{\mt}}{\b{\mtp}}{\e_1}{\e_2} \\ 	
  \rtranstz{\b{\mt}}{\b{\mtp}}{\ep_1}{\ep_2}
}{
  \rtranstz{\b{\mt}}{\b{\mtp}}{\DynCall{\e_1}\m{\ep_1}}{\DynCall{\e_2}\m{\ep_2}}
}

\IRule{MREW5}{
  \b{\rtranstz{\b{\mt}}{\b{\mtp}}{\e}{\ep}} 
}{
  \rtranstz{\b\mt}{\b\mtp}{\New\C{\b\e}}{\New\C{\b\ep}}
}
\end{mathpar}

\vspace{-2mm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hrulefill
\caption{Monotonic dynamic expression translation.}\label{montrans}
\end{figure}

% 
% \begin{figure}[!ht]
% \hrulefill 
% \footnotesize
% \vspace{4mm}
% \[\begin{array}{@{}ll@{}l@{}r@{~}c@{~}r}
%     \classgen{\C, \b\md, \bmt, \bmtp, \D} = \\
% \SP \class ~\D ~ \{\\
% \SPP \Fdef\that\C \\
% \SPP \Mdefz\f{\tp}{~\MonCast\tp{\Get{\Get\this\that}\f}~}
% &    \All \f \Mtype\f{}\t\in\bmt &\wedge& \Mtype\f{}\tp \in \bmtp
% \\
% \SPP \Mdef\f\x\tp\tp {~\MonCast\tp{\Set{\Get\this\that}\f{\MonCast\t\x}}~}
% &    \All \f \Mtype\f\t\t \in \bmt &\wedge& \Mtype\f\tp\tp \in \bmtp
% \\
% \SPP \Mdef\m\x\t\tp {~\MonCast\tp{{\ep}}~}
% &     \All \m \Mdef\m\x\Cp\Cpp\e\in\b\md &\wedge& \Mtype\m\t\tp\in\bmtp \\
% &&&&\wedge&\rtranstz{\bmt}\bmtp{(\MonCast\Cp\x)}\x{\e}{\ep}
% \\
% \SPP \Mdef\m\x\any\any {~\SubCast\any{\Call\this\m{\MonCast{\t}\x}}~}
% &     \All \m \Mdef\m\x\Cp\Cpp\e\in\b\md &\wedge& \Mtype\m\t\tp\in\bmtp\\
% &&&&\wedge&\Mdef\m\x\any\any{\e'}\not\in\b\md
% \\
% \SPP \Mdef\m\x\t\tp{~\MonCast\tp{\ep}~}
% &     \All \m \Mdef\m\x\any\any\e\in\b\md &\wedge& \Mtype\m\t\tp\in\bmtp \\
% &&&&\wedge&\rtranstz{\bmt}\bmtp{(\MonCast\any\x)}\x\e{\ep}
% \\
% % \SPP \Mdefz\f\t { ~\Get{\Get\this\that}\f~}
% % &    \All \f \Mtype\f{}\t \in \bmt &\wedge& \Mtype\f{}\tp \not\in \bmtp
% % \\
% % \SPP \Mdef\f\x\t\t { ~\Set{\Get\this\that}\f\x~}
% % &    \All \f \Mtype\f\t\t \in \bmt&\wedge& \Mtype\f\tp\tp \not\in \bmtp
% % \\
% % \SPP \Mdef\m\x{\Cp}{\Cpp} {~\ep~}
% % &    \All \m  \Mdef\m\x\Cp\Cpp\e\in\b\md &\wedge& \Mtype\m\t\tp\not\in \bmtp \\
% % &&&&\wedge&\rtranstz{\bmt}\bmtp\x\x{\e}{\ep}
% % \\
% % \SPP \Mdef\m\x\any\any {~\ep~}
% % &    \All \m  \Mdef\m\x\any\any\e\in\b\md  &\wedge& \Mtype\m\t\tp\not\in\bmtp \\
% % &&&&\wedge&\rtranstz{\bmt}\bmtp\x\x{\e}{\ep}
% % \\
% \SP \}\\
% \end{array}\]
% \hrulefill
% %%%%%%%%%%%%%%%%%%%%%%%%%% WRAP %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \caption{Monotonic class generation.}\label{classgen}
% \end{figure}
% 
% 
% \begin{figure}[!ht]
% \footnotesize
% %\IGNOREUNLESSNEEDED{
% \[\begin{array}{l@{~}r@{}r@{~}r@{~}r@{~}rr}
% \arrayrulecolor{white}
% \classgen{\C, \bmt, \bmtp, \D,\K}= \\
% % \SP \tikzmarkin[set fill color=gray!20!white, set border color=gray!20!white]{a}(3.65,-0.5)(0,0.25) 
% \class~\D~\{ \\
% \SPP \Fdef\that\C
% \\[1mm]
% \SPP \Mdef\m\x\any\any {\SubCast\any{\MonCast\tp{\Call{\Get\this\that}\m{\MonCast\Cp{\MonCast\t\x}}}}} 
% &
% \All m \Mtype\m\Cp\Cpp\in\bmt &\wedge& \Mtype\m\t\tp\in\bmtp
% \\[1mm]\hline
% \SPP \Mdef\m\x\any\any{
%   \SubCast\any{\MonCast\tp{\DynCall{(\SubCast\any{\,\Get\this\that})}\m{\SubCast\any{\MonCast\t\x}}}}} 
% &
% \All m \Mtype\m\any\any\in\bmt &\wedge& \Mtype\m\t\tp\in\bmtp
% \\[1mm]\hline
% \SPP \Mdef\f\x\any\any {\SubCast\any{\MonCast\tp{
%       \Set{\Get\this\that}\f{\MonCast\t{\MonCast\tp\x}}}}}
% &
% \All f \Mtype\f\t\t\in\bmt &\wedge& \Mtype\f\tp\tp\in\bmtp
% \\[1mm]\hline
% \SPP \Mdefz\f\any{\SubCast\any{\MonCast\tp{\Get{\Get\this\that}\f}}}
% &
%  \All f \Mtype\f{}\t \in \bmt &\wedge& \Mtype\f{}\tp \in \bmtp \\
% % \\[1mm]\hline
% % \SPP \Mdefz\f\any{\SubCast\any{\MonCast\t{\Get{\Get\this\that}\f}}}
% % &
% %  \All f \Mtype\f{}\t \in \bmt &\wedge& \Mtype\f{}\tp \not\in \bmtp 
% % \\[1mm]\hline
% % \SPP \Mdef\f\x\any\any {\SubCast\any{\MonCast\t{\Call{\Get\this\that}\f{\SubCast\any{\MonCast\t\x}}}}}
% % & \All f \Mtype\f\t\t\in\bmt &\wedge& \Mtype\f\tp\tp\not\in\bmtp 
% % \\[1mm]\hline
% % \SPP \Mdef\m\x\any\any { \SubCast\any{{\Call{\Get\this\that}\m{\SubCast\any\x}}}}
% % &
% % \All m \Mtype\m\any\any\in\bmt &\wedge& \Mtype\m\t\tp\not\in \bmtp 
% % \\[1mm]\hline
% % \SPP \Mdef\m\x\any\any{ \DynCall{(\SubCast\any{\Get\this\that})}\m{\SubCast\any\x}}
% % &
% % \All m \Mtype\m\any\any\in\bmt &\wedge& \Mtype\m\t\tp \not\in\bmtp
% % \\[1mm]\hline
% % \SPP \Mdef\m\x\t\tp{ \MonCast\tp{\Call{\Get\this\that}\m{{\MonCast\Cp\x}}}}
% % &
% %  \All m \Mtype\m\Cp\Cpp \in\bmt &\wedge& \Mtype\m\t\tp\in\bmtp \\
% %  \\[1mm]\hline
% % \SPP \Mdef\m\x\Cp\Cpp { \Call{\Get\this\that}\m\x} \tikzmarkend{a}
% % &
% %  \All m \Mtype\m\Cp\Cpp \in\bmt &\wedge& \Mtype\m\t\tp \not\in \bmtp \\
% \SP\}
% \end{array}
% \]
% %} 
% %\includegraphics[width=1\textwidth]{figures/classgenDefinition}
% \caption{Class generation.}\label{classgen}
% \end{figure}


\begin{figure}[!ht]
\hrulefill
\footnotesize
%\IGNOREUNLESSNEEDED{
\[\begin{array}{l@{~}r@{}r@{~}r@{~}r@{~}rr}
\arrayrulecolor{white}
\classgen{\C, \b\md, \bmt, \bmtp, \D, \K}= \\
\SP \class~\D~\{ \\
\SPP \Fdef\that\C
\\[1mm]
\SPP \Mdef\f\x\any\any {\SubCast\any{\MonCast\tp{
      \Set{\Get\this\that}\f{\MonCast\t{\MonCast\tp\x}}}}}
&
\All f \Mtype\f\t\t\in\bmt &\wedge& \Mtype\f\tp\tp\in\bmtp
\\[1mm]\hline
\SPP \Mdefz\f\any{\SubCast\any{\MonCast\tp{\Get{\Get\this\that}\f}}}
&
 \All f \Mtype\f{}\t \in \bmt &\wedge& \Mtype\f{}\tp \in \bmtp
\\[1mm]\hline
\SPP \Mdef\m\x\any\any {~\SubCast\any{\MonCast\tp{{[{(\MonCast\t\x)}/\x]\ep}}}~}
&     \All \m \Mdef\m\x\t\tp\e\in\b\md &\wedge& \Mtype\m\t\tp\in\bmtp \\
&&&&\wedge&\rtranstz{\bmt}\bmtp{[{(\MonCast\t\x)}/\x]\e}{\ep}
\\[1mm]\hline
\SPP \Mdef\m\x\t\tp {\ep~}
&     \All \m \Mdef\m\x\t\tp{\e}\in\b\md &\wedge& \Mtype\m\t\tp\in\bmtp \\
&&&&\wedge&\rtranstz{\bmt}\bmtp{\e}{\ep} \\
&&&&\wedge&\statictype{\C}{\K}{\cdot}
\\[1mm]\hline
\SP\}
\end{array}
\]
%} 
\hrulefill
\caption{Monotonic class generation.}\label{classgen}
\end{figure}

\begin{figure}
\hrulefill
\footnotesize
\vspace{4mm}
\[\begin{array}{l@{~}r@{}r@{~}r@{~}r@{~}rr}
\arrayrulecolor{white}
\typegen{\bmt}{\D} = \\
\SP \class~\D~\{
\\[1mm]
\SPP \Mdef\m\x\t\tp {{\MonCast\tp{\x}}} 
&
\All m \Mtype\m\t\tp\in\bmt
\\[1mm]\hline
\SPP \Mdef\f\x\t\t {\x}
&
\All f \Mtype\f\t\t\in\bmt
\\[1mm]\hline
\SPP \Mdefz\f\t{{\MonCast\t{\New\D{}}}}
&
 \All f \Mtype\f{}\t \in \bmt
\\[1mm]
\SP\}
\end{array}
\]
\hrulefill
\caption{Equivalent Type Generation} \label{typegen}
\end{figure}


\section{Translations}

\kafka provides us with a basis through which we can describe the operation
of more typical languages. \kafka requires that the programmer write casts
wherever a type boundary is encountered, which is not representative of how
actual gradually typed programming languages behave. Most gradually typed
programming languages abstract away from the actual casts that are inserted,
automatically inserting them and using them at runtime, invisibly to the
programmer up until it produces an error.

To represent this, we introduce a \emph{translation} mechanism, that performs much the same duty that this step does. This step works very similarly to how Siek and Taha~\cite{SiekTaha06} described cast insertion, though, thanks to our more complex source and target languages, we cannot entirely use the simple, bottom-up approach that Siek and Taha did.

Instead, we use a \emph{bidirectional} translation mechanism, based on the work originally done by Pierce and Turner~\cite{lti-pierce}. Bidirectional typechecking is, in effect, a local type inference mechanism, and allows us to cleanly identify cast insertion locations in a modular way.


\subsection{Typed Racket}

Typed Racket, in and of itself, is not a gradually typed language, as the Typed Racket language allows no untyped code. Its gradual nature, instead, comes from Typed Racket's interactions with (untyped) Racket, where a Typed Racket module can interact with a Racket one. As a result, when we refer to Typed Racket here, we refer to the combination of both Typed Racket and Racket. Moreover, this separation means that Typed Racket programs are typed on a module by module basis, rather than an expression by expression one.

Since we are largely unconcerned about the details of surface syntax, and want to highlight the interesting semantic details of all behavioural approaches independent of the surface language, our surface level translation will still allow programmers to write partially typed classes, unlike the actual Typed Racket language, where a single class cannot be both typed and untyped simultaneously.

We begin with Typed Racket as its surface to \kafka translation is the most straightforward. At the top level, we translate the classes, where source language terms are denoted with an underscore, to \kafka classes, then translate the source language main expression to one in \kafka, producing some return type we do not know, seen in rule PT.

The other rule of note is MT. In MT, we know that the method body must be of the form 

\begin{mathpar}
\IRule{PT}{
  {\classtrans{\K}{\K}{\K'}} \\ \GenCast{\K}{\cdot}{\e}{\ep}{\t} 
}{\progtrans{\e~\K}{\e'~{\K'}}}

\IRule{CR1}{ 
  \b{\methtrans {\K}{\C}{\md}{\md'}{}} \\
  \classtrans {\K}{\Kp}\Kpp
}{
   \classtrans {\K}{{\Class \C{\b{\Ftype\f\t}}{\b\md}~\Kp}}{\Class \C {\b{\Ftype\f\t}}{\b{\md'}}~\Kpp}}

\IRule{CR2}{ 
}{
  \classtrans {\K}\cdot\cdot
}

\IRule{MT}{
  \AnaCast {\K}{\HT\this{\C}~\HT\x{\t}}{\e}\ep{\tp}
}{
  \methtrans {\K}{\C}{\Mdef\m\x{\t}{\tp}{\e}}{\Mdef\m\x\t\tp\ep}{}
}
\end{mathpar}


\begin{mathpar}
\IRule{TRA1}{\HasType{\Env}\x\t}{\GenCast{\K}\Env\x\x\t}

\IRule[width=30em]{TRA2}{
    \GenCast\K\Env{\e_1}{\e_3}{\C} \\ \n(\b{\t_1}):\t_2 \in \classoff\C\K \\ \b{\AnaCast\K\Env{\e_2}{\e_4}{\t_1}}
}{
    \GenCast\K\Env{\Call{\e_1}\n{\b{\e_2}}}{\Call{\e_3}\n{\b{\e_4}}}{\t_2}
}

\IRule{TRA3}{
    \GenCast\K\Env{\e_1}{\e_3}{\any} \\ {\AnaCast\K\Env{\e_2}{\e_4}{\any}}
}{
    \GenCast\K\Env{\Call{\e_1}\m{{\e_2}}}{\DynCall{\e_3}\m{{\e_4}}}{\any}
}

\IRule{TRA4}{
  \b{\AnaCast{\K}\Env{\e_1}{\e_2}\t} \\ 
  \Class \C {\b{\Ftype\f\t}} {\b{\md}}
  }{\GenCast\K\Env{\New\C{\b{\e_1}}}{\New\C{\b{\e_2}}}{\C}}
\end{mathpar}

Our translation to KafKa from this basis is then relatively simple. Translation with the bidirectional system proceeds in the typical manner through all of the synthetic cases, and the analytic cases are typical, as well.

\begin{mathpar}
\IRule{TRAASC1}{
  \GenCast\K\Env\e\ep\tp \\
  \K \vdash \tp \Sub \t
}{
  \AnaCast\K\Env\e\ep\t
}

\IRule{TRAASC2}{
  \GenCast\K\Env\e\ep\tp
}{
  \AnaCast\K\Env\e{\BehCast\t{\ShaCast\t\ep}}\t
}
\end{mathpar}

The only rule of real note in our Typed Racket translation to \kafka is TRAASC2. Here, we see that if the Typed Racket translation ever enconters a non-subtype, then it will insert both a behavioural and name cast around the potentially ill-typed target, under every circumstance.

We do this as Typed Racket only does runtime checking on the nature of the values that pass in from Racket, and therefore, even nonsensical types can be asserted for untyped code, discovered on use. We represent this via the aggressive wrapping in TRAASC2, where a type can be of any other type.

Lastly, TRAASC2 will insert both a behavioural and shape cast, of which the formers purpose is obvious, but the latter of which less so. We insert the shape cast as our behavioural cast is very weak, passing virtually every object through it in a wrapper, even if the object underneath diverges from the type asserted by, for example, missing methods. To compensate for this, we also add the shape cast, which ensures that all of the required methods are present.

\subsection{Thorn}

Thorn adds an ``unsound'' type $\dt\C$ to its type system, which has its own subtyping relation, and compiles down to \any in \kafka. This unsound type still enforces the same static requirements as its sound counterpart, but generates no runtime casts and therefore has low overhead.

\newcommand{\bC}{\xt{!C}}

\begin{tabular}{l@{~~}l@{}l@{}l}
\t  &::= ~ \any \B \C \B \dt\C \\ 
\end{tabular}

Over this new type, we define a subtyping relation, $\t \Sub_t \t$ as follows:

\newcommand{\ThorSub}[4]{\EM{#1~#2 \vdash #3 \Sub_t #4}}
\opdef{\ThorSub\M\K\t\tp}{\t is a subtype of \tp}
\begin{mathpar}
\IRule{THSWeak}{\ThorSub \M\K\C\D}{\ThorSub\M\K{\dt\C}{\dt\D}}

\IRule{THSLower}{\ThorSub \M\K\C\D}{\ThorSub\M\K{\C}{\dt\D}}
\end{mathpar}

The remainder of the subtyping judgment is identical to the \kafka subtyping relation, which can be seen in the appendix. With this, we can define the synthetic and analytic cases of cast insertion for Thorn.

\newcommand{\ba}{\xt{!}}

\begin{mathpar}
\IRule{THA1}{
  \HasType\Env\x\t
}{
  \GenCast\K\Env\x\x\t
}

\IRule[width=30em]{THA2}{
    \GenCast\K\Env{\e_1}{\e_3}\C \\ 
    \src{\n(\b{\t_1}):\t_2 \in \classoff\C\K} \\ 
    \b{\AnaCast\K\Env{\e_2}{\e_4}{\t_1}}
}{
    \GenCast\K\Env{\Call{\e_1}\n{\b{\e_2}}}{\Call{\e_3}\n{\b{\e_4}}}{\t_2}
}

\IRule{THA3}{
    \GenCast\K\Env{\e_1}{\e_3}{\dt\C} \\ 
    \src{\m({\t_1}):\D \in \classoff\C\K} \\ 
    \AnaCast\K\Env{\e_2}{\e_4}{\t_1}
}{
    \GenCast\K\Env{\Call{\e_1}\m{{\e_2}}}{\SubCast\D{\DynCall{\e_3}\m{{\e_4}}}}{\D} %Q: do I need to cast the return value of non-bang
}

\IRule{THA4}{
    \GenCast\K\Env{\e_1}{\e_3}{\dt\C} \\ 
    \m({\t_1}):\t \in \classoff\C\K \\ 
    \t \neq \D \\
    \AnaCast\K\Env{\e_2}{\e_4}{\t_1} 
}{
    \GenCast\K\Env{\Call{\e_1}\m{{\e_2}}}{\DynCall{\e_3}\m{{\e_4}}}{\t}
    %Q: do I need to cast the return value of non-bang
}

\IRule{THA5}{
    \GenCast\K\Env{\e_1}{\e_3}\any \\ 
    \AnaCast\K\Env{\e_2}{\e_4}\any
}{
    \GenCast\K\Env{\Call{\e_1}\m{{\e_2}}}{\DynCall{\e_3}\m{{\e_4}}}\any
}

\IRule{THA6}{
  \b{\AnaCast\K\Env{\e_1}{\e_2}\t} \\ 
  \Class \C {\b{\Ftype\f\t}} {\b\md}
  }{
  \GenCast\K\Env{\New\C{\b{\e_1}}}{\New\C{\b{\e_2}}}\C
}
\end{mathpar}

The synthetic cases are effectively, as the name implies, the traditional ``bottom-up'' style of typing judgment. Here, we are asked to produce te type for a term while producing an equivalent \kafka term that is of the translated type. As a result, a number of the rules, including THA1, THA2, THA5, and THA6 are all effectively direct translations of the traditional typing rules for their cases.

However, THA3 and THA4 are of special interest. Both apply when the receiver type is a weak type - that is, unsound, so its types are not guaranteed - and case analyze on the declared return type. In THA3, we see the case where the returnn type is a concrete type, or a sound type, being returned from an unsound type, which requires the insertion of a runtime cast, and in THA4 we see the the alternative case.

At the same time, note that both THA3 and THA4 produce dynamic calls on the receiver, despite the receiver having a source language type. This is because we translate Thorn weak types down to \kafka's \any, which causes all calls on optional types to be considered by \kafka to be dynamic invocations.

\hrulefill

\begin{mathpar}
\IRule{THAASC1}{
  \GenCast\K\Env{\e_1}{\e_2}{\C_2} \\
  \src{\ThorSub\K\cdot{\C_2}{\C_1}}\\
}{
  \AnaCast\K\Env{\e_1}{\e_2}{\C_1}
}

\IRule{THAASC2}{
  \GenCast\K\Env{\e_1}{\e_2}{\dt\D} \\ 
  \src{\ThorSub\K\cdot\D\C}
}{
  \AnaCast\K\Env{\e_1}{\SubCast{\C}{\e_2}}{\C}
}

\IRule{THAASC3}{
  \GenCast\K\Env{\e_1}{\e_2}{\any} \\
}{
  \AnaCast\K\Env{\e_1}{\SubCast{\C}{\e_2}}{\C}
}

\IRule{THAASC4}{
  \GenCast\K\Env{\e_1}{\e_2}{\any} \\
}{
  \AnaCast\K\Env{\e_1}{\e_2}{\dt\C}
}

\IRule{THAASC5}{
  \GenCast\K\Env{\e_1}{\e_2}{\t} \\ \t \neq \any
}{
  \AnaCast\K\Env{\e_1}{\e_2}{\any}
}
\end{mathpar}

\subsection{Reticulated Python}

Reticulated Python is somewhat more complicated, as it implements three different semantics, though not simultaneously. As a result, we will show translations for each of its three semantics options.

The most notable difference between Reticulated and the other systems at the surface level is the use of \emph{consistency}, an operator broadly meaning that one type is compatible with another type. In our system, we define conistency as follows:
\newcommand{\consistent}[3]{#1 \vdash #2 ~\sim~ #3}
\begin{mathpar}
\IRule{C1}{\tmeet\t\tp\cdot\K = \tpp}{\consistent\K{\t}{\tp}}
\end{mathpar}

In effect, if there is some most specific type for two given types, then the two types are consistent - it is possible that a value of one could be converted into the other with a runtime cast.

\paragraph{Transient}

The transient semantics is notably different from the other systems, as illustrated by the invariants we can assume about its primary cast, $\ShaCast\t\e$. Here, we simply assert that $\e$ has the same \emph{names} as $\t$ does, and, as a result, the closest type representation we have is the $\any$ type, as illustrated in the typing for \kafka. All Transient guarantees is that the methods on the named type will be callable with some argument, and some return value, and it is up to the callee to check that the arguments are right and up to the caller to ensure that the return value is right.

Because of fields, we cannot fully represent the transient semantics in \kafka, as field accessors and getters can only be called in a fully typed context. However, we can approximate it, by only allowing field getters and setters to be called in the context of \this, thereby removing all possible ambiguity over the receiver of the field getter or setter.


\begin{mathpar}
\IRule{MTU}{
  \AnaCast{\K}{\HT\x\any}{\e}{\ep}{\any}
}{\methtrans\K\C{\Mdef\m\x\any\any\e}{\Mdef\m\x\any\any\ep}{}}

\IRule{MTT}{
  \t \neq \any \\
  \AnaCast{\K}{\HT\x\t}{\e}{\ep}{\tp}
}{\methtrans\K\C{\Mdef\m\x\t\tp\e}{\Mdef\m\x\any\any{\SubCast{\any}{\New{\EMxt{A2}}{\ShaCast\t\x, \e}.{\EMxt{f2}}()}}}{}}
\end{mathpar}

The first task for us to do in transient is to define a mechanism for calls to self-protect. The transient semantics provides no type guarantees about the arguments to functions, which must check their own arguments when called. However, \kafka does not allow us to call typed functions with arguments of unknown type, meaning that we have to take a translation approach on a per-method basis.

Our translation for untyped methods is very simple, as they make no type-based assumptions internally, as seen in MTU. However, in MTT, we see the considerably more complex typed method translation. As this method must be callable with any argument, the argument type of the untyped function must be \any, then translate the body of the method to account for the altered argument type.

As seen in the expression translation below, we cast every variable to the statically expected type whenever it is seen in the program. However, this is insufficient, as if the method does not use its argument, then without further checking, it can succeed even if the argument value is ill-formed. Solving this problem is challenging, as \kafka does not allow us to write multiple line expressions. What \kafka does have, though, is the ability to write multiple expressions in a new statement with a guaranteed evaluation order, which is sufficient for our purposes. 

To check the type of the argument, we then create a new instance of the empty utility class \EMxt{A2}, which has two fields, \EMxt{f1} and \EMxt{f2}, then set \EMxt{f1} to the casted value of the argument \x. While this value is used nowhere else in the program, the program will get stuck at this cast if the value is not of the specified type, maintaining the required. We then instantiate \EMxt{f2} to the translated body of the function, then return the value of \EMxt{f2}, producing the expected result. 


\begin{mathpar}
\IRule{A1}{\HasType{\E}\x\t}{\GenCast{\K}\E\x{\ShaCast\t\x}\t}


\IRule[width=30em]{A2}{
    \GenCast\K\Env{\e_1}{\e_3}{\C} \\ \m(\b{\t_1}):\t_2 \in \classoff\C\K \\ \b{\AnaCast\K\Env{\e_2}{\e_4}{\t_1}}
}{
    \GenCast\K\Env{\Call{\e_1}\m{\b{\e_2}}}{\ShaCast{\t_2}{\Call{\e_3}\m{\b{\e_4}}}}     {\t_2}
}

\IRule{A8}{
    \GenCast\K\Env{\e_1}{\e_3}{\any} \\ {\AnaCast\K\Env{\e_2}{\e_4}{\any}}
}{
    \GenCast\K\Env{\Call{\e_1}\m{{\e_2}}}{\DynCall{\e_3}\m{{\e_4}}}{\any}
}

\IRule{A11}{
  \b{\AnaCast{\K}\E{\e_1}{\e_2}\t} \\ 
  \Class \C {\b{\Ftype\f\t}} {\b{\md}}
  }{\GenCast\K\Env{\New\C{\b{\e_1}}}{\New\C{\b{\e_2}}}{\C}}
\end{mathpar}

Transient expression translation contains only one real suprise, A3. Transient does not provide a sufficiently strong type invariant as to satisfy \kafka's field access typechecking, causing us to be unable to call a field setter or getter on any argument. As a concequence, we can only call fields on the self reference \this, which is handled as a special case as A3, since the combination of A1 and A2 is not sufficient to typecheck a field access due to the weakness of the type invariant.

\begin{mathpar}
\IRule{AASC1}{
  \GenCast\K\E\e\ep\tp \\
  \K \vdash \tp \Sub \t
}{
  \AnaCast\K\E\e\ep\t
}

\IRule{AASC2}{
  \GenCast\K\E\e\ep\tp \\
  \consistent\K\tp\t
}{
  \AnaCast\K\E\e\ep\t
}
\end{mathpar}

The next point of interest for the transient semantics is AASC2, which handles the case where we expect one type and get another that is not a subtype of the first type, but is consistent. In the behavioural and the soon to be discussed monotonic semantics, we would insert a cast at this point, as it is needed to ensure that the value at this point satisfies the type invariant. However, since transient only checks types at their use site, it does not need to check a type at the site of the type assertion.

\paragraph{Monotonic}

At the surface language level, the Monotonic semantics are very similar to that used by the guarded semantics and Typed Racket/Racket. We insert casts at locations at type boundaries.


% broken: partially typed calls

\newcommand{\monowrap}[2]{\xt{mwrap}(#1,#2)}
\begin{mathpar}
\IRule{PT}{
  {\classtrans{\K}{\K}{\K'}} \\ \GenCast{\K}{\cdot}{\e}{\ep}{\t} 
}{\progtrans{\e~\K}{\e'~{\K'}}}

\IRule{MCT1}{
  \D \text{ fresh}\\
  \k = \classgen{\C,{\classoff\C\K},{\classoff\C\K},\D,\K}
}{
  \monowrap{\C}{\K} = \D~\k
}

\IRule{MCT2}{
}{
  \monowrap{\any}{\K} = \any
}

\IRule{CR1}{ 
  \b{\methtrans \K\C\md{\md'}{\K_m}} \\
  \classtrans \K\Kp\Kpp \\
  \b{\monowrap\t\Kpp = \tp~\Kppp}
}{
   \classtrans \K{\Class \C{\b{\Ftype\f\t}}{\b\md}~\Kp}{\Class \C {\b{\Ftype\f\tp}}{\b{\md'}}~\Kpp~\K_m~\b{\Kppp}}}

\IRule{CR2}{ 
}{
  \classtrans \K\cdot\cdot
}

\IRule{MT}{
  \AnaCast \K{\HT\this\C~\HT\x\t}\e\ep\tp \\
  \monowrap{\t_1}\K = \t_2~\K_1 \\
  \monowrap{\tp_1}\K = \tp_2~\K_2
}{
  \methtrans \K\C{\Mdef\m\x{\t_1}{\tp_1}\e}{\Mdef\m\x{\t_2}{\tp_2}\ep}{\K_1~\K_2}
}
\end{mathpar}


\newcommand{\isstatic}[3]{\text{static}(#1,#2,#3)}
\begin{mathpar}
\IRule{A1}{\HasType{\E}\x\t}{\GenCast{\K}\E\x\x\t}

\IRule[width=30em]{A2}{
    \GenCast\K\Env{\e_1}{\e_3}{\C} \\ \n(\b{\t_1}):\t_2 \in \classoff\C\K \\ \isstatic{\t_1}{\K}{\cdot} \vee \n=\f \\ \b{\AnaCast\K\Env{\e_2}{\e_4}{\t_1}}
}{
    \GenCast\K\Env{\Call{\e_1}\n{\b{\e_2}}}{\Call{\e_3}\n{\b{\e_4}}}{\t_2}
}

\IRule[width=30em]{A3}{
    \GenCast\K\Env{\e_1}{\e_3}{\C} \\ \m({\t_1}):\t_2 \in \classoff\C\K \\ \lnot\isstatic{\t_1}{\K}{\cdot} \\ \b{\AnaCast\K\Env{\e_2}{\e_4}{\any}}
}{
    \GenCast\K\Env{\Call{\e_1}\m{{\e_2}}}{\DynCall{(\MonCast\any\e_3)}\m{{\e_4}}}{\t_2}
}

\IRule{A8}{
    \GenCast\K\Env{\e_1}{\e_3}{\any} \\ {\AnaCast\K\Env{\e_2}{\e_4}{\any}}
}{
    \GenCast\K\Env{\Call{\e_1}\m{{\e_2}}}{\DynCall{\e_3}\m{{\e_4}}}{\any}
}

\IRule{A11}{
  \b{\AnaCast{\K}\E{\e_1}{\e_2}\t} \\ 
  \Class \C {\b{\Ftype\f\t}} {\b{\md}} \\
  \D~\text{fresh} \\
  \D = \classgen{\C,\classoff\C\K,\classoff\C\K,\D,\K} \\
  }{\GenCast\K\Env{\New\C{\b{\e_1}}}{\New\D{\New\C{\b{\e_2}}}}{\C}}
\end{mathpar}

\begin{mathpar}
\IRule{AASC1}{
  \GenCast\K\Env\e\ep\tp \\
  \K \vdash \tp \Sub \t
}{
  \AnaCast\K\Env\e\ep\t
}

\IRule{AASC2}{
  \GenCast\K\Env\e\ep\tp \\
  \consistent\K\t\tp
}{
  \AnaCast\K\Env\e{\MonCast\t\ep}\t
}
\end{mathpar}

\bibliographystyle{unsrturl}
\bibliography{../bib/jv,../bib/all,../bib/ben}

\appendix
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Auxiliary Definitions}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Subtyping}

The structural subtype relation, written \StrSub\M\K\t\tp, asserts that \t
is a subtype of \tp in the environment composed of a set of subtyping \M and
a class table \K.   The set of subtypings can be omitted if empty.

~\\

\opdef{\StrSub\M\K\t\tp}{\t is a subtype of \tp}
\begin{mathpar}
\IRule{SRef}{
}{
 \StrSub\M\K \t \t
}

\IRule{SAss}{
\C \Sub \D \in \M
}{
 \StrSub \M\K \C \D
}

\IRule{SRec}{
 \M' = \M~\C\Sub\D\\
\mt \in \classoff\D\K \implies \exists \mt' \in \classoff\C\K. \StrSub{\M'}\K\mt{\mt'}
}{
 \StrSub \M\K \C \D 
}
\end{mathpar}

Several auxiliary rules are used in the subtype judgement. 

\begin{mathpar}
\IRule{SMet}{
  \StrSub \M\K {\t[1]} {\t[2]} \\
  \StrSub \M\K {\tp[2]} {\tp[1]}
}{
 \StrSub \M\K {\Mtype\m{\t[1]}{\tp[1]}} {\Mtype\m{\t[2]}{\tp[2]}}
}

\IRule{SGet}{
  \StrSub \M\K {\t[1]} {\t[2]}
}{
 \StrSub \M\K {\Mtype\f{}{\t[1]}} {\Mtype\f{}{\t[2]}}
}

\IRule{SSet}{
  \StrSub \M\K {\t[1]} {\t[2]}
}{
 \StrSub \M\K {\Mtype\f{\t[1]}{\t[1]}} {\Mtype\f{\t[2]}{\t[2]}}
}

\IRule{SThat}{
}{
  \StrSub\M\K{\Mtype\that{\b{\t[1]}}{\t[1]}}{\mt}
}
\end{mathpar}

\subsection{Well-formedness}

The overloading function is meant to check that every typed method is
defined once. Every untyped method is defined once. A class has either a
field \f or a pair of getter and setters.

\opdef{\WFp\e\K}{Well-formed program}

\begin{mathpar}
\IRule{WP}{
  \k \in \K \implies \WF{}\cdot\K\k \\
  \EnvType\Env\cdot\K\e\t
}{
  \WFp\e\K
}
\end{mathpar}

\opdef{\WF{}\s\K {\Class\C{\b\fd}{\b\md}}}{Well-formed class}

\begin{mathpar}
\IRule{WC}{
 \xt{overloading}(\b\fd,\b\md)\OK \\
 \fd\in\b\fd\implies \WF \none\s\K \fd \\
 \md\in\b\md\implies \WF \none\s\K \md 
}{
 \WF {}\s\K {\Class \C {\b\fd}{\b\md}}
}
\end{mathpar}

We have some auxiliary judgements.

\begin{mathpar}
\IRule[width=18em]{WT}{
 \EnvType {\Env{\Ftype\x\C}}\s\K\e\D\\
 \WFtype\K\C \\
 \WFtype\K\D \\
}{
 \WF \Env\s\K {\Mdef\m\x\C\D\e}
}

\IRule[width=18em]{WU}{
 \EnvType {\Env \Ftype\x\any}\s\K \e\any\\
}{
 \WF \Env\s\K{\Mdef\m\x\any\any\e}
}

\IRule{WS}{
 \EnvType {\Env{\Ftype\x\tp}}\s\K \e\t \\
 \WFtype \K\t 
}{
 \WF  \Env\s\K {\Mdef\f\x\t\t\e}
}

\IRule{WF}{
 \WFtype \K\t 
}{
 \WF  \Env\s\K {\Fdef\f\t}
}

\IRule{WG}{
 \EnvType \Env\s\K\e\t \\
 \WFtype \K\t
}{
 \WF \Env\s\K {\Mdefz\f\t\e}
}


\IRule{WA}{
}{
 \WFtype \K \any
}

\IRule{WC}{
 \C \in \K
}{
 \WFtype  \K\C
}
\end{mathpar}



\subsection{Typing}

Field accessor rules W3 and W4 require a typed receiver, since \any does
not have any methods a receiver typed at \any will never typecheck.

Shallow casts, W9, do not change the type of the expression. We are casting
to the name of \t not to \t.  In practice that means that all expression
types in Transient will drift towards \any.

~\\

\opdef{\EnvType\Env\s\K\e\t}{\e has type \t in environment \Env against heap \s}
\begin{mathpar}

\IRule{W1}{
   \HasType \Env\x\t
 }{
   \EnvType \Env\s\K\x\t
}

\IRule{W2}{
  \EnvType \Env\s\K\e\tp \\
 \StrSub \M\K \tp \t
 }{
  \EnvType \Env\s\K\e\t 
}   

\IRule{W3}{
  \EnvType \Env\s\K\e\C \\
  \Mtype \f{}\tp \in \classoff\C\K
}{
  \EnvType \Env\s\K{\Get\e\f}\tp
}    

\IRule{W4}{
  \EnvType \Env\s\K\e\C \\
  \Mtype \f\tp\tp \in \classoff\C\K  \\
  \EnvType \Env\s\K\ep\tp
}{
  \EnvType \Env\s\K{\Set\e\f\ep}\tp
}    

\IRule{W5}{
  \EnvType \Env\s\K\e\C \\
  \Mtype \m\tp\tpp\in \classoff\C\K  \\
  \EnvType \Env\s\K\ep\tp
}{
  \EnvType \Env\s\K{\Call\e\m\ep}\tpp
}    

\IRule{W6}{
  \EnvType \Env\s\K\e\any \\
  \EnvType \Env\s\K\ep\any
}{
  \EnvType \Env\s\K{\DynCall\e\m\ep}\any
}    

\IRule{W7}{
 \EnvType \Env\s\K{\e_1}{\t_1}\dots 
 \EnvType \Env\s\K{\e_n}{\t_n}\ \\ 
 \b\fd=\Fdef{\f_1}{\t_1}\dots\Fdef{\f_n}{\t_n} \\ 
  \Class \C {\b\fd}{\b\md} \in \K
}{
  \EnvType \Env\s\K{\New\C{\e_1\dots\e_n}}\C
}

\IRule{W8}{
  \EnvType \Env\s\K\e\tp
}{
  \EnvType \Env\s\K{\SubCast\t\e}\t
}

\IRule{W9}{
  \EnvType \Env\s\K\e\tp
}{
  \EnvType \Env\s\K{\ShaCast\t\e}\any  %%!!!  not \t !!!
}

\IRule{W10}{
  \EnvType \Env\s\K\e\tp
}{
  \EnvType \Env\s\K{\BehCast\t\e}\t
}

\IRule{W11}{
  \EnvType \Env\s\K\e\tp
}{
  \EnvType \Env\s\K{\MonCast\t\e}\t
}

\IRule{W12}{
  \s(\a) = \obj\C{\b\ap}
}{
  \EnvType \Env\s\K\a\C
}
\end{mathpar}


\subsection{Field read}

We write \readf\s\a\f\K to denote a read of field \f from the object
stored at \a in \s.

\begin{equation*}
\readf \s\a\f\K = \ap ~~\mathit{if}~~  \s(\a) = \obj\C{\a_1\dots\a_n \ap \dots} \AND
 \Class\C {\Fdef{\f_1}{\t_1}\dots\Fdef{\f_n}{\t_n}\Ftype\f\t\dots}{\b\md}\in\K
\end{equation*}

\subsection{Write field}

We write \setf\s\a\f\ap\K to denote the write of value \ap into field \f of
the object stored at \a in \s.

\begin{equation*}
\setf \s\a\f\ap\K= \Map\s{\Bind{\a}{\obj\C{\a_1\dots\a_n\,\ap\dots}}}
  ~~\mathit{if}~~ \begin{cases}
   \s(\a) = \obj\C{\a_1\dots\a_n\,\app\dots}\\
   \Class\C{\Fdef{\f_1}{\t_1}\dots\Fdef{\f_n}{\t_n}\,\Fdef\f\t\dots}{\b\md}\in\K
\end{cases}
\end{equation*}

\section{Generative Monotone Casts}

The \texttt{mmeet} function is used by the \texttt{tmeet} functions to
perform the meet over the typing of each method within a class definition.
The \texttt{mmeet} function also takes four arguments, the method
signatures of the original class $\b\mt$, the method signatures of the cast
class $\b\mtp$, the environment $\P$, a class table $\K$, and outputs method
types $\b\mtpp$ and a class table $\Kp$. 

\hrulefill

\opdef{
  $\mmeet{\b\mt}{\b\mtp}\P\K = \b\mtpp\,\Kp$
}{
}
\begin{mathpar}
\IRule{MM1}{
}{
  \mmeet{\b\mt}{\cdot}\P\K =\b{\mt} ~\K
}

\IRule{MM2}{
}{
  \mmeet{\cdot}{\b\mt}\P\K =\b{\mt} ~\K
}

\IRule{MM3}{ 
  \Mtype\f{}{\t} = \mt \\
  \Mtype\f{}{\tp} \in \b{\mtp} \\
  \tmeet{\t}{\tp}\P\K = \tpp~\Kp \\
  \Mtype\f{}{\tpp} = \mtpp
}{ 
   \mmeet{\mt}{\b{\mtp}}\P\K = \mtpp\,\Kp
}

\IRule{MM4}{ 
  \Mtype\f{\t}{\t} = \mt \\
  \Mtype\f{\tp}{\tp} \in \b{\mtp} \\
  \tmeet{\t}{\tp}\P\K = \tpp~\Kp \\
  \Mtype\f{\tpp}{\tpp} = \mtpp
}{ 
   \mmeet{\mt}{\b{\mtp}}\P\K = \mtpp\,\Kp
}


\IRule{MM5}{ 
  \Mtype\m{\t_1}{\t_2} = \mt \\
  \Mtype\m{\t_3}{\t_4} \in \b{\mtp} \\
  \tmeet{\t_3}{\t_1}\P\K = \t_5~\Kp \\
  \tmeet{\t_2}{\t_4}\P\Kp = {\t_6}~{\Kpp} \\
  \Mtype\n{\t_5}{\t_6} = \mtpp
}{ 
   \mmeet{\mt}{\b{\mtp}}\P\K = \mtpp\,\Kpp 
}

\IRule{MM6}{
  \mmeet{\mt}{\b{\mt_2}}\P\K = \mt_3~\Kp\\
  \mmeet{\b{\mt_1}}{\b{\mt_2}}\P\Kp = \b{\mt_4}~\Kpp
}{
  \mmeet{\mt~\b{\mt_1}}{\b{\mt_2}}\P\K =\mt_3\b{\mt_4} ~\Kpp
}
\end{mathpar}
\\

\hrulefill

\begin{mathpar}
\IRule{HT1}{
  \a \not\in \text{addr}(\S) \\
  \enfortype\C\cdot\K = \D\,\W\,\Kp
}{
  \htype\a\S{\sigma[\a \mapsto \C\{\ap\}]}\K = \D~\Kp
}

\IRule{HT2}{
  \S(\a) = \t
}{
  \htype{\a}{\S}{\sigma}\K = \t~\K
}
\end{mathpar}

\hrulefill
\begin{align*}
\W &::= \cdot \B \Map\W{\Bind\C\D}
\end{align*}
\begin{mathpar}
\IRule{ENT1}{ 
  \Class\C{\hspace{-0.3em}}{\Fdef\that\Cp ~ \b\md} \in \K \\ 
  \C \notin \text{dom}(\W) \\
  \D\text{ fresh} \\
  \Wp = \W\,\Bind\C\D \\
  \Kp = \K\,\Class\D{\hspace{-0.3em}}{\Fdef\that\Cp ~ \enformt{\b{\md}}{\Wp}{\K}} \\ 
}{
  \enfortype{\C}{\W}{\K} = \D\,\Wp\,\Kp
}

\IRule{ENT2}{ 
  \W(\C) = \D \\
}{
  \enfortype{\C}{\W}{\K} = \D\,\W\,\K
}

\IRule{ENT3}{ 
}{
  \enfortype{\any}{\W}{\K} = \any\,\W\,\K
}
\end{mathpar}
\\

\hrulefill

\begin{mathpar}
\IRule{ENMT1}{
  \md =  \Mdef\m\x\any\any {~\SubCast\any{\MonCast\tp{{[{(\MonCast\t\x)}/\x]\ep}}}~} \\
  \enfortype\t\W\K = \tpp\,\Wp\,\Kp \\
  \enfortype\tp\Wp\Kp = \tppp\,\Wpp\Kpp \\
  \mdpp = \Mdef\m\x\tpp\tppp {\MonCast\tppp\x} \\
  \enformt{\b\md}{\Wpp}{\Kpp} = \b\mddp \\
}{
  \enformt{\md\,\b\md}{\W}{\K} = \mdpp\,\b\mddp
}

\IRule{ENMT2}{
  \md = \Mdef\m\x\t\tp {\ep~}\\ 
  \enfortype\t\W\K = \tpp\,\Wp\,\Kp \\
  \enfortype\tp\Wp\Kp = \tppp\,\Wpp\Kpp \\  
  \mdpp =\Mdef\m\x\tpp\tppp {\MonCast\tppp\x}\\
  \enformt{\b\md}{\Wpp}{\Kpp} = \b\mddp \\
}{
  \enformt{\md\,\b\md}{\W}{\K} = \mdpp\,\b\mddp
}

\IRule{ENFS}{
  \md = \Mdef\f\x\any\any {\SubCast\any{\MonCast\tp{\Set{\Get\this\that}\f{\MonCast\t{\MonCast\tp\x}}}}} \\ 
  \enfortype\t\W\K = \tpp\,\Wp\,\Kp \\
  \enfortype\tp\Wp\Kp = \tppp\,\Wpp\Kpp \\   
  \mdpp = \Mdef\f\x\tpp\tppp {\MonCast\tppp\x} \\
  \enformt{\b\md}{\Wpp}{\Kpp} = \b\mddp \\
}{
  \enformt{\md\,\b\md}{\W}{\K} = \mdpp\,\b\mddp
}

\IRule{ENFG}{
  \md =  \Mdefz\f\any{\SubCast\any{\MonCast\t{\Get{\Get\this\that}\f}}} \\ 
  \enfortype\t\W\K = \tp\,\Wp\,\Kp \\
  \mdpp = \Mdefz\f\tp {\MonCast\tp{\Get{\Get\this\that}\f}} \\
  \enformt{\b\md}{\Wp}{\Kp} = \b\mddp \\
}{
  \enformt{\md\,\b\md}{\W}{\K} = \mdpp\,\b\mddp
}

\IRule{ENE}{
}{
  \enformt{\cdot}{\W}{\K} = \cdot
}
\end{mathpar}

\hrulefill

\opdef{
  $\statictype\D\K{\b\C} = \texttt{Bool}$
}{
}

\begin{mathpar}
\IRule{ST1}{ 
}{ 
  \statictype\any\K{\b\C} = \texttt{False} 
}

\IRule{ST2}{ 
 \D \in {\b\C}
}{ 
  \statictype\D\K{\b\C} = \texttt{True} 
}

\IRule{ST3}{
  \D ~\text{empty}
}{ 
  \statictype\D\K{\b\C} = \texttt{True} 
}

\IRule{ST4}{
 \Class \C {\b{\Ftype\f\t}}{\b\md} \in \K \\
 \sign{\b\md} = \b{\Mtype\m\tp\tpp} \\ 
 \b\Cp = \b\C, \b\t, \b\tp, \b\tpp 
}{ 
  \statictype\D\K{\b\C} = \statictype{\b\t}\K{\b\Cp} \cap \statictype{\b\tp}\K{\b\Cp} \cap \statictype{\b\tpp}\K{\b\Cp}
}
\end{mathpar}
\\


We write \wftype{\b\f}\C\K to denote the type lookup for a particular set of fields in \C.

\begin{equation*}
\wftype{\b\f}\C\K = \b\t ~~\mathit{if}~~ \begin{cases}

 \Class \C {\b{\Ftype\fp\tp}}{\b\md} \in \K\\
 \b\t = \{ \b\t \subseteq \b\tp ~|~ \forall~ \f \in \b\f ~.~ \f \in \names{\b{\Ftype\fp\tp}} \} \\
 
\end{cases}
\end{equation*}


We write \classoff\C\K to denote the signutare lookup for every method, including field getters and setters, in \C.

\begin{equation*}
\classoff\C\K = \b\mt ~~\mathit{if}~~ \begin{cases}

 \Class \C {\b{\Ftype\f\t}}{\b\md} \in \K\\
 \b\mt = \sign{\b\md} \oplus \forall ~\Ftype\fp\tp \in \b{\Ftype\f\t} ~|~ \fp \notin \names{\b\md} ~.~ \typez{\Ftype\fp\tp}

\end{cases}
\end{equation*}

$\getmds(\C,\K)$ refers to the method definitions that are explicitly written inside of the class \C, according to the class table \K.

\begin{equation*}
\getmds\C\K = \b\md ~~\mathit{if}~~ \Class\C{\b{\fd}}{\b\md} \in \K
\end{equation*}

\hrulefill

\begin{mathpar}
\IRule{FT1}{
 \App\s\a=\obj\D{\ap} \\ % we know that a refers to a wrapper with a that field of the wrapped object
  \App\s\ap =\obj\E{\b\app}  \\ % getting the fields out of ap
 \Class \E {\b{\Fdef\f\t}}{\b\md} \in\K \\
 \wftype{\b\f}\C\K =\b\tp
}{
  \ftypes \a\C\s\K = \b\app~\b\tp
}
\end{mathpar}

\hrulefill

% &\B~   &\B \Mtype\f{}\t

\begin{mathpar}
\IRule{DYN1}{
 \dyn{\b\mt} = \b{\mtp} \\
}{
  \dyn{\Mtype{\m}{\t}{\t} ~\,\b\mt} = \Mtype{\m}{\any}{\any}~\,\b\mtp
}

\IRule{DYN2}{
 \dyn{\b\mt} = \b{\mtp} \\
}{
  \dyn{\Mtype{\f}{\t}{\t} ~\,\b\mt} = \Mtype{\f}{\any}{\any}~\,\b\mtp
}

\IRule{DYN3}{
 \dyn{\b\mt} = \b{\mtp} \\
}{
  \dyn{\Mtype{\f}{}{\t} ~\,\b\mt} = \Mtype{\f}{}{\any}~\,\b\mtp
}

\IRule{DYNE}{
}{
  \dyn{\cdot} = \cdot
}
\end{mathpar}



\section{Monotonic figure scratch}

%% Example -- please check

%%class A {
%%  m(x:*):* { x }  
%%}
%% a = new A()
%% a.m(new A()) -- works fine
%%class B {
%%  m(x:B):B { x }  
%%}
%% b = <|B|> a
%% b.m(new B()) -- works
%% a.m(new A()) -- fails

% translated version

%%class wA {
%%  that : A
%%  m(x:*):* { this.that().m(x) }
%%}
%%a = new wA(new A())
%%(<*>a)@(<*>new wA(new A()))
%%class AmB {
%%  m(x:B):B{ ... }
%%}
%%class AwAmB {
%%  that : A
%%  m(x:*):* { <|*|><|B|>(<|*|>this.that())@m(<|*|><|B|>x) }
%%  m(x:B):B { <|B|>(<|*|>this.that())@m(<|*|>x)}  
%%}
%% b = <|B|> a -- b and a instance of AwAmB
%% b.m(new B()) -- works
%% a.m(new A()) -- fails

% example 2

%% class T { }
%% class A { f : * }
%% class B { f : A }
%% class C { f : B }
%% a1 = new A(new T())
%% a2 = new A(a1)
%% a3 = new A(a2)
%% b = <|B|> a3
%% c = <|C|> a3

% translated

%% class WA { that : A f():* { <|*|><|*|> this.that().f() } f(x:*):* { <|*|><|*|> this.that().f(<|*|><|*|>s x)} }
%% class WAmB { that:A f():* { <|*|><|A|>this.that().f() } f(x:*):* {<|*|><|A|> this.that().f(<|*|><|A|> x) } }
%% class WAmBmC { that:A f():* {<|*|> <|B|> this.that().f() } f(x:*):* { <|*|> <|B|> this.that().f(<|*|><|B|> x)} }
%% a1 = new WA(new A(new WT(new T())))
%% a2 = new WA(new A(a1))
%% a3 = new WA(new A(a2))
%% b = <|B|> a3 -- s(b) : WAmB
%% a3.f(new T()) -- boom
%% a2.f(new T()) -- ok
%% c = <|C|> b -- s(b) : WAmBmC, s(a2) : WAmB
%% a3.f(new T()) -- boom
%% a3.f(new WA(new A(new T))) -- boom
%% a2.f(new T()) -- boom

%% class A {
%%   fa : B
%%   ma(x : A): B { fa.mb(a) }
%% }
%% class B {
%%   fb : any
%%   mb(x:A):B { this }
%% }
%% class C {}

%% class Ap {
%%   fa : Bp
%%   ma(x : Ap): Bp {...}
%% }
%% class Bp {
%%   fb: C 
%%   ma(x : Ap): Bp {...}
%% }

%% a = new A(new B(new C()))
%% ap = <| Ap |> a

%% class WA {
%%   that : A
%%   fa() : B { that.fa() }
%%   fa(x:B):B { that.fa(x) }
%%   ma(x:B):B { that.ma(x) }
%% }
%% class WB {
%%   that : any
%%   fb() : any { that.fb() }
%%   fb(x:any):any { that.fb(x) }
%%   mb(x:B):B { that.mb(x) }
%% }
%% class WBp {
%%   that : A
%%   ...


\section{Proofs of Related Theorems}
\subsection{Accessory Lemmas}

\paragraph{Evaluation Extends Class Tables}

If $\Reduce \K\e\s \Kp\ep\sp$ then $\Kp = \K~\Kpp$ for some $\Kpp$.

\paragraph{Weakening of Subtyping}

If $\StrSub\cdot\K\t\tp$ then $\StrSub\cdot{\K~\Kp}\t\tp$.

\paragraph{Correctness of \classoff{\C}{\K}}

If $\Mtype\n{\b\t}\tp \in \classoff{\C}{\K}$, $\EnvType\cdot\s\K\e\C$ and (if applicable) $\EnvType\cdot\s\K\ep\t$, then $\Reduce \K{\Call\e\n{\b\ep}}\s \K\epp\s$ where $\EnvType\cdot\s\K\epp\tp$

\subsection{Soundness of \kafka Typing}

Given that $\WFp\K\e\s$ and $\EnvType\cdot\s\K\e\t$, then either there is some $\ep$ such that $\Reduce \K\e\s \Kp\ep\sp$ and $\WFp\Kp\ep\sp$ and $\EnvType\cdot\sp\Kp\ep\t$ hold, or $\e$ is of one of the following forms:
\begin{itemize} 
\item $\a$
\item $\DynCall\ep\m{\epp}$
\item $\SubCast\tp\ep$
\item $\ShaCast\tp\ep$
\item $\BehCast\tp\ep$
\item $\MonCast\tp\ep $
\end{itemize}
We proceed with rule induction on the judgement used to conclude $\EnvType\Env\s\K\e\t$. Note that we refer to rule preconditions from left to right.
\begin{itemize}
  \item W1

        Not applicable, since $\Gamma = \cdot$ and therefore contains no variables.
  \item W2

        We apply the IH to the first precondition. If we get stuck in the IH, then the entire expression gets stuck or terminates, trivially. Therefore, the interesting case is when $\Reduce \K\e\s \Kp\ep\sp$, $\WFp\Kp\ep\sp$ and $\EnvType\cdot\sp\Kp\ep\tp$. By 
  \item W3, W4, W5
  \item W6
  \item W7
  \item W8
  \item W9
  \item W10
  \item W11
  \item W12
\end{itemize}

\subsection{Type Correctness of Translation}


\end{document}

%######## ##    ## ########      #######  ########    ########   #######   ######  ##     ## ##     ## ######## ##    ## ######## 
%##       ###   ## ##     ##    ##     ## ##          ##     ## ##     ## ##    ## ##     ## ###   ### ##       ###   ##    ##    
%##       ####  ## ##     ##    ##     ## ##          ##     ## ##     ## ##       ##     ## #### #### ##       ####  ##    ##    
%######   ## ## ## ##     ##    ##     ## ######      ##     ## ##     ## ##       ##     ## ## ### ## ######   ## ## ##    ##    
%##       ##  #### ##     ##    ##     ## ##          ##     ## ##     ## ##       ##     ## ##     ## ##       ##  ####    ##    
%##       ##   ### ##     ##    ##     ## ##          ##     ## ##     ## ##    ## ##     ## ##     ## ##       ##   ###    ##    
%######## ##    ## ########      #######  ##          ########   #######   ######   #######  ##     ## ######## ##    ##    ##    




\subsection{others}

%TODO Fix ME \mtype\m\C\K = \convert{\methz\m\C\K} 

\hrulefill

\opdef{\classoff\C\K}{Auxiliary function: Type definition}

\begin{equation*}
\classoff\C\K = \EMxt{MT} ~~s.t.~~ \begin{cases}

 \K(\C) = \Class \C {\b{\Ftype\f\t}}{\b\md} \\
 \EMxt{MT} = \{\convert{\b\md} \oplus \forall ~\Ftype\fp\tp \in \b{\Ftype\f\t} ~|~ \fp \notin \b{\names{\md}} ~.~ \convertFD{\Ftype\fp\tp}\}

\end{cases}
\end{equation*}

\hrulefill


\opdef{\classoffs\a\s\K}{Auxiliary function: Type definition}

\begin{equation*}
\classoffs\a\s\K = \EMxt{MT} ~~s.t.~~ \begin{cases}

 \s(\a) = \obj\C{\b\a} \\
 \K(\C) = \Class \C {\b{\Ftype\f\t}}{\b\md} \\
 \EMxt{MT} = \{\convert{\b\md} \oplus \forall ~\Ftype\fp\tp \in \b{\Ftype\f\t} ~|~ \fp \notin \b{\names{\md}} ~.~ \convertFD{\Ftype\fp\tp}\}

\end{cases}
\end{equation*}

\hrulefill

\opdef{\ftype\f\C\K}{Auxiliary function: Field type lookup}

\begin{equation*}
\ftype\f\C\K = \t ~~s.t.~~ \begin{cases}

 \K(\C) = \Class \C {\ldots ~ \Ftype\f\t ~ \ldots}{\b\md}
\end{cases}
\end{equation*}

\hrulefill

\opdef{\field\C\K}{Auxiliary function: Field definition}

\begin{equation*}
\field\C\K = \b{\Ftype\f\t} ~~s.t.~~ \begin{cases}

 \K(\C) = \Class \C {\b{\Ftype\f\t}}{\b\md}
\end{cases}
\end{equation*}




This common core is focused on the basics of object functionality, with a
simple example being a \xt{Point} class.\footnote{For our examples we use
  integers and common arithmetic operations even if they are not in core
  calculus.}

%%% FIXME: formatting
\begin{verbatim}
class Point {
  x : Int
  y : Int
  addx( v : Int ) : Int {
       this.x!( this.x() + v )
  }
  addy( v : Int ) : Int {
       this.y!( this.y() + v )
  }
}
\end{verbatim}

The type system ensures that, if \xt{pt} is declared to be of type
\xt{Point}, an operation such as \xt{pt.addx(42)} will not get stuck.  As
this small language requires all variables to be initialized, there checking
for \xt{null} is not needed as it likely would in a full fledged language.

The language also supports a single unconstrained type, denote \any (pronounced
dyn), thus one could write the following method

%%% FIXME: formatting
\begin{verbatim}
  mkPt( u : * ) : Point {
      new Point( u.x() 
                 (<Point> u).y() )
  }
\end{verbatim}

This method will accept an instance of any class and will return a new
\xt{Point}. At run-time, the code will get stuck if the dynamic cast
\xt{\Cast{\xt{Point}}{\xt{u}}} fails. If \x is a declared of type \any, an
expression such as \xt{u.x()} will fail if the object bound to \xt{u} does
not have a getter \xt{x()}.


%%%%%%%%%%%%%%%%%%%%%% DYNAMIC SEMANTICS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The dynamic semantics evaluates expression extended with object references,
denoted \a, and errors, denoted \err, together with a heap \s mapping
references to object values. Object values contain all fields, methods, a
type, and a class; they are denoted \obj\C{\b\a}. The class is used for
locating methods and the type is used for type casts. The need for keeping
them separate will become clear later.

The semantics uses evaluation context \E[\e], meaning that $\e$ is in the
hole of $\E$. Selecting an object from the heap is written \Sel\s\a, while a
heap is extended with a new object by \Map{\s}{\Bind{\a}{\obj\C{\dots}}}.

For an object reference \a, such that \EM{\Sel\s\a=\obj\C\dots}, we have 
\classofis{\Sel\s\a}\C and \typeofis\s\a\t.

We use the notation \Mdef\m\x\t\t \in\C to select a method in a class
definition and \Fdef\f\t\a\in\obj\C\dots to express the selection of a
field. Lastly a field of an object can be update with the notation
\Update{\obj\C\dots}\f\a.

\subsection{Core Type System}

As a basis for our gradual type system, we will use a simple static
type system, ensuring that the program will not get stuck, but while
simultaneously is entirely up-front and not gradual, shown in
figure~\ref{fig:basetyp}.

This basic type system is typical of calculi that support objects, notably
including subtyping. Subtyping in our system is defined in
figure~\ref{fig:sub}, which defines a simple structual subtyping system with
names (to provide for recursive types) as well as the Amber rule to support
recursive types. Notably, however, because there are no valid operations on
$\any$ other than casting, this type system cannot be called a
\emph{gradual} type system, as a gradual type system should allow $\any$
typed-terms to coexist with fully typed ones.

Soundness for this base system is typical. We combine the progress and
preservation lemmas to come up with an aggregate small step soundness
theorem, which we then extend with the typical cast failure carve-out to
enable casts to fail without the program getting stuck.

\begin{thm}
If $\EnvType\Es\e\t$, then one of the following holds:
\begin{itemize}
\item $\e \rightarrow \e'$ and $\EnvType\Es{\e'}\t$
\item $\e \rightarrow \xt{v}$ and $\EnvType\Es{\xt{v}}\t$
\item $\e$ is $\Cast{\t}{\e'}$ and $\e \rightarrow \err$
\end{itemize}
\end{thm}

The proof of this theorem is simple and is included in the appendix.

\begin{figure}
\input{figures/basetype}
\caption{Typing rules for the base langauge}
\label{fig:basetyp}
\end{figure}


\section{Gradual Typing}
In order to extend the core calculus to enable programmers to write
gradually typed code without having to insert a great number of casts
manually, we use gradual type systems to add casts where required,
presenting a unified gradual semantics to the programmer while relying on
the core system for soundness.

Our characterization of gradual typing is \emph{gradual typing by translation},
using an approach similar to that of~\cite{Bierman10}, adding gradual
types to the underlying fully typed language. In this vein,
we define our gradual typing extensions as \emph{cast insertion} phases.

\subsection{Cast Insertion}

The user-facing component of a gradual typing system is its type checker,
or the surface type system, which is then complemented by a type-driven
cast insertion mechanism ``behind the scenes''. In our approach, these two
steps are combined into a cast insertion system.

Cast insertion is fundamentally \emph{type driven}. In our type system, it is
required to have a cast whenever a type needs to be altered, and therefore in
inserting casts we need to know every site where one type is required to be another.
Our system handles this through an \emph{bidirectional cast insertion} system,
introduced by~\cite{lti-pierce}

Our choice comes from an observation about the nature of traditional
bottom-up type systems. The fundamental building block is judgements of the
form $\E \vdash \e : \t$, which means that $\e$ inherently has type
$\t$. For example, a type mismatch would look like trying to conclude a
judgement $\E \vdash \e : \any$ when only $\E \vdash \e : \xt{int}$ holds.

Other systems have solved this problem through the introduction of
nondeterministic rules such as subsumption, but nondeterminism in cast
insertion creates problems where a single program can be typed in multiple
different ways (EXAMPLE).

To solve this problem, we use the aforementioned bidirectional cast
insertion mechanism. Ina bidirectional system, we have two judgements:

\begin{itemize}
\item The \emph{analytic} judgement $\E \vdash \e \Rightarrow \t$, which says that
$\e$ inherently has type $\t$ against environment $\E$, equivalently to the
traditional bottom-up type system.
\item The \emph{synthetic} judgement $\E \vdash \e \Leftarrow \t$, which implies that
$\e$ can potentially have type $\t$ against environment $\E$.
\end{itemize}

For example, consider the function call $\Call{\ep1}{\m}{\ep2}$. A
bidirectional type system will begin with seeing what type $\ep1$ has, with
the judgment $\E \vdash \ep1 \Rightarrow \t$.  From this, the bidirectional
type system will check what type the method $\m$ has in $\t$, here denoted
$\Mtype\m{\tp1}{\tp2} \in \t$, then ensure that the arguments make sense
with that type.

In a bottom-up type system, we would write $\E \vdash \ep2 : \tp1$, but, as
commonly noted with subsumption, this can require the introduction of a
nonalgorithmic rule to conclude this final judgment. Instead, in a
bidirectional type system, we can simply ensure that the type of $\ep2$ is
consistent with $\tp1$ through the judgment $\E \vdash \ep2 \Leftarrow
\tp2$.

Finally, we will be able to conclude that $\E \vdash \Call{\ep1}{\m}{\ep2}
\Rightarrow \tp2$. This is a synthetic judgement as $\tp2$ is the type that
the expression can be known to have in the absence of any external
information.

To support cast insertion, we extend these basic type checking judgements
with an output term, of the form $\GenCast{\E}{\ep1}{\ep2}{\t}$ for the
synthetic case and $\AnaCast{\E}{\ep1}{\ep2}{\t}$ for the analytic, case,
where the former translates $\ep1$ to $\ep2$ producting type $\t$, and the
latter translates the same ensuring type $\t$.

An important note in the construction of our bidirectional type system is
that our handling of the key case, function application, is less specific
than it could be, as we ignore the analytic case. Other works in this area,
including~\cite{bidir-typing} use a third bidirectional judgment to handle
function application, largely to handle the analytic case. If we are trying
to typecheck a function call against some known type, then we can infer a
type for the receiver by using synthetic type checking on the arguments.
However, in our context, detailed handling of this case is not required, as
our type inference does not need to be as precise as it does for Dunfield
and Krishnaswami's type inference.

\subsection{Class Translation}

A key component of many gradual type systems is enabling checks for every
field access or modification, ensuring type invariants about the heap. To
enable these checks, we cannot expose ``raw'' field access and modification
in our calculus, as otherwise these checks could be easily bypassed.

As a result, we expose no typing judgment for field manipulation, and
instead auto-generate getter and setter methods in a phase we call
\emph{class translation}, occuring at the same time as cast insertion.

Another issue solved by class translation is that raised by calling a method
on a dynamic receiver type.  Consider the invocation $\Call{\e}{\m}{\e'}$
where $\EnvType{\Es}{\e}{\any}$ and $\EnvType{\Es}{\e'}{\any}$.  Now,
suppose that we have a method on $\e$ $\m(\x:\C)$. Using casting, we can
figure out that the method exists, and that the arity is correct, but there
is no static way to know the argument types of $\m$ statically to insert
checks.

Class translation solves this problem by creating a ``guard'' method
$\m_\xt{u}$ that will have the same arity and a related name, but only has
arguments of type $\any$. We then translate every call to a method $\m$ on
an untyped receiver to a call to a call to $\m_\xt{u}$, which then does the
approperiate type check before calling the typed method. Likewise, method reads and writes are protected by getters and setters added
during the class translation phase.

%%%%%%%%%%%%%%%%%%%%%%%% SUBTYPING %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}
%\input{figures/subtyping}
\caption{Subtyping}
\label{fig:sub}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%% WELLFORMDNESS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{figure}
%\input{figures/syncast}
\caption{Synthetic cast insertion}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%% CLASS TRANSLATION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}
%\input{figures/anacast}
\caption{Analytic Cast Insertion}
\end{figure}

\begin{figure}
%\input{figures/classtrans}
\caption{Class Translation}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

At this point, we have defined a not-very-useful semantics for gradual typing, 
with all of the key components but providing no additional functionality
beyond what our original statically typed core. This semantics has us
applying class translation, $\TransClass\C\C$, expression translation,
$\GenCast\E\e\e\t$ and $\AnaCast\E\e\e\t$, a dynamic semantics $\e 
\rightarrow \e$, and finally a subtyping relationship $\t <: \t$, defining the
architecture that we will follow for the remainder of the languages.


By following this structure, we can describe a semantics for our language
with the 5-tuple $(\rightharpoonup, \hookrightarrow, \rightsquigarrow, <:, \rightarrow)$.
The core would be defined as (TODO)


\subsection{Type soundness:}
Theorem 1: Type translation. If $\EnvType{\Es}\e\t$ and $\TransExp\E\e{\e'}\t$ then $\EnvType{\E ~ \cdot}{\e'}\t$.

Theorem 2: Progress. If $\EnvType{\Es}{\e}{\t}$ then $\s,\e \rightarrow \s',\e'$ for $\e'$ expression or $\e' ~ \err$.

Theorem 3: Preservation. If $\s,\e \rightarrow \s',\e'$ and $\EnvType{\Es}{\e}{\t}$ then $\EnvType{\E~\s'}{\e'}{\t}$.

For a list of classes $\bar{\c}$ such that $\b{\c ~~ WF}$ and an expression $e$ such that $\EnvnvType\cdot\e\t$ and $\b{\TransClass\c{\c'}}$, we have $\cdot~e \rightarrow^* \sigma~r$ (against $\b{\c'}$) where $r$ is either a value or $\err$.


\begin{figure}
\input{figures/trtrans}
\caption{Translation for Typed Racket}
\end{figure}

Typed Racket uses a much stricter definition of where $\any$ types can go, where every class is either fully typed or fully untyped. To describe this, we alter definition 1 and 2 to


\begin{definition} A Typed Racket class table is well-formed if for every class \C  in
the class table, every method is of the form \Mdef\d\x{\tp1}{\tp2}\e where
\EnvType{\this:\C,\b{\x:\tp1}}\e{\tp2} holds in \C, and all types in \C are either $\any$ or all not $\any$
\end{definition}

Typed Racket uses wrappers to ensure that typed code type guarantees are not violated, and that untyped code follows the types that it is casted to. We generate these wrappers using the following mechanism.

\begin{definition}
Every place a type \Type{\mt} where $\mt=\Mtype\m{\b{\tp1}}{\tp2}$ flows from typed into untyped code, generate a wrapper $\Class{\C'}{~\xt{orig}:\t,\b{\md}}$ where $\md = \Mdef\m\x{\any}{\any}{\Cast{\any}{\xt{this}.\xt{orig}.\m(\b{\Cast{\tp1}x})}}$.
\end{definition}

To model Typed Racket, we then need to enforce the property that objects are wrapped at typed/untyped boundaries, and ensuring that untyped code cannot use typed code internally through casts. We do this by altering the completion process, giving us a new definition. We use the wrappers we generated using definition 4 to enforce the type guarantees


\begin{definition} A Typed Racket class table is completed if for every 
 \Class \C {\b{\fd}} {\b{\md}} in the class table: 
 \begin{itemize}
 \item for every type \Type{\b{\md}}, add a class \xt{D} such that 
 \begin{itemize}
 \item for every method $\Mtype\m{\tp1}{\tp2} \in \b{\md}$, generate a function in \xt{D} $\Mdef\m{x}{\any}{\any}{\Cast{\any}{\New{\xt{D}}{\xt{this}.\xt{orig}.\m(\New\C{\b{\Cast{\tp1}x}})}}}$
 \end{itemize}
 \item for every field \Ftype\f\t\in\C, we add to \C:
 \begin{itemize}
 \item A setter \SMdef\f\x\t\t{\Set\this\f\x} 
 \item A getter \GMdef\f\t{\Get\this\f}; 
 \end{itemize}
 \item For every method definition \Mdef\d\x\t{\tp1}\e\in\C:
 \begin{itemize}
 \item A dynamic method \Mdef{\Dyn\d}\x\any\any{\Cast\any{\Call\this\d{\b{\Cast\t\x }} }} is added to \C 
 \item We replace the body \e of \m is replaced by \ep1 where \TransClass\e{\ep1}.
 \end{itemize}
 \end{itemize}
\end{definition}

One of the issues inherent to the Strongscript approach (and is apparent in
the common core as well) is that a strict interpretation of the static type
system causes the programmer to have to write a very large number of
``obvious'' casts, breaking untyped code and seemingly-sensible typed
code. We can solve this by having the compilation process insert the types
for the programmer, which we describe using a cast insertion system.

Our cast insertion approach is based on a bidirectional type
system~\cite{}, where each expression either \emph{synthesizes}, or
inherently makes, a type, or is \emph{analyzed} against a type where the
type system checks to make sure that the expression still ``works'' under
the given type. This approach has been used for a number of other tasks,
including inferring types to select sub-languages~\cite{}, infer
types for higher rank languages~\cite{}. In our case, they allow us
to simply specify in an extensible manner where to insert casts.

Synthetic cast insertion is closer to a traditional type system, as it
produces types from terms in a similar manner. However, instead of having
non algorithmic cases where types are known (for example, in the arguments
to a typed function), the synthetic cast insertion judgment defers to the
analytic cast insertion mechanism with the known type. Importantly for us,
the basic semantics of the static type system does not change between any of
the type systems under consideration, and as a result the synthetic cases
are not changed by any of the systems.

Analytic cast insertion ensures that an expression is of a given type. We use analytic cast insertion when a type is known for an expression and we want to force that expression to be of the correct type, which we do by inserting the appropriate cast. The actual details of analytic cast insertion vary depending on the system under consideration (most notably, the monotonic semantics has a notion of consistency that differs from the other two systems).

\begin{figure}
$\t = \ldots \B {\WType{\Mtype\m\t\t}}$
\caption{Strongscript}
\end{figure}

\begin{figure}
%\input{figures/transtrans}
\caption{Transient}
\end{figure}


\section{Monotonic}

%%%%%%%%%%%%%%%% Monotonic Statics

\begin{figure}[h]
%\input{figures/conssub}
\caption{Consistent Subtyping}
\end{figure}

The key static difference between the monotonic semantics and the other systems we have considered is the consistent subtyping relationship. Traditional subtyping can be thought of as if a value satisfies one type, then it will satisfy any supertype of that type. Consistent subtyping encapsulates both this notion and the new idea of consistency. Consistency for objects means that two types have static type information that does not conflict - e.g. $\Type{\Ftype\f\any}$ could very well be able to replace $\Type{\Ftype\f\C}$, though we are unable to tell statically. Consistency allows us to interchange these types, inserting a cast where required.

Subtype consistency combines the two properties. Subtyping lets us add and remove fields from a type, and consistency allows us to make the type we are going to more or less dynamic. Going by the above intuition, a value of type $\any$ could work with any other type and vice versa, and clearly two identical types are compatible. The most complex case is when we have two class types, both with the same method $\m$, which we resolve by ensuring that $\m$ has parameters and return types that are consistent and continuing on through the rest of the class.

Adding this to our static type system is simple. We just introduce the rule that allows types to be converted via $\stcons{}{}$. The details of how to make the dynamics work with this static addition will be covered later.

\begin{figure}[h]
%\input{figures/monomeet}
\caption{Meet for the monotonic system}
\end{figure}

This idea leads us into the core of the monotonic idea. Under this system, if we have a field of some given type $\t$, we do not know if the value of that field is truly of the expected type (since the class could have been cast to one where that field is $\any$ and the field updated), and therefore have to check the value of $\f$ at every point it is used. The solution used by the monotonic approach is to ensure that if a type is given to a field, then that type is never violated.

Consistency allows us to convert between, for example, $\Type{\Ftype\f\any, \Ftype{\xt{g}}\C}$ and $\Type{\Ftype\f\C, \Ftype{\xt{g}}\any}$, as neither has static typing information that would rule out a value that satisfied the other type. However, if we have a value that satisfied both, we would end up with a type that had neither type exactly - we would have $\Type{\Ftype\f\C, \Ftype{\xt{g}}\C}$. This is the key to the monotonic system - we never throw away any type information away. If, at any point in the program, we have an object with some specialized (e.g. not all $\any$) type, then those type assumptions will never be violated. As a result, we can ensure that no get operation will need to be checked.


\begin{figure}

For every class $\C$ and every $\t$ where $\stcons\C\t$, we can generate a most specific type as $\t' \equiv \meet\C{\t^i}$. We then produce a wrapper class $\refine\C\t$ such that

%\input{figures/monotrans}
\caption{Monotonic translation}
\end{figure}

\begin{figure}
%\input{figures/casts}
\end{figure}


\begin{figure}
%\input{figures/castins}
\end{figure}

%% Example -- please check

%% class A {
%%   fa : B
%%   ma(x : A): B { fa.mb(a) }
%% }
%% class B {
%%   fb : any
%%   mb(x:A):B { this }
%% }
%% class C {}

%% class Ap {
%%   fa : Bp
%%   ma(x : Ap): Bp {...}
%% }
%% class Bp {
%%   fb: C 
%%   ma(x : Ap): Bp {...}
%% }

%% a = new A(new B(new C()))
%% ap = <| Ap |> a

%% class WA {
%%   that : A
%%   fa() : B { that.fa() }
%%   fa(x:B):B { that.fa(x) }
%%   ma(x:B):B { that.ma(x) }
%% }
%% class WB {
%%   that : any
%%   fb() : any { that.fb() }
%%   fb(x:any):any { that.fb(x) }
%%   mb(x:B):B { that.mb(x) }
%% }
%% class WBp {
%%   that : A
%%   ...
