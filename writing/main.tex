\documentclass{sigplanconf}
\usepackage{xspace,hyperref,times,amsmath,xspace,listings,url,subfigure, framed}
\usepackage{graphicx,wrapfig,array,multirow,mathpartir,amsmath,amssymb}

\newcommand{\doi}[1]{doi:~\href{http://dx.doi.org/#1}{\Hurl{#1}}}
 \hypersetup{colorlinks=true,
   linkcolor=black,  citecolor=black,filecolor=magenta, urlcolor=black,
   pdftitle={R}, pdfauthor={Morandat Hill Osvald Vitek},
   pdfkeywords={Dynamic Languages, R, Reflection, Dynamic Analysis}}

\newcommand{\rl}[1]{{{\small{[{\sc #1}]}}}\xspace}
\newcommand{\lang}[1]{#1}% {\sf\scshape#1}\xspace}
\newcommand{\JAVA}{\lang{Java}\xspace}
\newcommand{\CommonLisp}{\lang{CommonLisp}\xspace}
\newcommand{\Java}{\lang{Java}\xspace}
\newcommand{\Scheme}{\lang{Scheme}\xspace}
\newcommand{\JavaScript}{\lang{Java\-Script}\xspace}
\newcommand{\Python}{\lang{Python}\xspace}
\newcommand{\Ruby}{\lang{Ruby}\xspace}
\newcommand{\Groovy}{\lang{Groovy}\xspace}

\newcommand{\NOTE}[3][NOTE]{\marginpar{\textcolor{#2}{\textbf{#1:}\scriptsize\sf#3}}}
\newcommand{\TODO}[2][Unassigned]{\NOTE[#1]{black}{#2}}
\newcommand{\FM}[1]{\NOTE[FM]{blue}{#1}}
\newcommand{\BH}[1]{\NOTE[BH]{magenta}{#1}}
\newcommand{\JV}[1]{\NOTE[JV]{red}{#1}}
\newcommand{\PROOF}[1]{#1}

\newcommand{\NUM}[2][]{#2#1\xspace}
\newcommand{\PC}[1]{#1\%\xspace}

\def\NEEDNUMBER{XXX\xspace}
\def\UrlFont{\fontfamily{cmtt}\selectfont}
\lstset{tabsize=2,columns=flexible,%
	basicstyle=\small\ttfamily,keywordstyle=\bfseries,%
	commentstyle=\rmfamily\itshape,indexstyle=[1]\indexlst,%
	showstringspaces=false,%
	lineskip=1pt,
	showspaces=false,belowcaptionskip=\baselineskip,framexleftmargin=5mm,%
	texcl=true,xleftmargin=15pt, % make room for line numbers
	breaklines=true,
	breakatwhitespace=true,
	escapeinside={(*}{*)},
}
\newcommand{\code}[1]{\lstinline[keywordstyle=]!#1!\xspace}
\newcommand{\etal}{{\em et al.}}
\def\cross{\ding{55}}\def\naive{na\"\i ve }
\newcommand{\app}[1]{{\small\textsf{#1}}}
\newcommand{\IGNORE}[1]{}\newcommand{\hide}[1]{}
\newcommand{\Section}[1]{Sect.~\ref{#1}\xspace}
\newcommand{\Figure}[1]{Fig.~\ref{#1}\xspace}
\newcommand{\figref}[1]{Fig.~\ref{fig:#1}\xspace}
\newcommand{\tabref}[1]{Table~\ref{tab:#1}\xspace}

\newcommand{\kewif}{\texttt{\textbf{if}}}
\newcommand{\kewthen}{\texttt{\textbf{then}}}
\newcommand{\kewelse}{\texttt{\textbf{else}}}
\newcommand{\kewnew}{\texttt{\textbf{new}}}
\newcommand{\kewclass}{\texttt{\textbf{class}}}
\newcommand{\kewimplements}{\texttt{\textbf{implements}}}

\newcommand{\ifabs}[3]{\kewif \; #1 \;\kewthen\; #2 \;\kewelse\; #3}
\newcommand{\opplus}[2]{#1 + #2}
\newcommand{\newclass}[2]{\kewnew\;\texttt{#1}(#2)}

\newcommand{\strt}{\texttt{str}}
\newcommand{\intt}{\texttt{int}}
\newcommand{\anyt}{\texttt{any}}
\newcommand{\vbar}{\;|\;}
\newcommand{\spec}{\vartriangleright}

\newcommand{\opdef}[2]{\framebox[1.1\width]{#1} ~ #2\\}

\input{common}

%\titlerunning{\it Evaluating the Design of R}
%\authorrunning{\it Morandat et al.}

\begin{document}
\title{The Design Space of Gradual Type Systems} 
\authorinfo{Ben and Jan}{Northeastern University}{EMAILS}
\maketitle


\conferenceinfo{CONF 'yy}{Month d--d, 20yy, City, ST, Country}
\copyrightyear{20yy}
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm}
\copyrightdoi{nnnnnnn.nnnnnnn}

\begin{abstract}
The popularity of dynamically typed languages has given rise to a cottage
industry of incremental type systems. These type systems allow developpers
to annotate their code with types and to feel better about the correctness
of their code.  The exact properties that these incremental type systems are
able to guarantee vary greatly from one language to another. This paper
compares some of the main design choices by embedding them into one common
core calculus representative of dynamic object-oriented languages such as
Python, TypeScript or Ruby.

\end{abstract} 

\section{Introduction}

The fundamental property a sound type system provides is the guarantee that an 
expression such as 
\begin{lstlisting}
    x = y.m(z);
\end{lstlisting}
will not ``go wrong''. If the expression passes the typechecker and the
variable \code{x} is declared to be of some type \code{T}, setting aside
issues related to null pointers and non-termination, the result of
\code{m()} will be of type \code{T}.  This is not the case in a dynamic
language where the receiver \code{y} may lack the requested method, or may
expect an argument of a different type, or may return a value that does not
belong to type \code{T}.

For any dynamic language, from the early days of Lisp to more recent times
with JavaScript, there have been attempts to add annotations to document
programmer expectations about the nature of values flowing through their
code.  The motivation for burdening the language with these extra
annotations have been either to provide hints for a just-in-time compiler or
to help programmers catch errors early.

\newcommand{\Opt}[1]{#1$^{?}$\xspace}
\newcommand{\Con}[1]{#1$^{!}$\xspace}
\newcommand{\Pro}[1]{#1$^{()}$\xspace}
\newcommand{\dyn}{$\star$}

In the last decade, the design space for these incremental annotations seems
to have stabilized around three alternatives.  A number of systems offer
\emph{optional types}, \Opt{T},
\cite{PluggableTypes,Bracha93,typescript13,oopsla09} which provide local
guarantees but do not prevent type errors at call boundaries. Other systems
rely on \emph{promised types}, \Pro{T}, these type annotations are
associated to the values that flow through the program and represent a
promise that the value will either behave as if it was of that type, or that
type error will be emitted~\cite{siek14,tf-popl08}.  Lastly, some systems
offer \emph{concrete types} which provide the traditional soundness
guarantees one would expect in a statically typed
language~\cite{thorn,stongscript,csharp}. In addition all dynamic languages
have the type dyn (\dyn) as the default type for all dynamically typed
variables.

The design space of incremental type system is an interesting one as there
are seemingly important trade-offs to be made in three different dimensions:
expressiveness, assurance and performance.  By expressiveness, we mean how
much of the legacy code base can be typed (and at what cost in terms of
changes to the original programs).  By assurance, we mean what kinds of
guarantees does the type system give to programmers. At its weakest, the
type system can be little more than a machine-checked documentation, and at
its strongest it can be equivalent to a sound statically typed language.
Performance here refers to the additional runtime overheads that are caused
by the extra checks that the language must perform to provide the
aforementioned guarantees.

\newcommand{\name}{{\sf Gool}\xspace}

This paper elucidates the difference between different designs by setting
them all in a common context. We have picked a simple class based
object-oriented language, representative of the likes of Python, Ruby,
TypeScript. Our core calculus, named \name for Gradual Object-oriented
Language, is stateful, as mutation introduces additional challenges. \name
is agnostic as to the nature of the subtyping relation (structural or
nominal) as this seems to be an orthogonal design choice.

\section{Related Work}

Typescript~\cite{typescript13} is an extension of Javascript, enabling existing 
Javascript code to be typed without substantial changes. In order to do so, 
Typescript uses an optional type system, only providing type guarantees within 
local code, not across call boundaries. This approach eases the transition from
Javascript to typed code, but the guarantees provided are very weak, only 
ensuring type saftey in local contexts, restricting optimization as well as
limiting the information provided by a type signature.

The example of a concrete type sysetm we are considering in this work is
Strongscript~\cite{stongscript}. Strongscript builds on lambda JS and 
Typescript, strengthening the guarantees provided in the latter by providing
\emph{concrete} types, represented by an excalmation mark. Within Strongscript,
concrete types impose guarantess about the runtime values that they represent, 
a stronger guarantee than that provided by Typescript, while still allowing
programmers the flexibility of the Typescript approach, though with fewer
guarantees.

Another approach is that taken by~\cite{seik-monotonic} (Seik Monotonic)
This approach presents a system that takes a \emph{promised type} approach.
Its novelty comes from a new approach to avoiding expensive and complex
wrappers. Instead of ensuring that the type of references remain consistent
by adding a wrapper, this approach works by ensuring that the type of values in
the heap only get \emph{less} generic.

Within this approach, references that were well-typed previously will always
remain well-typed, as the new type is strictly less generic than the one that
it had at the time that the reference was checked. By doing this, the monotonic
approach can avoid many of the expensive checks that wrapper approaches incur, 
while still providing similar functionality. However, this approach is less
generic than wrapper-based systems, as the monotonic constraint is much stronger
than the more usual well-typed one.

\section{Core Calculus}

\begin{figure}
\syntax

\caption{Abstract Syntax for the Core Calculus}
\end{figure}

The core calculus is a simple object based system, including classes and 
restricted mutability. We have declarations $d$, which act as the high level 
building blocks, types $\tau$, and expressions $e$. This construction is 
similar to the core calculus in StrongScript, though with some major 
modifications.

In our calculus, a class is represented by a \emph{class declaration}, which 
includes the nominal relationships between that class and its parents. Then, we 
represent fields as labels with types, and notate methods as a label, a list 
of typed parameters, a return type, and a method body. This construction models 
many other object systems while remaining fairly trivial.

Our types are modeled after those in StrongScript. In addition to the basic 
types $\intt$ and $\strt$, we have the $\anyt$ type, representing a dynamic 
value, as well as two kinds of class type. $C$ represents a weaker, optional, 
class type with few guarantees. Only finding a $C$ implies very little about 
the eventual value that is recieved at runtime. In contrast, however, $!C$ is 
a concrete type, one with strong static guarantees that will hold at runtime. 

Our expression grammar is fairly simple, with a few interesting components. 
Mutability is expressed our system by altering fields, which are only 
accessible from inside an object. This is expressed in our expression
grammar by having get and set forms only involving labels. 

\section{Examples}


\begin{figure}
\opdef{$\t <: \t'$}{$\t$ is a subtype of $\t'$}
\begin{mathpar}
\inferrule*[lab=SWidth]{
}{\{\bar{\m(\bar{\t_1''}):\t_1'},\bar{\m'(\bar{\t_2''}):\t_2'}\}<: \{\bar{\m(\bar{\t_1''}):\t_1'}\}}

\inferrule*[lab=SDepth]{
	\bar{\t_2 <: \t_1} \\
	\bar{\t_1' <: \t_2'}
}{\{\bar{\m(\bar{\t_1''}):\t_1'}\}<: \{\bar{\m(\bar{\t_2''}):\t_2'}\}}

\inferrule*[lab=STrans]{
  \C <: \xt{D} \\ \xt{D} <: \xt{E}
}{\C <: \xt{E}}
\end{mathpar}
\opdef{$\S;\Gamma\vdash e : \t$}{$e$ has type $\t$ in context $\G$ with heap $\S$}
\begin{mathpar}
\TVar

\TRef

\TInt

\TSub

\TApp

\TIf

\TPlus

\TNew

\TCast
\end{mathpar}
\opdef{$\Gdash e \tlate e' : \t$}{$e$ translates to $e'$ producing type $\t$ in context $\G$}
\opdef{$\CICAST{e}{\t}{e'}$}{$e$ translates to $e'$ ensuring type $\t$ in context $\G$}
\begin{mathpar}
\CICast

\CICallAny

\CICall

\CIIf

\CIPlus

\CIVar

\CINew
\end{mathpar}
\caption{Common Statics}
\end{figure}


\begin{figure}
\opdef{$e,\s \ereduce e',\s'$}{$e$ with heap $\s$ evaluates to $r$ and $\s$ in one step}
\begin{mathpar}
\EFrame

\inferrule*[lab=EFrameError]{ e,\s \ereduce \error,\s'}{F[e],\s \ereduce \error,\s'}

\ENew

\EInv

\EField

\EAssign

\EIfZ

\EIfNZ

\EPlus

\ECastInt

\ECastAny

\inferrule*[lab=ECastError]{ }{ \cast{\t}e,\s \ereduce \error,\s}
\end{mathpar}
\caption{Common Dynamics}
\end{figure}

\begin{figure}

\begin{mathpar}
\inferrule*[lab=WFField]{\G \vdash \t}{\G\vdash\f}

\inferrule*[lab=WFMeth]{\G \vdash \t \\ \bar{\G \vdash \t'} \\ \G,\this:this(\G),\bar{x:\t'} \vdash e : \t}{\G \vdash \m(\bar{x:\t'}):\t = e}

\inferrule*[lab=WFSelfGet]{\f \in fields(\G)}{\G \vdash \f():\t = \xt{this}.\f}

\inferrule*[lab=WFSelfSet]{\f \in fields(\G)}{\G \vdash \f!(\xt{x}:\t):\t = (\xt{this}.\f=\xt{x})}
\end{mathpar}
\caption{Class well-formedness}
\end{figure}


\section{Monotonic Semantics}

\begin{figure}
\opdef{$\tau \sim \tau'$}{$\tau$ is compatible with $\tau'$}
\begin{mathpar}
\inferrule*[lab=CNSym]{ }{\tau \sim \tau}

\inferrule*[lab=CNCons1]{ }{\any \sim \tau}

\inferrule*[lab=CNCons2]{ }{\tau \sim \any}

\inferrule*[lab=CNSub1]{
  \bar{\t_1 \sim \t_2}\\
  \bar{\t_2' \sim \t_2'}\\
  \bar{\t_2'' \sim \t_2''}}{\{\bar{\f_1:\t_1},\bar{\m_1(\t_1''):\t_1'}\} \sim \{\bar{\f_2:\t_2},\bar{\m_2(\t_2''):\t_2'}\}}
\end{mathpar}
\opdef{$\tau \sim \tau'$}{$\tau$ is subtype compatible with $\tau'$}
\begin{mathpar}
\inferrule*[lab=CSSub]{\C <: \xt{D}}{ \C \lesssim \xt{D}}

\inferrule*[lab=CSCons]{\tau \sim \tau'}{\tau \lesssim \tau'}

\inferrule*[lab=CSTrans]{\tau_1 \lesssim \tau_2 \\ \tau_2 \lesssim \tau_3}{\tau_1 \lesssim \tau_3}
\end{mathpar}
\caption{Monotonic operators}
\end{figure}


\begin{figure}
\opdef{$\Gamma\vdash e : \t$}{$e$ has type $\t$ in context $\G$}
\begin{mathpar}
\inferrule*[lab=TClass]{ 
  \bar{\G \vdash \f : \t}\\
  \bar{\G \vdash \MTYPE{\m}{\bar{x:\t''}}{\t'} = e} \\ 
  \f \in \xt{D} \implies \f \in \C\\
  \MTYPE{d}{\bar{x:\t''}}{\t'}\in \xt{D} \implies \MTYPE{d}{\bar{x:\t''}}{\t'} \in \C\\
 }{
  \Gdash \CLASS \C{\xt{D}}{\bar{\f},\bar{\MDEF d{\bar{x:\t''}}{\t'}e}}
  }
\end{mathpar}

\opdef{$\CICAST{e}{\t}{e'}$}{$e$ translates to $e'$ ensuring type $\t$ in context $\G$}
\begin{mathpar}
\inferrule*[lab=CIIDown]{\Gdash e \tlate e' : \xt{D} \\ \C <: \xt{D}}{\CICAST{e}{\C}{\cast{\C}e'}}

\inferrule*[lab=CIIUp]{\Gdash e \tlate e' : \C \\ \C <: \xt{D}}{\CICAST{e}{\xt{D}}{e'}}

\inferrule*[lab=CIICons]{\Gdash e \tlate e' : \t' \\ \t' \lesssim \t \\ \t \neq \t' }{\CICAST{e}{\t}{\cast{\t}e'}}

\inferrule*[lab=CIIId]{\Gdash e \tlate e' : \t}{\CICAST{e}{\t}{e'}}
\end{mathpar}
\opdef{$e,\s \ereduce e',\s'$}{$e$ with heap $\s$ evaluates to $e'$ and $\s$ in one step}
\begin{mathpar}
\inferrule*[lab=ECast]{ \s' = \text{cast}(\s, v, \t) }{ \cast{\t}a,\s \ereduce a,\s'}
\end{mathpar}
\caption{Evaluation rules for the monotonic semantics}
\end{figure}


\begin{figure}
\opdef{$\t_1 \spec \t_2 = \t_3$}{$\tau_1$ specialized with $\tau_2$ produces type $\tau_3$}
\begin{mathpar}
\inferrule*[]{}{\t \spec \t = \t}

\inferrule*[]{}{\t \spec \any = \t}

\inferrule*[]{}{\any \spec \t = \t}

\inferrule*[]{
	\bar{\t_1 \spec \t_2 = \t_3} \\ 
	\bar{\t_1' \spec \t_2' = \t_3'} \\ 
	\bar{\t_1'' \spec \t_2'' = \t_3''}}{
	\{\bar{\f:\t_1},\bar{\f'}, \bar{\m(\bar{\t_1'}):\t_1},\bar{\m'}\} \spec \{\bar{\f:\t_2},\bar{\m(\bar{\t_2''}):\t_2'}\} = \\
	\{\bar{\f:\t_3},\bar{\f'},\bar{\m(\bar{\t_3''}):\t_3'},\bar{\m'}\}}
\end{mathpar}
\opdef{$\sigma' = \text{cast}(\s, v, \t)$}{Casting $v$ in $\s$ to type $\t$ produces heap $\s'$}
\begin{mathpar}
\inferrule*[lab=CClass]{\s[a \is \{\bar{\f = v},\bar{\m(\bar{x}) = e},\bar{\m_o} \B \t\}] \\ 
\t \neq \t \spec \t' \\ 
\bar{\m(\bar{\t_a}):\t_r} \in \t \spec \t'\\
\s' = \s[a \is \\\{\bar{\f = v},\bar{\m'(\bar{x})=e},\bar{\m(\bar{x})=\cast{\t_r}\xt{this}.\m'(\bar{\cast{\t_a}x})},\bar{\m_o} \B \t \spec \t'\}]\\
\f:\t'' \in \t\spec \t' \implies \sigma'' = \text{cast}(\s', v, \t'')}{\text{cast}(\s, a, \t') = \s''}

\inferrule*[lab=CCycle]{\s[a \is \{\bar{\f = v} \B \C\}] \\ \C = \C \spec \xt{D}}{\text{cast}(\s, a, \xt{D}) = \s}

\inferrule*[lab=CInt]{ }{\text{cast}(\s,n,\xt{\int}) = \s}

\inferrule*[lab=CSub]{\s[a \is \{\bar{\f = v} \B \C\}]}{\text{cast}(\s, a, \C) = \s}
\end{mathpar}
\caption{Casting in the monotonic system}
\end{figure}

Define $types(C) = \{A_1,\ldots,A_n\}$ such that 

$classMeet(classMeet(A_1,A_2)\ldots,A_n) = C$

Define $gen(C, B) = classMeet(C,B)$

We apply $classMethod(\m)$ to every method $\m$ in every class $\C$.

classMeet is applied to every string of classes $C_1,\ldots,C_n$ where $C_1 \lesssim C_i$ for $i=2,\ldots,n$. Then, we apply wrapMethods to all classes.

\section{Wrapper Semantics}


\begin{figure}
\opdef{$\Gamma\vdash e : \t$}{$e$ has type $\t$ in context $\G$}
\begin{mathpar}

\inferrule*[lab=TNew]{
  \bar{\Gdash e:\t} \\ 
  \{\ldots \bar{\f} \ldots\} = fields(\C)\\
  typed(\C)
}{
  \Gdash \NEW \C{\bar e}:\C
}

\inferrule*[lab=TTypedClass]{ 
  {\bar{\Gdash \f}}\\
  {\bar{\Gdash \MDEF\m{\bar{x:\t''}}{\t'}e}}
 }{
  \Gdash \CLASS \C{\bar\D}{\bar{\f},\bar{\MDEF\m{\bar{x:\t''}}{\t'}e}}
  }  

\inferrule*[lab=TUntypedClass]{ 
 }{
  \Gdash \CLASS \C{\bar\D}{\bar{\f:\any},\bar{\MDEF\m{\bar{x:\any}}{\any}e}}
  } 
\end{mathpar}
\opdef{$\CICAST{e}{\t}{e'}$}{$e$ translates to $e'$ ensuring type $\t$ in context $\G$}
\begin{mathpar}
\inferrule*[lab=CIIUni]{ }{\CICAST{e}{\t}{e}}
\end{mathpar}
\opdef{$\CICAST{e}{\t}{e'}$}{$e$ translates to $e'$ producing type $\t$ in context $\G$}
\begin{mathpar}
\inferrule*[lab=CTypedClass]{typed(\C)}{\Gdash \NEW \C {\bar v} \tlate \cast{\C}\NEW\C{\bar v} : \any}

\inferrule*[lab=CUntypedClass]{ }{\Gdash \NEW \C {\bar v} \tlate \NEW\C{\bar v} : \any}
\end{mathpar}
\caption{Analytic cast insertion for the wrapper semantics}
\end{figure}


\begin{figure}
\opdef{$\sigma' = \text{cast}(\s, v, \t)$}{Casting $v$ in $\s$ to type $\t$ produces heap $\s'$}
\begin{mathpar}
\inferrule*[lab=ECastRef]{
\s' = \s[a' \is \{\xt{orig} = a \B \xt{\#}\C\}] }{ \cast{\C}a,\s \ereduce a',\s'}
\end{mathpar}
\caption{Evaluation for the wrapper semantics}
\end{figure}

\begin{figure}

\begin{lstlisting}
wrapper(A)
  A = class A {(*@\bar{\f_A:\t_A},\bar{m(\bar{x:\t''_A}):\t'_A = e_A}@*)}
  return class #A {
    (*@\xt{orig}:\xt{A}@*),
    (*@\xt{orig():\xt{A} = this.orig}@*),
    (*@$\bar{m(\bar{x:\any}):\any = \cast{\t'_A}\xt{this.orig()}.m(\bar{\cast{\t''_A}v})}$@*)
  }
\end{lstlisting}

For every typed class $\xt{A}$, we run $wrapper(\xt{A})$ to get a $\xt{\#A}$ that ensures the type invariants on A.
\caption{Wrapper generation for wrapper semantics}
\end{figure}

\section{Optional Semantics}

\begin{figure}

\opdef{$\t <: \t'$}{$\t$ is a subtype of $\t'$}
\begin{mathpar}
\inferrule*[lab=SubRefl]{ }{ \t <: \t }

\inferrule*[lab=SubClass]{\class~\C~\implements~\D}{ \xt{!C} <: \xt{!D} }

\inferrule*[lab=SubWeak]{ \xt{!C} <: \xt{!D} }{ \C <: \xt{D}}

\inferrule*[lab=SubInj]{ }{ \xt{!C} <: \C}
\end{mathpar}
\opdef{$\Gamma\vdash e : \t$}{$e$ has type $\t$ in context $\G$}
\begin{mathpar}
\inferrule*[lab=TCInj]{\Gamma \vdash e : \tau' \\ \tau' = \any \vee \tau = \any \vee \tau' <: \tau }{ \Gamma \vdash e : \tau}

\inferrule*[right=TClass]{ 
  \bar{\G,\this:\C,\bar{x:\t''} \vdash e:\t'}
 }{
  \Gdash \CLASS \C{\bar\D}{\bar{\f},\bar{\MDEF\m{\bar{x:\t''}}{\t'}e}}
  }
\end{mathpar}
\opdef{$\CICAST{e}{\t}{e'}$}{$e$ translates to $e'$ ensuring type $\t$ in context $\G$}
\begin{mathpar}
\inferrule*[lab=CIIInsert]{\Gdash e \tlate e' : \any }{\CICAST{e}{\t}{\cast{\t}e'}}

\inferrule*[lab=CIISub]{\Gdash e \tlate e' : \xt{D} \\ \xt{D} <: \C}{\CICAST{e}{\C}{e'}}

\inferrule*[lab=CIISuper]{\Gdash e \tlate e' : \xt{D} \\ \C <: \xt{D}}{\CICAST{\cast{\C}e}{\C}{e'}}

\inferrule*[lab=CIIAny]{\Gdash e \tlate e' : \tau}{\CICAST{e}{\any}{e'}}
\end{mathpar}

\caption{Optional typing statics}
\end{figure}

\begin{figure}
\opdef{$\sigma' = \text{cast}(\s, v, \t)$}{Casting $v$ in $\s$ to type $\t$ produces heap $\s'$}
\begin{mathpar}
\inferrule*[lab=ECastClass]{ \s[a\is\{\ldots\B\xt{D}\}] \\ \xt{D} <: \C }{ \cast{\C}a,\s \ereduce a,\s}
\end{mathpar}

\caption{Optional typing evaluation}
\end{figure}

\section{Conclusion}

\bibliographystyle{plain}

\bibliography{bib/compactdoi}
\end{document}


