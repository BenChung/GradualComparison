\documentclass[preprint]{sigplanconf}
\usepackage{xspace,listings,url,subfigure,framed,amssymb,mathpartir,hyperref,
            stmaryrd % double brackets llbracket
}
\newcommand{\rn}[1]{#1}
\newcommand{\doi}[1]{doi:~\href{http://dx.doi.org/#1}{\Hurl{#1}}}



\conferenceinfo{CONF 'yy}{Month d--d, 20yy, City, ST, Country}
\copyrightyear{20yy}
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm}
\copyrightdoi{nnnnnnn.nnnnnnn}

%%% Metavariables %%%%%%%%%%%%%%%%%%%
\newcommand{\fd}{\M{\xt{fd}}}
\newcommand{\md}{\M{\xt{md}}}
\newcommand{\mt}{\M{\xt{mt}}}
\newcommand{\m}{\M{\xt{m}}}
\newcommand{\e}{\M{\xt{e}}}
\newcommand{\n}{\M{\xt{n}}}
\renewcommand{\d}{\M{\xt{d}}}
\renewcommand{\r}{\M{\xt{r}}}
\newcommand{\f}{\M{\xt{f}}}
\newcommand{\fb}{\M{\xt{f!}}}
\newcommand{\x}{\M{\xt{x}}}
\renewcommand{\t}{\M{\xt{t}}}
\renewcommand{\c}{\M{\xt{c}}}
\newcommand{\C}{\M{\xt{C}}}
\newcommand{\D}{\M{\xt{D}}}
\newcommand{\this}{\M{\xt{this}}}
\newcommand{\err}{\M{\bt{err}}}
\renewcommand{\d}{\M{\xt{d}}}
\newcommand{\s}{\M{\sigma}}
\newcommand{\fv}{\M{\xt{fv}}}
\renewcommand{\a}{\M{\xt a}}
\newcommand{\F}{\M{\xt F}}
\newcommand{\T}{\M{\xt T}}
\newcommand{\tp}[1]{\M{ \t_{#1} }}
\newcommand{\ep}[1]{\M{ \e_{#1} }}
\newcommand{\ap}[1]{\M{ \a_{#1} }}
\renewcommand{\mp}[1]{\M{ \m_{#1} }}
\renewcommand{\sp}[1]{\M{ \s_{#1} }}
\newcommand{\none}{\M{\cdot}}
%% Keywords %%%%%%%%%%%%%%%%%%
\newcommand{\new}{\M{\bt{new}}}
\newcommand{\class}{\M{\bt{class}}}
%% Expressions %%%%%%%%%%%%%%%%%%%%
\newcommand{\Get}[2]{\M{#1.#2}}
\newcommand{\Set}[3]{\M{#1.#2:=#3}}
\newcommand{\Call}[3]{\M{#1.#2(#3)}}
\newcommand{\New}[2]{\M{\new\;#1({#2})}}
\newcommand{\Cast}[2]{\M{\langle{#1}\rangle{#2}}}
%% Types %%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\any}{\M{\star}}
\newcommand{\Type}[1]{\M{\{ #1 \}}}
\newcommand{\HT}[2]{\M{{#1}\!:{#2}}}
%% Classes %%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\Mdef}[5]{\M{ \HT { #1( \b{\HT{#2}{#3}})}{#4}={#5}}}
\newcommand{\SMdef}[5]{\M{ \HT { #1!( \HT{#2}{#3})}{#4}= {#5}}}
\newcommand{\GMdef}[3]{\M{ \HT { #1()}{#2}={#3}}}
\newcommand{\Ftype}[2]{\M{ \HT{#1}{#2} }}
\newcommand{\Fdef}[3]{\M{ \HT{#1}{#2}={#3} }}
\newcommand{\Mtype}[3]{\M{ \HT { #1( #2 )}{#3}}}
\newcommand{\Class}[3]{\M{\bt{class}\;#1\{ #2 ~ #3 \}}}
%%% Dynamics %%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\is}{\M{\mapsto}}
\newcommand{\Obj}[3]{ \M{\{ #1 \}^{#2}_{#3}}}
\newcommand{\Heap}[2]{\M{ #1[ #2 ] }}
%% Formatting %%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\Alt}[1]{ &\B #1 \\}
\newcommand{\B}{\M{~|~}}
\newcommand{\M}[1]{\ensuremath{#1}\xspace}
\newcommand{\xt}[1]{{\sf{#1}}\xspace}
\newcommand{\bt}[1]{\xt{\bf #1}}
\renewcommand{\b}[1]{\M{\overline{#1}}}
\newcommand{\opdef}[2]{\framebox[1.1\width]{#1} ~ #2\\}

\newcommand{\IRule}[3]{\inferrule*[lab={\tiny #1}]{#2}{#3}}
%\newcommand{\IRule}[3]{\inferrule{#2}{#3}}    %% No label
\newcommand{\CondRule}[3]{ #3 & {if} #2 \\}
\newcommand{\NoCondRule}[2]{ #2 &       \\}
\newcommand{\Reduce}[4]{\M{ #1~#2 \rightarrow #3~#4}}
\newcommand{\ReduceA}[4]{\M{ #1 ~ #2 } &  \M { \rightarrow #3 ~ #4}}
\newcommand{\inc}{\M{\in}}
\newcommand{\Update}[3]{\M{#1[ #2 := #3]}}
\newcommand{\Bind}[2]{\M{#1 \is #2}}
\newcommand{\NotSub}{\M{\not<:}}
\newcommand{\Sub}{\M{<:}}
\newcommand{\classofis}[2]{\M{\xt{classof}(#1)=#2}}
\newcommand{\typeofis}[2]{\M{\xt{typeof}(#1)=#2}}
\newcommand{\classof}[1]{\M{\xt{classof}(#1)}}
\newcommand{\typeof}[1]{\M{\xt{typeof}(#1)}}
\newcommand{\Sel}[2]{\M{#1(#2)}}

\newcommand{\EnvType}[3]{ \M{#1 \vdash #2 : #3}}
\newcommand{\HasType}[3]{ \M{#1 (#2) = #3}}
\newcommand{\E}{\M{\Gamma}}
\newcommand{\Es}{\E ~\s}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\title{Designing Gradual Types for Objects
\vspace{-1cm}} 
\authorinfo{}{}{} % Annon : Benjamin Chung, Jan Vitek}{Northeastern University}{}
\maketitle

\begin{abstract}
The popularity of dynamically typed languages has given rise to a cottage
industry of type systems that provide various degrees of assurance
while allowing some code to remain free of type annotations. 
The motivation underlying these new type systems is that they give
programmers a way to incrementally migrate a code base from untyped
to typed.  It is becoming increasingly clear that the design of these
type systems must carefully consider issues such expressiveness of the 
annotation language, granularity of type regions, and performance overheads
of any associated run-time checks.  This paper focuses on gradual types for 
object-oriented languages and attempts to explain some of the key design 
dimensions and trade-offs of three implemented gradual types systems.
This is achieved by embedding the different design into a core calculus
that is broadly representative of dynamic languages such as Python, JavaScript
and Ruby.
\end{abstract} 

\section{Introduction}
Well-typed programs go wrong every day. Short of programming with a proof
assistant, our programs will remain replete with errors that lead to
undesirable outcomes.  The question that face language designers is what
classes of errors are frequent enough that it makes sense to try to catch in
the programming language itself, and how much linguistic machinery to expose
to end-users for that purpose.  At one end of the spectrum, some of the most
popular languages of the day rely solely on dynamic checks to catch errors
as the program runs. Towards the other end, statically typed languages
expose a set of type annotations that programmers have to use in their code
and, in return, these languages ensure that many errors are ruled entirely.

Gradual typing attempts to merge both of these world-views by allowing
developers to add annotations in an incremental manner, with the promise of
rewards in error prevention commensurate to the effort invested in selecting
where to put annotations. Types have other benefits, by making programmer
intent explicit, they play the role of simple machine-checked documentation,
and they also have the potential of providing useful information for
the compiler to generate efficient code.

This paper explores the design space of gradual type systems for
object-oriented languages. We aim to expose the main forces influencing the
design of practical systems, and to provide advice for the next generation
of gradually typed languages. To this end, we have designed a minimialistic
object-based language that supports statically and dynamically typed code
fragments. On top of this common core, we then build models of several
practical gradual type systems and illustrate their differences in terms of
catching errors. While our work has a formal flavor, we are careful to
discuss the practical implications of different choices in the light of
our experience with the implementation of several gradually typed systems.

The fundamental property that a type system object-based language should
guarantee is that an expression of the form 
\vspace{-1mm}\[ \xt{x.m(y)} \]

\vspace{-1mm}\noindent does not result in, to borrow Smalltalk terminology,
a \emph{message not understood} error.  That is to say, method \xt{m} exists
in the object bound to variable \x. Many static type systems only
provide a partial guarantee as they make an exception for \xt{null} or
\xt{undefined} references; the call may fail as the test whether \x is
bound to an object is deferred to execution.

At the heart of the design of a gradual type system lies the choice of
definition of \emph{soundness} and the static and dynamic mechanisms
employed to enforce it. The literature is ripe with proposals with subtly
different properties and mechanisms.  One key distinction is what it means
for a variable \x to be of type \T. In a traditional statically typed
language, \x will refer to either an instance of the class denoted by \T or
one of its sub-classes; we say that \T is a \emph{concrete type}. In some
proposals, a variable \x of type \T can refer to an instance of any class,
in this case we say that \T is \emph{unconstrained type}. Lastly, in some
systems \x is allowed to refer to any value but the language implementation
will ensure that the value behaves as if it was of type \T, we call this a
\emph{promised type}.

While statically typed languages such as Scala only offer concrete types and
dynamically typed languages like Python have a single, implicit,
unconstrained type, gradually typed language have experimented with various
combinations.  C\# has concrete typed but also support a single
unconstrained type \xt{dyn}~\cite{Bierman10}. Thorn~\cite{popl10} and
StrongScript~\cite{ecoop15} both support concrete types as well as
unconstrained types. Languages such as Facebook's Hack and
TypeScript~\cite{typescript13} support only unconstrained types.  Finally
Reticulated Python~\cite{siek14} and Typed Racket~\cite{tf-dls06} support
promised types.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{A Common Core for Gradually Typed Objects}



A common core calculus is used to compare the various gradual type
systems. This common core is an imperative object-based system with
structural subtyping. Figure~\ref{syn} summarize the syntax of this small
language where \x ranges over variables, \f ranges over field names, \m can
be either a plain method name \d, a field getter \f, or a field setter \fb,
\C and \D range over class names. We use the overbar notation to denote a
possibly empty sequence. In the common core, a class is defined as by a set
of fields, \b\f, with distinct names and a set of method definitions,
\b\m. An instance of class is constructed by the expression \New\C{\b\e} where
each argument is used to initialize the corresponding field. Fields are
encapsulated and can only be accessed and updated in the corresponding
getter and setter from the \this variable.  Expressions include variable
access, field access and update, method invocation, object creation, and
type casts.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%% SYNTAX %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[!h]\begin{minipage}{3cm}\begin{tabular}{l@{~~~}l}
\e &::=  \x \\
   \Alt{ \Get\e\f }
   \Alt{ \Set\e\f\e }
   \Alt{ \Call\e\m{\b\e} }
   \Alt{ \New\C{\b\e} }
   \Alt{ \Cast\t\e }
\end{tabular}\end{minipage}\begin{minipage}{3cm}\begin{tabular}{l@{~~~}l}
\fd &::= 
    \Ftype\f\t   \\
\md &::=
    \Mdef\m\x\t\t\e \\
\c &::= \Class \C {\b{\fd}}{\b{\md} } \\
\mt &::= \Mtype\m\t\t\\
\t &::= ~ \any \\
   \Alt{ \Type{  \b{ \mt } } }
\end{tabular}\end{minipage}
\caption{Abstract Syntax for the Core Calculus}\label{syn}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%% END OF SYNTAX %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Our types are structural and only account for the methods in an object's
interface. For type annotations, we use the name of classes, ranged over by
\C and \D, as shorthand for the set of methods defined in the respective
classes.


The dynamic semantics evaluates expression extended with object references,
denoted \a, and errors, denoted \err, together with a heap \s mapping
references to object values. Object values contain all fields, methods, a
type, and a class; they are denoted \Obj{\b{\Fdef\f\t\a}}{\tp 1}{\C}. The
class is used for locating methods and the type is used for type casts. The
need for keeping them separate will become clear later.

The semantics uses evaluation context \M{\F[\e]}.

Selecting an object from the heap is written \Sel\s\a, while a heap is
extended with a new object by \Heap{\s}{\Bind{\a}{\Obj{\dots}\t\C}}.


For an object reference \a, such that \M{\Sel\s\a=\Obj{\dots}\t\C}, we have 
\classofis{\Sel\s\a}\C and \typeofis{\Sel\s\a}\t.

We use the notation \Mdef\m\x\t\t \inc\C to select a method in a class
definition and \Fdef\f\t\a\inc\Obj{\dots}\t\C to express the selection of a
field. Lastly a field of an object can be update with the notation
\Update{\Obj{\dots}\t\C}\f\a.


\subsection{Dynamic Semantics}

We use a typical small-step operational semantics with a heap. Each step steps an expression and a heap to a result and a new heap, where a result can either be a new expression or an error. Errors halt execution, and can be lifted through execution frames.

\subsection{Typing}

As an object-oriented calculus, our type system has subtyping. We use a structural subtyping mechanism which supports with, depth, and reordering. 

Each class in our system must be well-formed, as described in Figure 4. Each method must typecheck against the named arguments, producing the result type. Our type system has two major issues: it does not provide any guarantees about the type of the arguments to an untyped method, and it does not mention getters and setters at all.

To fill these holes, we use class translation, which performs 2 major tasks:
\begin{itemize}
\item Generating accessor methods, to enable user code to retreive and modify field values.
\item Generating wrapper methods, that take all $\*$ arguments and use casts to ensure that the values that they were passed are correct. 
\end{itemize}

% TODOS:
% $ should not be a valid character in a method name <- explain in text
% c translates to c with $ <- explain in text
% Figure 2 sigma <- not sure?

%%%%%%%%%%%%%%%%%%%%%%%%%%% DYNAMIC SEMANTICS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure*}
\begin{tabular}{l|@{~~~~~~~~}l}
\begin{minipage}{11cm}
\opdef{\Reduce{\ep 1}{\sp 1}{\ep 2}{\sp 2}}{\ep 1 with heap \sp 1 evaluates to \ep 2 and \sp 2 in a step}

\begin{tabular}{@{}l@{}l@{~}l@{~}l}
\CondRule{E1}{ 
  \Reduce {\ep 1}{\sp 1}{\ep 2}{\sp 2}
}{
  \ReduceA {\F[\ep 1]}{\sp 1}{\F[\ep 2]}{\sp 2}
}
\CondRule{E2}{
     \sp 2 = \Heap{\sp 1}{ \Bind{\ap 1}{\Obj{\b{\Fdef\f\t\a}}\C\C\}}}
}{ 
    \ReduceA{ \New\C{\b\a} }{\sp 1}{\ap 1}{\sp 2}
}
\CondRule{E3}{
     \Mdef\m\x{\tp 1}{\tp 2}\e\inc \classof{\Sel\s\a}
}{
   \ReduceA{\Call\a\m{\b{\ap 1}}}\s{[\a/\this~\b{{\ap 1}/\x}]\e}\s
}

\CondRule{E3}{
     \Mdef\m\x{\tp 1}{\tp 2}\e\M{\not\in} \classof{\Sel\s\a}
}{
   \ReduceA{\Call\a\m{\b{\ap 1}}}\s{\err}\s
}

\CondRule{E3}{ 
     \Fdef\f\t{\ap 1}\inc \Sel\s\a
}{
  \ReduceA{\Get\a\f}{\s}{\ap 1}{\s}
}
\CondRule{E4}{
     \sp 2 = \Heap{\sp 1}{\Bind\a{\Update{\Sel{\sp 1}\a}\f {\ap 1}}}
}{
     \ReduceA{\Set\a\f{\ap 1}}{\sp 1}{\ap 1}{\sp 2}
}
\NoCondRule{E5}
{ 
   \ReduceA{ \Cast\any\a}\s \a\s
}
\CondRule{E6}{
  \typeof{\Sel\s\a} \Sub \tp 1
}{ 
    \ReduceA{\Cast{\tp 1}\a}\s\a\s
}
\CondRule{E7}{
  \typeof{\Sel\s\a} \NotSub \tp 1
}{ 
    \ReduceA{\Cast{\tp 1}\a}\s\err\s
}
\CondRule{E8}{
    \Reduce\e{\sp 1}\err{\sp 2}
}{
    \ReduceA{\F[\e]}{\sp1}\err{\sp 2}
}
\end{tabular}\end{minipage}&
%%%%%%%%%%%%%%%%%%% CONTEXTS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{minipage}{4cm}\begin{tabular}{l@{~~}l}
\fv &::= \Fdef\f\t\a \\
\s &::= \none \\
\Alt{  \Heap\s{\Bind\a{\Obj{\b{\fv}}{\t}{\C}}} } 
\F &::=    \Get\square\f \\
   \Alt{    \Set\square\f\e}
   \Alt{    \Set\a\f\square    }
   \Alt{    \Call\square\m\e}
   \Alt{    \Call\a\m{\b\a\,\square\,\b\e}}
    \Alt{   \Cast\t\square }
   \Alt{   \New\C{\b \a\,\square\,\b\e}}
\end{tabular}
\end{minipage}\end{tabular}
\caption{Common Core Calculus Dynamic Semantics.}
\end{figure*}





%%%%%%%%%%%%%%%%%%%%%%%% SUBTYPING %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}
\opdef{\tp 1 \Sub \tp 2 }{\tp 1 is a subtype of \tp 2}
\begin{mathpar}
\IRule{S1}{}{\t\Sub\t}

\IRule{S2}{}{\t \Sub \Type{} }

\IRule{S3}{
    \t \Sub \Type{\b{ \mt } } \\
     \Mtype\m{\b{\tp3}}{\tp4} \inc \t \\
    \tp2 \Sub \tp4 \\    
    \b{\tp3 \Sub \tp1}
}{
   \t \Sub \Type{\Mtype\m{\b{\tp1}}{\tp2} ~ \b{\mt} \, } 
}
\end{mathpar}
\caption{Subtyping}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% WELLFORMEDNESS %%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}
\opdef{\EnvType\E\e\t}{\e has type \t in environment \E}
\begin{mathpar}
\IRule{W1}{
    \HasType\E\x\t
 }{
   \EnvType\E\x\t
}

\IRule{W2}{
   \EnvType\E\e{\tp 1} \\ \tp 1 \Sub \t
 }{
   \EnvType\E\e\t 
}   

\IRule{W3}{
   \EnvType\E\e\any \\ \b{\EnvType\E{\ep1}\t }
}{
   \EnvType\E{\Call\e\m{\b{\ep1}}}\any
}

\IRule{W4}{
   \EnvType\E\e{\tp1} \\ \Mtype\m{\b{\tp2}}\t\inc \tp1  \\  \b{\EnvType\E{\ep1}{\tp 2}}
}{
    \EnvType\E{\Call\e\m{\b{\ep1}}}\t
}    

\IRule{W5}{
  \b{\EnvType\E\e\t} \\ 
  \Class \C {\b{\Ftype\f\t}} {\b{\md}}
}{
  \EnvType\E{\New\C{\b\e}}\C
}

\IRule{W6}{
  \EnvType\E\e{\tp1}
}{
   \EnvType\E{\Cast\t\e}\t
}

\IRule{W7}{
	\M{\forall} \Mdef\m\x{\tp1}{\tp2}\e \inc \b\md ~\B~
       \EnvType{\this:\C,\b{\x:\tp1}}\e{\tp2}
}{ 
	\Class \C {\b{\fd}} {\b{\md}}  ~~ WF
}
\end{mathpar}
\caption{Class well-formedness}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%% WELLFORMDNESS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\TransClass}[2]{\M{ #1 \hookrightarrow #2 }}
\newcommand{\TransExp}[4]{\M{ #1 \vdash #2 \hookrightarrow #3 : #4 }}
\newcommand{\mdp}[1]{\M{\md_{#1}}}
\newcommand{\setter}[1]{\M{\llbracket #1  \rrbracket}_{\xt{set}}}
\newcommand{\getter}[1]{\M{\llbracket #1  \rrbracket_{\xt{get}}}}
\newcommand{\dynamic}[1]{\M{\llbracket #1  \rrbracket_{\xt{dyn}}}}
\newcommand{\invoke}[1]{\M{\llbracket #1 \rrbracket_{\xt{inv}}}}
\newcommand{\Dyn}[1]{\M{#1^{\any} }}
%%%%%%%%%%%%%%%%%%%%%%%%% CLASS TRANSLATION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}
\opdef{\EnvType\E\e\t}{\e has type \t in environment \E}
\begin{mathpar}
\IRule{}{
      \TransExp\E\e{\ep 2}\any\\
     \b{\TransExp\E{\ep 1}{\ep 3}{\tp 3}}
 }{
    \TransExp\E{\Call\e\m{\b{\ep 1}}} {\Call{\ep 2}{\Dyn{\m}}{\b{\ep 3}}} \any
}   

\IRule{}{
   \EnvType\E{\ep 1}\any \\ \b{\EnvType\E{\ep 2}\t }
}{
   \EnvType\E{\Call{\ep 1}\m{\b{\ep 2}}}\any
}

\IRule{}{
  \TransExp{\this:\C,\x:\tp1}\e{\ep1}{\tp2}
}{
   \invoke{\Mdef\d\x\t{\tp1}\e  } \equiv  \Mdef\d\x\t{\tp1}{\ep1}
}    

\IRule{}{
}{
   \dynamic{\Mdef\d\x\t{\tp1}\e} \equiv  \Mdef{\Dyn\d}\x\any\any{ \Cast\any{\Call\this\d{\b{\Cast\t\x }} }}
}

\IRule{}{
}{
  \getter{\Ftype\f\t} \equiv   \GMdef\m\t{\Get\this\f}
}
 
\IRule{}{
}{
  \setter{\Ftype\f\t} \equiv   \SMdef\m\x\t\t{\Set\this\f\x}
}

\newcommand{\union}{\M{\cup}}
\IRule{}{
 \b{ \mdp1} \equiv \b{\setter\fd} ~~ \b{\getter\fd} \\  \b{\mdp2} \equiv \b{\dynamic{\mdp1}} ~~ \b{\invoke{\mdp1}}
}{ 
	\TransClass { \Class \C {\b{\fd}} {\b{\md}} }{  \Class \C {\b{\fd}} {\b{\mdp2}} }
}
\end{mathpar}
\caption{Translations}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection{Type soundness:}
Theorem 1: Type translation. If $\EnvType\E\e\t$ and $\TransExp\E\e{\e'}\t$ then $\EnvType{\E ~ \cdot}{\e'}\t$.

Theorem 2: Progress. If $\EnvType{\Es}{\e}{\t}$ then $\s,\e \rightarrow \s',\e'$ for $\e'$ expression or $\e' ~ \err$.

Theorem 3: Preservation. If $\s,\e \rightarrow \s',\e'$ and $\EnvType{\Es}{\e}{\t}$ then $\EnvType{\E~\s'}{\e'}{\t}$.

For a list of classes $\bar{\c}$ such that $\b{\c ~~ WF}$ and an expression $e$ such that $\EnvType\cdot\e\t$ and $\b{\TransClass\c{\c'}}$, we have $\cdot~e \rightarrow^* \sigma~r$ (against $\b{\c'}$) where $r$ is either a value or $\err$.

\newcommand{\casts}[1]{\llbracket #1 \rrbracket_{\xt{casts}}}
\newcommand{\fcast}[1]{\M{\llbracket #1 \rrbracket_{\xt{force}}}}
\newcommand{\wrapper}[1]{\M{\llbracket #1  \rrbracket}_{\xt{wrap}}}
\begin{figure}
\begin{mathpar}
\IRule{}{ }{
	\wrapper{\Mtype\m{\b{\tp1}}{\tp2}} \equiv \Mdef\m{x}{\any}{\any}{\Cast{\any}{\xt{this}.\xt{orig}.\m(\b{\Cast{\tp1}x})}}
}

\IRule{}{
	\b{\md=\wrapper{\mt}}
}{
	\wrapper{\{\b{\mt}\}} \equiv \Class\C{~\xt{orig}:\t,\b{\md}}
}

\IRule{}{
      \TransExp\E\e{\ep 2}\any\\
     \b{\TransExp\E{\ep 1}{\ep 3}{\tp 3}} \\
     \b{\tp 4 \equiv \wrapper{\tp 3}}
 }{
    \TransExp\E{\Call\e\m{\b{\ep 1}}} {\Call{\ep 2}{\m}{\b{\New{\tp 4}{\ep 3}}}} \any
}   

\IRule{}{
 \b{ \mdp1} \equiv \b{\setter\fd} ~~ \b{\getter\fd} \\  \b{\mdp2} \equiv \b{\fcast{\mdp1}}
}{ 
	\TransClass { \Class \C {\b{\fd}} {\b{\md}} }{  \Class \C {\b{\fd}} {\b{\mdp2}} }
}

\IRule{TRW1}{
	\M{\forall} \Mdef\m\x{\tp1}{\tp2}\e \inc \b\md ~\B~ \b{\tp1 \equiv \any} \wedge \tp2 \equiv \any \\ \wedge ~ \casts{\e} \cup \{\any\} = \{\any\} \wedge
   	\EnvType{\this:\C,\b{\x:\any}}\e{\any}
}{ 
	\Class \C {\b{\fd}} {\b{\md}}  ~~ WF
}

\IRule{TRW2}{
	\M{\forall} \Mdef\m\x{\tp1}{\tp2}\e \inc \b\md ~\B~ \b{\tp1 \not\equiv \any} \wedge \tp2 \not\equiv \any \\\wedge~ \casts{\e} \cap \{\any\} = \emptyset \wedge
       \EnvType{\this:\C,\b{\x:\tp1}}\e{\tp2}
}{ 
	\Class \C {\b{\fd}} {\b{\md}}  ~~ WF
}
\end{mathpar}
\caption{Class well-formedness for Typed Racket}
\end{figure}


%%%%%%%%%%%%%%%% Monotonic Statics
\newcommand{\stcons}[2]{#1\lesssim #2}

\begin{figure}
\begin{mathpar}
\IRule{CS1}{ }{\stcons{\t}{\t}}

\IRule{CS2}{ }{\stcons{\any}{\t}}

\IRule{CS3}{ }{\stcons{\t}{\any}}

\IRule{CS4}{ \tp 1 \Sub \tp 2 }{\stcons{\tp 1}{\tp 2}}

\IRule{CS5}{
	\stcons{\tp3}{\tp1} \\
    \stcons{\tp2}{\tp4} \\
    \stcons{\Type{\b{\md_1} ~ \b{\md_2}}}{\Type{\b{\md_3} ~ \b{\md_4}}}
}{\stcons{\Type{\b{\md_1} ~ \Mtype\m{\tp1}{\tp2}~ \b{\md_2}}}{\Type{\b{\md_3} ~ \Mtype\m{\tp3}{\tp4} ~ \b{\md_4}}}}
\end{mathpar}
\caption{Consistent Subtyping}
\end{figure}

\newcommand{\meet}[2]{#1\sqcap #2}
\newcommand{\refine}[2]{#1\vartriangleright #2}
\begin{figure}
\begin{mathpar}
\IRule{M1}{ }{\meet{\t}{\any} \equiv \t}

\IRule{M2}{ }{\meet{\any}{\t} \equiv \t}

\IRule{M3}{ }{\meet{\t}{\t} \equiv \t}

\IRule{M4}{
	\b{\meet{\tp3}{\tp1}  \equiv \tp5} \\
    \meet{\tp2}{\tp4} \equiv \tp6\\
    \meet{\Type{\b{\md_1}}}{\Type{\b{\md_2}}} \equiv \Type{\b{\md_3}} 
}{\meet{\Type{\Mtype\m{\b{\tp1}}{\tp2}~ \b{\md_1}}}{\Type{\Mtype\m{\b{\tp5}}{\tp6} ~ \b{\md_3}}}}
\end{mathpar}
\caption{Meet for the monotonic system}
\end{figure}

\begin{figure}
\begin{mathpar}
\IRule{M1}{\EnvType\E\e{\tp2} \\ \stcons{\tp2}{\tp1} }{\EnvType\E\e{\tp1}}
\end{mathpar}
\caption{Monotonic typing}
\end{figure}


\newcommand{\GenCast}[4]{#1 \vdash #2 \hookrightarrow #3 \Rightarrow #4}
\newcommand{\AnaCast}[4]{#1 \vdash #2 \rightsquigarrow #3 \Leftarrow #4}
\begin{figure}
\begin{mathpar}
\IRule{A1}{\HasType\E\x\t}{\GenCast\E\x\x\t}

\IRule{A4}{
	\GenCast{\E}{\e_1}{\e_2}{\t_1} \\
	\Mtype\m{\b{\tp 2}}{\tp 3} \inc \t_1\\
	\b{\AnaCast{\E}{\e_3}{\e_4}{\tp 2}} \\
}{
	\GenCast{\E}{\Call{\e_1}\m{\b{\e_2}}}{\Call{\e_3}{\m}{\b{\e_4}}}{\tp 3}
}

\IRule{A5}{
	\GenCast{\E}{\e_1}{\e_1'}{\any} \\
	\b{\AnaCast{\E}{\e_2}{\e_2'}{\any}} \\
}{
	\GenCast{\E}{\Call{\e_1}\m{\b{\e_2}}}{\Call{\e_1'}{\Dyn\m}{\b{\e_2'}}}{\any}
}

\IRule{A6}{
  \b{\AnaCast\E{\e_1}{\e_2}\t} \\ 
  \Class \C {\b{\Ftype\f\t}} {\b{\md}}
  }{\GenCast{\E}{\New\C{\b{\e_1}}}{\New\C{\b{\e_2}}}{\C}}

\IRule{A7}{
	\GenCast{\E}{\e_1}{\e_2}{\t_2}
}{\GenCast{\E}{\Cast{\tp 1}{\e_1}}{\Cast{\t_1}{\e_2}}{\tp 1}}
\end{mathpar}
\caption{Synthetic cast insertion}
\end{figure}

\begin{figure}
\begin{mathpar}
\IRule{AA1}{\GenCast{\E}{\ep1}{\ep2}{\t}}{\AnaCast\E{\ep1}{\ep2}\t}

\IRule{AA2}{\GenCast{\E}{\ep1}{\ep2}{\tp 2} \\ {\tp2} \Sub {\tp1}}{\AnaCast\E{\ep1}{\ep2}{\tp1}}

\IRule{AA3}{\GenCast{\E}{\ep1}{\ep2}{\tp 2} \\ \stcons{\tp2}{\tp1}}{\AnaCast\E{\ep1}{\Cast{\tp1}{\ep2}}{\tp1}}

\IRule{AA4}{
	\AnaCast{\E}{\e_1}{\e_1'}{\Type{\Mtype\m{\b{\tp2}}{\tp1}}} \\
	\b{\GenCast{\E}{\e_2}{\e_2'}{\tp2}} \\
}{
	\AnaCast{\E}{\Call{\e_1}\m{\b{\e_2}}}{\Call{\e_1'}{\m}{\b{\e_2'}}}{\tp1}
}
\end{mathpar}
\caption{Analytic cast insertion}
\end{figure}


\newcommand{\inscast}[1]{\M{\llbracket #1 \rrbracket_{\xt{ins}}}}
\newcommand{\adapt}[1]{\M{\llbracket #1 \rrbracket_{\xt{adapt}}}}
\begin{figure}

Index every type $\t$ in the source of the program with an index $i$ (denoted $\t^i$). Then, for every class $\C$ and every $i$ where $\stcons\c{\t^i}$, we can generate a most specific type as $\t' \equiv \meet\C{\t^i}$. We then produce a wrapper class $\C^i$ such that
\begin{mathpar}
\IRule{}{
\Mtype\m{\b{\tp3}}{\tp4} \in \t
}{
\adapt{\Mdef\m\x{\tp1}{\tp2}\e, \t} \equiv \\ \Mdef \m\x\any{\meet{\tp2}{\tp4}}{\xt{this}.\m'(\b{\Cast{\meet{\tp1}{\tp3}}{x}})},\\
\Mdef {\m'}\x{\meet{\tp1}{\tp3}}{\meet{\tp2}{\tp4}}{\Cast{\meet{\tp2}{\tp4}}\e},	
}

\IRule{}{
	\b{\adapt{\md_1, \t^i}} \equiv \md_2
}{\TransClass{\Class\C{\b{\fd}}{\b{\md_1}}}{\Class{\C^i}{\b{\fd}}{\b{\md_2}}}}
\end{mathpar}


\begin{mathpar}
\IRule{}{
	\AnaCast{\b{\x:{\tp1}}}{\ep1}{\ep2}{\tp2}
}{
	\inscast{\Mdef\d\x{\tp1}{\tp2}{\ep1}} \equiv \Mdef\d\x{\tp1}{\tp2}{\ep2}
}

\IRule{}{
 \b{ \mdp1} \equiv \b{\setter\fd} ~~ \b{\getter\fd} \\  \b{\mdp2} \equiv \b{\inscast{\mdp1}}  ~~ \b{\dynamic{\mdp1}}
}{ 
	\TransClass { \Class \C {\b{\fd}} {\b{\md}} }{  \Class \C {\b{\fd}} {\b{\mdp2}} }
}
\end{mathpar}
\caption{Monotonic translation}
\end{figure}


\begin{figure}
\opdef{\Reduce{\ep 1}{\sp 1}{\ep 2}{\sp 2}}{\ep 1 with heap \sp 1 evaluates to \ep 2 and \sp 2 in a step}

\begin{mathpar}
\IRule{}{
	\Heap{\sp1}{\Bind{\ap 1}{\Obj{\b{\Fdef\f\t\a}}{\tp2}\C\}}} \\
	\tp2 \not\equiv \meet{\tp1}{\tp2} \\
	\sp2 = \Heap{\s}{\Bind{\ap 1}{\Obj{\b{\Fdef\f\t\a}}{\meet{\tp1}{\tp2}}{\refine{\C}{\tp1}}}}
}{
	\Reduce{\Cast{\tp 1}{\ap1}}{\sp1}{\ap1}{\sp2}
}

\IRule{}{
	\Heap{\sp1}{\Bind{\ap 1}{\Obj{\b{\Fdef\f\t\a}}{\tp2}\C\}}} \\
	\tp2 \equiv \meet{\tp1}{\tp2} \\
}{
	\Reduce{\Cast{\tp 1}{\ap1}}{\sp1}{\ap1}{\sp1}
}
\end{mathpar}
\caption{Common Core Calculus Dynamic Semantics.}
\end{figure}


\section{Appendix}


\section{Appendix}
\begin{figure}
\begin{mathpar}
\IRule{W1}{
    \HasType\Es\x\t
 }{
   \EnvType\s\x\t
}

\IRule{W2}{
   \EnvType\Es\e{\tp 1} \\ \tp 1 \Sub \t
 }{
   \EnvType\Es\e\t 
}   

\IRule{W3}{
   \EnvType\Es\e\any \\ \b{\EnvType\E{\ep1}\t }
}{
   \EnvType\Es{\Call\e\m{\b{\ep1}}}\any
}

\IRule{W4}{
   \EnvType\Es\e{\tp1} \\ \Mtype\m{\b{\tp2}}\t\inc \tp1  \\  \b{\EnvType\E{\ep1}{\tp 2}}
}{
    \EnvType\Es{\Call\e\m{\b{\ep1}}}\t
}    

\IRule{W5}{
  \b{\EnvType\Es\e\t} \\ 
  \Class \C {\b{\Ftype\f\t}} {\b{\md}}
}{
  \EnvType\Es{\New\C{\b\e}}\C
}

\IRule{W6}{
  \EnvType\Es\e{\tp1}
}{
   \EnvType\Es{\Cast\t\e}\t
}

\IRule{}{
  \Ftype\f{\t} \inc \classof{\Sel\s\a}
}{ 
 \EnvType\Es{\Get\a\f}{\t}
}

\IRule{}{
  \EnvType\Es\e{\tp1} \\
  \Ftype{\f}{\tp2}\inc\classof{\Sel\s\a}\\
  \tp1 \Sub \tp2
}{ 
    \EnvType\Es{\Set\a\f\e}{\tp1} 
}

\IRule{}{
   \typeofis{\Sel\s\a}\t 
}{
   \EnvType\Es\a\t
}
\end{mathpar}
\caption{Runtime typing rules}
\end{figure}

\bibliographystyle{plain}
\bibliography{../bib/compactdoi}
\end{document}

