\documentclass{report}
\usepackage{mathpartir,amsmath,amssymb,xspace,listings}
\begin{document}
\input{common}
\newcommand{\dyn}{\texttt{dyn}}   %% dyn type

% fields through wrapper based on name

Syntax:
\syntax
\begin{mathpar}
\inferrule*[right=SubRefl]{ }{ \t <: \t }

\inferrule*[right=SubClass]{\class~\C~\implements~\D}{ \C <: \xt{D} }

\inferrule*[right=Subdyn]{ }{\t <: \dyn}
\end{mathpar}


Class well-formedness

\begin{mathpar}
\inferrule{\G \vdash \t}{\G\vdash\f:\t}

\inferrule{\G \vdash \t \\ \bar{\G \vdash \t'} \\ \G,\this:this(\G),\bar{x:\t'} \vdash e : \t}{\G \vdash \m(\bar{x:\t'}):\t = e}

\inferrule{f:\t \in fields(\G)}{\G \vdash f():\t = \xt{this}.f}

\inferrule{f:\t \not\in fields(\G) \\ \G \vdash e : \t}{\G \vdash f():\t = e}

\inferrule{f:\t \in fields(\G)}{\G \vdash f!(\xt{x}:\t):\t = (\xt{this}.f=\xt{x})}

\inferrule{f:\t \not\in fields(\G) \\ \G,\xt{x}:\t \vdash e : \t}{\G \vdash f!(\xt{x}:\t):\t = e}
\end{mathpar}

\begin{mathpar}
\TVar 

\TStr

\TInt

\inferrule*[right=TSub]{\Gdash e : \t' \\ \t' <: \t}{\Gdash e : \t}

\TApp

\TIf

\TPlus

\inferrule*[right=TNew]{
  \bar{\Gdash e:\t} \\ 
  \{\ldots \bar{\f:\t} \ldots\} = fields(\C)\\
  typed(\C)
}{
  \Gdash \NEW \C{\bar e}:\C
}

\TCast

\inferrule*[right=TTypedClass]{ 
  \bar{\Gdash D} \\  
  {\MTYPE{\m'}{\bar{x:\t''}}{\t'} \in\D \implies \MTYPE{\m'}{\bar{x:\t''}}{\t'}\in\C }\\
  {\f:\t \in\D \implies \f:\t \in\C}\\
  {\bar{\Gdash \f:\t}}\\
  {\bar{\Gdash \MDEF\m{\bar{x:\t''}}{\t'}e}}
 }{
  \Gdash \CLASS \C{\bar\D}{\bar{\f:\t},\bar{\MDEF\m{\bar{x:\t''}}{\t'}e}}
  }  % TODO: LESS HORRIFYING

\inferrule*[right=TUntypedClass]{ 
  \bar{\Gdash D} \\  
  {\MTYPE{\m'}{\bar{x:\dyn}}{\dyn} \in\D \implies \MTYPE{\m'}{\bar{x:\dyn}}{\dyn}\in\C }\\
  {\f:\dyn \in\D \implies \f:\dyn \in\C}\\
 }{
  \Gdash \CLASS \C{\bar\D}{\bar{\f:\dyn},\bar{\MDEF\m{\bar{x:\dyn}}{\dyn}e}}
  } % TODO: UNTYPED VERSION
\end{mathpar}

\section{Dynamic Cast Insertion}
\begin{mathpar}
\inferrule*{ }{\NEW \C {\bar v} \tlate \cast{\C}\NEW\C{\bar v}}

\inferrule*{e\tlate e_t \\ \bar{e' \tlate e'_t} }{e(\bar{e'}) \tlate e_t(\bar{e_t'})}

\inferrule*{\bar{e\tlate e_t}}{\NEW \C {\bar e} \tlate \NEW\C{\bar{e_t}}}

\inferrule*{e \tlate e_t \\ e' \tlate e_t'}{e+e' \tlate e_t + e_t'}

\inferrule*{e \tlate e' \\
e_1 \tlate e_1' \\
e_2 \tlate e_2'}{\ifthenelse{e}{e_1}{e_2}\tlate\ifthenelse{e'}{e_1'}{e_2'}}

\inferrule*{e \tlate e_t}{\cast{\t}e \tlate \cast{\t}e_t}

\inferrule{e\tlate e_t}{e.\f \tlate e_t.\f}

\inferrule{e\tlate e_t \\ e'\tlate e_t'}{e.\f = e' \tlate e_t.\f = e_t'}

\inferrule{}{e \tlate e }
\end{mathpar}

\section{Dynamic semantics:}

Reduction:

\begin{mathpar}
\inferrule*[right=EFrame]{ e,v \ereduce e',v'}{F[e],v \ereduce F[e'],v'}

\inferrule*[right=ENew]{
     \class \; \C  \{\bar{\f : \t}, \bar{ \m (\bar{x:\t}) : \t' = e}\} \\
     \s'=\s(a\is\{\bar{\f=v},\bar{ \m (\bar{x}) = e} \B \C\}) }{ \NEW \C {\bar v},\s \ereduce a,\s'}

\inferrule*[right=EInv]{a\is \{\ldots,\m(\bar x)=e, \ldots \B \t\}}{a.\m(\bar v),\s \ereduce [a/\xt{this}][\bar{v/x}]e,\s}

\inferrule*[right=EField]{ \s[a\is\{\ldots,\f =v,\ldots\B\t\}] }{a.\f,\s \ereduce v,\s}

\inferrule*[right=EAssign]{ \s' = \s[a\is \{\ldots,\f =v,\ldots\B\t\}] }{a.\f = v,\s \ereduce v,\s'}

\inferrule*[right=EIfZ]{ }{ \ifthenelse{\intv{0}}{e_1}{e_2},\s \ereduce e_1,\s }

\inferrule*[right=EIfNZ]{n\neq 0}{ \ifthenelse{\intv{n}}{e_1}{e_2},\s \ereduce e_2,\s }

\inferrule*[right=EPlus]{ n_1 + n_2 = n_3 }{ \intv{n_1} + \intv{n_2},\s \ereduce \intv{n_3},\s}

\inferrule*[right=ECast]{ 
\CLASS \C{\bar\D}{\bar{\f:\t},\bar{\MDEF\m{\bar{x:\t''}}{\t'}e}}\\
\s(a) = \{\bar{\f}, \bar{\m(\bar{x}) = e}\}\\
getters = \bar{\xt{get\_}\f():\t = a\xt{.get\_f}()\cast{\t}}\\
setters = \bar{\xt{set\_}\f(\xt{x}) = a\xt{.set\_f}(\xt{x}\cast{\t})\cast{\t}}\\
meths = \bar{\m(\bar{x})=a.\m(\bar{x\cast{\t}})\cast{\t'}}\\
\s' = \s[a' \is \{getters, setters, meths\}] }{ \cast{\C}a,\s \ereduce a',\s'}
\end{mathpar}
\begin{lstlisting}
wrapper(A)
  A = class A {(*@\bar{\f_A:\t_A},\bar{m(\bar{x:\t''_A}):\t'_A = e_A}@*)}
  return class #A {
    (*@\xt{orig}:\xt{A}@*),
    (*@$\bar{m(\bar{x:\dyn}):\dyn = \cast{\t'_A}\xt{orig}.m(\bar{\cast{\t''_A}v})}$@*)
  }
\end{lstlisting}

For every typed class $\xt{A}$, we run $wrapper(\xt{A})$ to get a $\xt{#A}$ that ensures the type invariants on A.
\end{document}
