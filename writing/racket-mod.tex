\documentclass{report}
\usepackage{mathpartir,amsmath,amssymb,xspace,listings}
\begin{document}
\newcommand{\class}{\ensuremath{\xt{class}}\xspace}
\newcommand{\G}{\Gamma}
\renewcommand{\int}{\texttt{int}}
\newcommand{\coerce}{\Rightarrow} %% arrow used in coercions
\newcommand{\str}{\texttt{str}}
\newcommand{\any}{\texttt{dyn}}   %% dyn type
\newcommand{\dyn}{\texttt{dyn}}   %% dyn type
\newcommand{\this}{\texttt{this}}
\newcommand{\ifthenelse}[3]{\texttt{if }#1\texttt{ then }#2\texttt{ else }#3}
\newcommand{\cast}[1]{\langle #1\rangle} 
\newcommand{\xt}[1]{\texttt{#1}}
\newcommand{\creduce}{\longrightarrow_{cr}}  %% reduction
\newcommand{\ereduce}{\longrightarrow_{e}}   %%  reduction
\newcommand{\stepsto}{\longrightarrow}        %% reduction
\newcommand{\intv}[1]{\xt{int}[#1]}
\newcommand{\strv}[1]{\xt{str}[#1]}
\newcommand{\tlate}{\rightsquigarrow}
\newcommand{\s}{\sigma}
\renewcommand{\sc}{\mu}
\renewcommand{\t}{\tau}
\newcommand{\B}{\ensuremath{~|~}\xspace}
\newcommand{\new}{\ensuremath{\texttt{new}}\xspace}
\newcommand{\NEW}[2]{\ensuremath{  \new ~ #1 ( #2 )}\xspace}
\renewcommand{\bar}[1]{\ensuremath{\overline{ #1} }\xspace}
\newcommand{\m}{\ensuremath{\xt{m}}\xspace}
\newcommand{\f}{\ensuremath{\xt{f}}\xspace}
\newcommand{\C}{\ensuremath{\xt{C}}\xspace}
\newcommand{\D}{\ensuremath{\xt{D}}\xspace}
\newcommand{\is}{\mapsto}
%% Cast syntax??
\newcommand{\cl}{\mathit{cl}\xspace}
\newcommand{\implements}{\xt{implements}\xspace}
\newcommand{\CLASS}[3]{ \ensuremath{  \xt{class}~#1~\implements~#2\;\{ #3 \}}\xspace} 
\newcommand{\MDEF}[4] { #1( #2 ):#3 = #4}
\newcommand{\MTYPE}[3] { #1( #2 ):#3}
\newcommand{\MVAL}[3] { #1( #2 ) = #3}
\newcommand{\Gdash}{\G\vdash}

% fields through wrapper based on name

Syntax:
\begin{align*}
\t &::= \dyn \B  \str \B  \int \B  \{\bar{\f :\t},\bar{\m (\bar{\t}):\t}\}\\
e &::= k \B  e.\m(\bar{e}) \B e.\f  \B e.\f  = e \B  \ifthenelse{e}{e}{e}\B e + e \\
&\B x\B \NEW \C {\bar{e}} \B  e\cast{\t}\\
\cl &::= \CLASS \C {\bar \D} { \bar{ \f : \t }, ~ \bar{ \MDEF{\m}{\bar{x :\t}}{\t'}{e} } } \\
I &::= \str \B  \int \B  \{\bar{\f :I},\bar{\m (\bar{I}):I}\}\\
v &::= k \B a\\
\s &::= \emptyset \B  \s( a \is o : \t )\\
F &::=    \square.\m(\bar e) 
   \B 	  \square.\f 
   \B 	  \square.\f  = e
   \B     v.\f  = \square
   \B     v.\m(\bar v,\square, \bar e) 
   \B     \ifthenelse{\square}{e}{e} 
   \B     \square + e 
   \B      v + \square\\
   &\B     \square\cast{\tau}
   \B \NEW  \C {\bar{v},\square,\bar{e}}\\
\end{align*}

\begin{mathpar}
\inferrule*[right=SubRefl]{ }{ \t <: \t }

\inferrule*[right=SubClass]{\class~\C~\implements~\D}{ \C <: \xt{D} }

\inferrule*[right=Subdyn]{ }{\t <: \dyn}
\end{mathpar}


Class well-formedness

\begin{mathpar}
\inferrule{\G \vdash \t}{\G\vdash\f:\t}

\inferrule{\G \vdash \t \\ \bar{\G \vdash \t'} \\ \G,\this:this(\G),\bar{x:\t'} \vdash e : \t}{\G \vdash \m(\bar{x:\t'}):\t = e}

\inferrule{f:\t \in fields(\G)}{\G \vdash \xt{get\_}f():\t = \xt{this}.f}

\inferrule{f:\t \not\in fields(\G) \\ \G \vdash e : \t}{\G \vdash \xt{get\_}f():\t = e}

\inferrule{f:\t \in fields(\G)}{\G \vdash \xt{set\_}f(\xt{x}:\t):\t = (\xt{this}.f=\xt{x})}

\inferrule{f:\t \not\in fields(\G) \\ \G,\xt{x}:\t \vdash e : \t}{\G \vdash \xt{set\_}f(\xt{x}:\t):\t = e}
\end{mathpar}

\begin{mathpar}
\inferrule*[right=TVar]{\G(x) = A }{\G \vdash x : A}

\inferrule*[right=TStr]{ }{\Gdash string : \str}

\inferrule*[right=TInt]{ }{\Gdash int : \int}

\inferrule*[right=TSub]{\Gdash e : \t' \\ \t' <: \t}{\Gdash e : \t}

\inferrule*[right=TApp]{\bar{\Gdash e_i : \t_i} \\ \Gdash e : \{\ldots, \m(\bar{\t'_i}):\t', \ldots\}}{\Gdash e.\m(\bar{e_i}) : \t'}

\inferrule*[right=TIf]{ 
     \Gdash e:\int\\ 
     \Gdash e':\t \\ 
     \Gdash e'':\t
}{ 
     \Gdash \ifthenelse{e}{e'}{e''} : \t}

\inferrule*[right=TPlus]{ 
  \Gdash e:\int \\ \
  \Gdash e':\int
}{ \Gdash e+e':\int}

\inferrule*[right=TNew]{
  \bar{\Gdash e:\t} \\ 
  \G(\C) = \{\bar{\f:\t} \ldots\}
}{
  \Gdash \NEW \C{\bar e}:\C
}

\inferrule*[right=TCast]{
  \Gdash e:\t'
}{
  \Gdash \cast{\t}e : \t}

\inferrule*[right=TTypedClass]{ 
  \bar{\Gdash D} \\  
  {\MTYPE{\m'}{\bar{x:\t''}}{\t'} \in\D \implies \MTYPE{\m'}{\bar{x:\t''}}{\t'}\in\C }\\
  {\f:\t \in\D \implies \f:\t \in\C}\\
  {\bar{\Gdash \f:\t}}\\
  {\bar{\Gdash \MDEF\m{\bar{x:\t''}}{\t'}e}}
 }{
  \Gdash \CLASS \C{\bar\D}{\bar{\f:\t},\bar{\MDEF\m{\bar{x:\t''}}{\t'}e}}
  }  % TODO: LESS HORRIFYING

\inferrule*[right=TUntypedClass]{ 
  \bar{\Gdash D} \\  
  {\MTYPE{\m'}{\bar{x:\dyn}}{\dyn} \in\D \implies \MTYPE{\m'}{\bar{x:\dyn}}{\dyn}\in\C }\\
  {\f:\dyn \in\D \implies \f:\dyn \in\C}\\
 }{
  \Gdash \CLASS \C{\bar\D}{\bar{\f:\dyn},\bar{\MDEF\m{\bar{x:\dyn}}{\dyn}e}}
  } % TODO: UNTYPED VERSION
\end{mathpar}

\section{Dynamic Cast Insertion}
\begin{mathpar}
\inferrule*{ }{\NEW \C {\bar v} \tlate \cast{\C}\NEW\C{\bar v}}

\inferrule*{ }{e \tlate e}
\end{mathpar}

\section{Dynamic semantics:}

Reduction:

\begin{mathpar}
\inferrule*[right=EFrame]{ e,v \ereduce e',v'}{F[e],v \ereduce F[e'],v'}

\inferrule*[right=ENew]{
     \class \; \C  \{\bar{\f : \t}, \bar{ \m (\bar{x:\t}) : \t' = e}\} \\
     \s'=\s(a\is\{\bar{\f=v},\bar{ \m (\bar{x}) = e} \B \C\}) }{ \NEW \C {\bar v},\s \ereduce a,\s'}

\inferrule*[right=EInv]{a\is \{\ldots,\m(\bar x)=e, \ldots \B \t\}}{a.\m(\bar v),\s \ereduce [a/\xt{this}][\bar{v/x}]e,\s}

\inferrule*[right=EField]{ \s[a\is\{\ldots,\f =v,\ldots\B\t\}] }{a.\f,\s \ereduce v,\s}

\inferrule*[right=EAssign]{ \s' = \s[a\is \{\ldots,\f =v,\ldots\B\t\}] }{a.\f = v,\s \ereduce v,\s'}

\inferrule*[right=EIfZ]{ }{ \ifthenelse{\intv{0}}{e_1}{e_2},\s \ereduce e_1,\s }

\inferrule*[right=EIfNZ]{n\neq 0}{ \ifthenelse{\intv{n}}{e_1}{e_2},\s \ereduce e_2,\s }

\inferrule*[right=EPlus]{ n_1 + n_2 = n_3 }{ \intv{n_1} + \intv{n_2},\s \ereduce \intv{n_3},\s}

\inferrule*[right=ECast]{ 
\CLASS \C{\bar\D}{\bar{\f:\t},\bar{\MDEF\m{\bar{x:\t''}}{\t'}e}}\\
\s(a) = \{\bar{\f}, \bar{\m(\bar{x}) = e}\}\\
getters = \bar{\xt{get\_}\f():\t = a\xt{.get\_f}()\cast{\t}}\\
setters = \bar{\xt{set\_}\f(\xt{x}) = a\xt{.set\_f}(\xt{x}\cast{\t})\cast{\t}}\\
meths = \bar{\m(\bar{x})=a.\m(\bar{x\cast{\t}})\cast{\t'}}\\
\s' = \s[a' \is \{getters, setters, meths\}] }{ \cast{\C}a,\s \ereduce a',\s'}
\end{mathpar}
\end{document}
