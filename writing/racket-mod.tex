\documentclass{report}
\usepackage{mathpartir,amsmath,amssymb,xspace,listings}
\begin{document}
\input{common}

% fields through wrapper based on name

Syntax:
\syntax
\begin{mathpar}
\inferrule*[right=SubRefl]{ }{ \t <: \t }

\inferrule*[right=SubClass]{\class~\C~\implements~\D}{ \C <: \xt{D} }

\inferrule*[right=Subdyn]{ }{\t <: \any}
\end{mathpar}


Class well-formedness

\begin{mathpar}
\inferrule{\G \vdash \t}{\G\vdash\f:\t}

\inferrule{\G \vdash \t \\ \bar{\G \vdash \t'} \\ \G,\this:this(\G),\bar{x:\t'} \vdash e : \t}{\G \vdash \m(\bar{x:\t'}):\t = e}

\inferrule{f:\t \in fields(\G)}{\G \vdash f():\t = \xt{this}.f}

\inferrule{f:\t \not\in fields(\G) \\ \G \vdash e : \t}{\G \vdash f():\t = e}

\inferrule{f:\t \in fields(\G)}{\G \vdash f!(\xt{x}:\t):\t = (\xt{this}.f=\xt{x})}

\inferrule{f:\t \not\in fields(\G) \\ \G,\xt{x}:\t \vdash e : \t}{\G \vdash f!(\xt{x}:\t):\t = e}
\end{mathpar}

\begin{mathpar}
\TVar 

\TStr

\TInt

\inferrule*[right=TSub]{\Gdash e : \t' \\ \t' <: \t}{\Gdash e : \t}

\TApp

\TIf

\TPlus

\inferrule*[right=TNew]{
  \bar{\Gdash e:\t} \\ 
  \{\ldots \bar{\f:\t} \ldots\} = fields(\C)\\
  typed(\C)
}{
  \Gdash \NEW \C{\bar e}:\C
}

\TCast

\inferrule*[right=TTypedClass]{ 
  \bar{\Gdash D} \\  
  {\MTYPE{\m'}{\bar{x:\t''}}{\t'} \in\D \implies \MTYPE{\m'}{\bar{x:\t''}}{\t'}\in\C }\\
  {\f:\t \in\D \implies \f:\t \in\C}\\
  {\bar{\Gdash \f:\t}}\\
  {\bar{\Gdash \MDEF\m{\bar{x:\t''}}{\t'}e}}
 }{
  \Gdash \CLASS \C{\bar\D}{\bar{\f:\t},\bar{\MDEF\m{\bar{x:\t''}}{\t'}e}}
  }  % TODO: LESS HORRIFYING

\inferrule*[right=TUntypedClass]{ 
  \bar{\Gdash D} \\  
  {\MTYPE{\m'}{\bar{x:\any}}{\any} \in\D \implies \MTYPE{\m'}{\bar{x:\any}}{\any}\in\C }\\
  {\f:\any \in\D \implies \f:\any \in\C}\\
 }{
  \Gdash \CLASS \C{\bar\D}{\bar{\f:\any},\bar{\MDEF\m{\bar{x:\any}}{\any}e}}
  } % TODO: UNTYPED VERSION
\end{mathpar}

\section{Dynamic Cast Insertion}

\begin{mathpar}
\CICast

\CICallAny

\CIIf

\CIPlus

\CIVar

\inferrule*{ }{\Gdash \NEW \C {\bar v} \tlate \cast{\C}\NEW\C{\bar v} : \any}

\end{mathpar}

\section{Dynamic semantics:}

Reduction:

\begin{mathpar}
\EFrame

\ENew

\EInv

\EField

\EAssign

\EIfZ

\EIfNZ

\EPlus

\inferrule*[right=EField]{ \s[a\is\{\ldots,\f =v,\ldots\B\t\}] }{a.\f,\s \ereduce v,\s}

\inferrule*[right=EAssign]{ \s' = \s[a\is \{\ldots,\f =v,\ldots\B\t\}] }{a.\f = v,\s \ereduce v,\s'}

\inferrule*[right=EIfZ]{ }{ \ifthenelse{\intv{0}}{e_1}{e_2},\s \ereduce e_1,\s }

\inferrule*[right=EIfNZ]{n\neq 0}{ \ifthenelse{\intv{n}}{e_1}{e_2},\s \ereduce e_2,\s }

\inferrule*[right=EPlus]{ n_1 + n_2 = n_3 }{ \intv{n_1} + \intv{n_2},\s \ereduce \intv{n_3},\s}

\inferrule*[right=ECast]{
\s' = \s[a' \is \{\xt{orig} = a \B \xt{\#}\C\}] }{ \cast{\C}a,\s \ereduce a',\s'}
\end{mathpar}
\begin{lstlisting}
wrapper(A)
  A = class A {(*@\bar{\f_A:\t_A},\bar{m(\bar{x:\t''_A}):\t'_A = e_A}@*)}
  return class #A {
    (*@\xt{orig}:\xt{A}@*),
    (*@\xt{orig():\xt{A} = this.orig}@*),
    (*@$\bar{m(\bar{x:\any}):\any = \cast{\t'_A}\xt{this.orig()}.m(\bar{\cast{\t''_A}v})}$@*)
  }
\end{lstlisting}

For every typed class $\xt{A}$, we run $wrapper(\xt{A})$ to get a $\xt{\#A}$ that ensures the type invariants on A.
\end{document}
