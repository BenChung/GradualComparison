Well-typed class translation:
	if c |-> c', then for every m(x:t1 ...):t2=e in c', x:t1 ... |- e : t2

proof:
		Consider some md in c'. One of four rules can have been applied to make it, translate, set, get, and proxy.

		If the body was generated by translate, then the theorem follows by well-typed translation.

		If the body was generated by get, then the theorem follows by W7 with this : {... f:t ...}, and likewise with W8 for set.

		If the body was generated with proxy, then <t1>x has type t1 for every x by W6, and therefore this.m(<t1>x ...) has type t2 by W4 and thus <*>this.m(<t1>x ...) has type * by W6 and the theorem holds.

Base language well-typed translation:
	if gamma |- e |-> e' => t, then gamma emp |- e' : t
	if gamma |- e ~~> e' <= t, then gamma emp |- e' : t

proof: by rule induction on typed translation judgment

	case A1:
		trivial.
	case A4:
		trivial.
	case A5:
		By IH, gamma emp |- e3 : *
		By IH, gamma emp |- e4 : * ...
		By W6, gamma emp |- <{m*(* ...) : *}>e3 : {m*(* ...) : *}
		By W4, gamma emp |- <{m*(* ...) : *}>e3.m*(e4) : *
	case A6:
		trivial.

	case AASC1:
		By IH, gamma emp |- e2 : t2
		By W2, gamma emp |- e2 : t1
	case AASC3:
		trivial.

Typed racket well-typed translation:
	if gamma |- e |-> e' => t, then gamma emp |- e' : t
	if gamma |- e ~~> e' <= t, then gamma emp |- e' : t

proof: by rule induction on typed translation judgment
	case TRNew1:
		Trivial
	case TRNew2:
		Trivial
	case AASC1:
		Trivial
	case AASC2:
		Trivial

Strongscript well-typed translation:
	if gamma |- e |-> e' => t, then gamma emp |- e' : t
	if gamma |- e ~~> e' <= t, then gamma emp |- e' : t

proof:
	case A5
		By IH, gamma emp |- e3 : ?t1
		By IH, gamma emp |- e4 : ?t2 ...
		By W6, gamma emp |- <{m*(* ...) : *}>e3 : {m*(* ...) : *}
		By W4, gamma emp |- <{m*(* ...) : *}>e3.m*(e4) : *
		By SW2, gamma emp |- <(<{m*(* ...) : *}>e3) : t3
	case AASC1
		trivial by IH and by W6
	case AASC2
		trivial by IH and SW2


Transient well-typed translation:
	if gamma |- e |-> e' => t, then gamma emp |- e' : t
	if gamma |- e ~~> e' <= t, then gamma emp |- e' : t

proof:
	A5:
		gamma |- e3 : t1 by IH on inversion
		know that m(t2 ...) : t3 is in t1
		every e4 s.t. gamma |- e4 : t2 by IH on inversion
		m*(*...):* is in t1 by above and via translation
		gamma |- <*>e4 : * by W6 on above
		therefore by W4 gamma |- e3.m*(<*>e4 ...) : *
		By W6 on above, gamma |- <t3>(e3.m*(<*>e4 ...)) : t3


proof: by rule induction on typed translation judgment
	case A5:
		By IH, gamma |- e3 : t1
		By IH for every e4, gamma |- e4 : t2
		Because m(t2 ...):t3 in t1, m*(* ...) : * must be in t1 by class translation.
		By W6 on the above, gamma |- <*>e4 : * for every e4
		By W4 on the above with m(* ...):* in t1, gamma |- e3.m*(e4 ...) : *
		By W6 on above, gamma |- <t3>(e3.m*(e4 ...) : *) : t3

progress & preservation: if emp s |- e : t then e -> e' and emp s |- e' :t
							   or e value
							   or e -> err

proof: By rule induction on typing judgment.
	case W1:
		Not possible, empty environment.
	case W2:
		Apply IH to inversion. Trivial.
	case W4:
		By inversion,
			1) emp s |- e : C
			2) m(t2 ...) : t in C
			3) {emp s |- e1 : t2} ...
		Apply IH to 1.
			if e -> e' then emp s |- e' : t1 
				e.m(e1 ...) -> e'.m(e1 ...) by eval. rule 1
				typing holds by W4
			if e -> err
				e.m(e1 ...) -> err by eval. rule 10
			otherwise, if e value:
		Apply IH to each element in 3 iteratively left-to-right. For each step:
			if e1 -> e1' and emp s |- e1' : t2
				e.m(... e1 ...) -> e.m(... e1' ...)
				typing holds by W4
			if e1 -> err
				e.m(... e1 ...) -> err by eval. rule 10
			otherwise, if all e1 value:
		By canonical forms e must be of the form {f=v ...}_D^t where D <: C
		By 2, m(t2 ...):t in C, and by (TODO LEMMA), a function m'(x:t2' ...):t'=e2 in D where (4.1) t2 <: t2' and (4.2) t' <: t, such that
			this:D x:t2' ... |- e2 : t' 
		5) By W2 on 3 and 4.1, {emp s |- e1 : t2'} ...
		By substitution, emp s |- [e/this] [e1/x ...] e2 : t'
		By eval. rule 3, e.m(e1 ...) -> [e/this] [e1/x ...] e2 : t' and by W2 on 4.2, this is well typed
	case W5:
		By inversion:
			1) {emp s |- e : t} ...
			2) exists class C { f : t ... md ...}
		Apply IH to 1.
			if e -> e' and emp s |- e' : t
				new C(... e ...) -> new C(... e' ...) by eval. rule 1
				typing holds by W5
			if e -> err
				new C(... e ...) -> err by eval. rule 10
			otherwise, if every e value
		Apply eval. rule 2, new C(e ...) s1 -> a s2 where s2,a = alloc(s1, e ...)
		By definition of alloc, s2[a] |-> {f=e ...}_C^C
		Therefore by W9 the result is well typed.
	case W6:
		Trivial by evaluation rules 8 and 9 as well as W2
	case W7:
		By inversion:
			1) emp s |- e : C
			2) f:t in C
		By IH on 1:
			if e -> e' and emp s |- e' : C
				then emp s |- e'.f : t by W7 on 2 and assumption
			if e -> err
				then e.f -> err by rule
			if e value:
		By canonical forms, sigma(e) = {... f=a ...}_D^t where D <: C and t <: C
		Likewise, emp s |- a : t
		Therefore, e.f -> a by eval. rule 5 and emp s |- a : t by above.
	case W8:
		By inversion:
			1) emp s |- e1 : C
			2) f : t in C
			3) emp s |- e2 : t
		By IH on 1:
			if e1 -> e1' and emp s |- e1' : C
				then emp s |- e1' : C and e1.f := e2 -> e1'.f := e2 by eval. rule 1, and is well typed by W8 on above.
			if e1 -> err
				then e1.f := e2 -> err by evaluation rule 10
			if e1 value then continue
		By IH on 3:
			if e2 -> e2' and emp s |- e2' : C
				then emp s |- e2' : C and e1.f := e2 -> e1.f := e2' by eval. rule 1, and is well typed by W8 on above.
			if e2 -> err
				then e2.f := e2 -> err by evaluation rule 10
			if e2 value then continue
		If e1 value and e1 has type C, then by canonical forms s(e1) = {... f = a ...}_D^t where D <: C and t <: C
		define s2 as s(e1) = {... f = e2 ...}_C^t
		then emp s2 |- e1 : C by above and W9.
		Therefore, s e1.f := e2 -> s2 e1 and emp s2 |- e1 : C
	case W9:
		a1 value.


Soundness: follows trivially.



progress & preservation for strongscript: if emp s |- e : t then e -> e' and emp s |- e' :t
							   or e value
							   or e -> err

proof: By rule induction on typing judgment.

	case SW1
		By inversion, emp s |- e : t2
		By IH, one of the following hold:
			e -> e' and emp s |- e' : t2
			e value
			or e -> err
		Case e -> e' where emp s |- e' : t2  
			By SW1, emp s |- e : ?t1
		Case e value
			ibid
		Case e -> err
			trivial
	case SW2
		By inversion, emp s |- e : *
		By IH, one of the following hold:
			e -> e' and emp s |- e' : *
			e value
			or e -> err
		Case e -> e' where emp s |- e' : *  
			By SW2, emp s |- e : ?t1
		Case e value
			ibid
		Case e -> err
			trivial
	Other cases same as base system.

Meet consistent subtyping: if t meet t' = t'' and t <~ tp and t' <~ tp then t'' <~ tp

Proof: trivial

constraints imposed by casting: if s' = cast(a,t,s), then for every a in s' and s, if s[a |-> {ai}_C^t1] and s'[a |-> {ai}_D^t2] then s' <~ s

proof trivial

define a satisfying type assignment as a set v = {a |-> t} for some heap sigma, denoted v |= sigma.

Define v |= sigma as 
	for every a in v and a in sigma, then
		v(a) = t implies that
			sigma[a |-> {a'}^t'_C]
			t <~ t'
			forall f():t'' in t
				v(a') <~ t''

lemma 1: if s = cast(a,t,s')
	then
		forall a in dom(s), s'[a|->{a' ...}^t_C] => s[a |-> {a' ...}^t'_C'] /\ t' <~ t /\ 
													forall v |= s => v |= s'

theorem 1: s' = cast(a, t, s) /\ exists v_i |= s => s'[a |-> {a' ...}_C^t'] /\ t' <~ t /\ exists v' |= s'

proof: rule induction on casting
	MS1: (denote IH1)
		let t be s.t. s[a |-> {a' ...}^{t_i}_C]
		define s2 s.t. s2[a |-> {a' ...}^{t_i meet t}_C]
		let ts = ti meet t

		let f():tf in ts

		proceed by induction on n:
			IH2 exists v |= sn' /\ forall va |= sn', j <= n, va(aj) <~ tj and va(a) <~ ts
			b.c. n = 0
				let sn' = s2
				let v' = v[a|-> ts]
				v' |= sn' trivially
				forall va |= sn', va(a) <~ ts as su'[a |-> {...}^ts_D]
			i.s. n = k, sk = cast(ak,tk,s(k-1))
				by IH2, (1) exists v |= s(k-1)' /\ (2) forall va |= s(k-1)', (3) forall j <= k, va(aj) <~ tfj /\ va(a) <~ t meet tj
				by IH1 on (1) and given, (4) exists v2' |= sk' /\ sk'[ak|-> {...}^tk'_E] /\ tk' <~ tk
				forall vb |= sk' by lemma 1, vb |= s(k-1) => forall i <= k, vb(i) <~ ti /\ by (3) vb(a) <~ ts
				by (4), exists v' = v2' s.t. v' |= sk' 


soundness of casting: for every a1 and a2, if emp s |- a1 : t1 and cast(a2,t2,s) = s' then emp s' |- a1 : t1 and emp s' |- a2 : t2

proof: by rule induction on casts
	case MS1
		by inversion of W9, we know that
			s[a1 |-> {f=a1' ...}_C^t1]
			every f is such that f : t1' in C
			and if f:t1' in C then emp s |- a1' : t1'
			as well as that C <~ t1
		by inversion of MS1, we know that
			s'[a2 |->{f=a2' ...}_{D|>t2}^{t2 meet t2'}]
			let tf be such that f():tf in {t2 meet t2'}
			s1' = cast(a2',tf,s')
			s2' = cast(a2',tf,s1')
			...
			sn' = cast(a2',tf,s(n-1)') for every a2' tf pair
			sn'[a2 |->{f=a2' ...}_{D}^{t2'}]
		wts
			emp sn' |- a1 : t1
		and emp sn' |- a2 : t2

		Begin by showing the first property:
		sts 
			sn'[a1 |-> {f=a1' ...}_C1f^t1f]
			every f is such that f() : t1f' in t1f
			and if f():t1f' in t1f then emp s' |- a1' : t1f'
			as well as that C1f <~ t1f

			sn'[a2 |-> {f=a2' ...}_C2f^t2f]
			every f is such that f() : t2f' in t2f
			and if f():t2f' in t2f then emp s' |- a2' : t2f'
			as well as that C2f <~ t2f
		
	case MS2

progress & preservation for monotonic: if emp s |- e : t then s e -> s' e' and emp s' |- e' : t
							   or e value
							   or e -> err

proof: By rule induction on typing judgment.

	Everything other than cast has the same evaluation rule. Therefore, we focus only on casts.
	case W6
		if s e -> s' e' and emp s' |- e' : t
			trivial
		if e -> err
			trivial
		if e value
			if e is a value, then e must be an address a
			if no cast rule applies, then e -> err and theorem holds
			otherwise, cast rule 3 must have applied, and t1 = t, a1 = a, and s1 = s

