
\newcommand{\class}{\ensuremath{\xt{class}}\xspace}
\newcommand{\G}{\Gamma}
\renewcommand{\int}{\texttt{int}}
\newcommand{\coerce}{\Rightarrow} %% arrow used in coercions
\newcommand{\str}{\texttt{str}}
\newcommand{\any}{\texttt{any}}   %% any type
\newcommand{\this}{\texttt{this}}
\newcommand{\ifthenelse}[3]{\texttt{if }#1\texttt{ then }#2\texttt{ else }#3}
\newcommand{\cast}[1]{\langle #1\rangle} 
\newcommand{\xt}[1]{\texttt{#1}}
\newcommand{\creduce}{\longrightarrow_{cr}}  %% reduction
\newcommand{\ereduce}{\longrightarrow_{e}}   %%  reduction
\newcommand{\stepsto}{\longrightarrow}        %% reduction
\newcommand{\intv}[1]{\xt{int}[#1]}
\newcommand{\strv}[1]{\xt{str}[#1]}
\newcommand{\tlate}{\rightsquigarrow}
\newcommand{\s}{\sigma}
\renewcommand{\sc}{\mu}
\renewcommand{\t}{\tau}
\newcommand{\B}{\ensuremath{~|~}\xspace}
\newcommand{\new}{\ensuremath{\texttt{new}}\xspace}
\newcommand{\NEW}[2]{\ensuremath{  \new ~ #1 ( #2 )}\xspace}
\renewcommand{\bar}[1]{\ensuremath{\overline{ #1} }\xspace}
\newcommand{\m}{\ensuremath{\xt{m}}\xspace}
\newcommand{\f}{\ensuremath{\xt{f}}\xspace}
\newcommand{\C}{\ensuremath{\xt{C}}\xspace}
\newcommand{\D}{\ensuremath{\xt{D}}\xspace}
\newcommand{\is}{\mapsto}
%% Cast syntax??
\newcommand{\cl}{\mathit{cl}\xspace}
\newcommand{\implements}{\xt{implements}\xspace}
\newcommand{\CLASS}[3]{ \ensuremath{  \xt{class}~#1~\implements~#2\;\{ #3 \}}\xspace} 
\newcommand{\MDEF}[4] { #1( #2 ):#3 = #4}
\newcommand{\MTYPE}[3] { #1( #2 ):#3}
\newcommand{\MVAL}[3] { #1( #2 ) = #3}
\newcommand{\Gdash}{\G\vdash}
\renewcommand{\TirNameStyle}[1]{\footnotesize\textsc{#1}}
\lstset{
    escapeinside={(*@}{@*)},          % if you want to add LaTeX within your code
}
\newcommand{\types}{\any \B \int \B \C}
\newcommand{\context}{\G &::= \cdot \B x : \tau~\G\\}
\newcommand{\objform}{\mathit{o} &::= \{\bar{\f=v} \B \C\}\\}
\newcommand{\syntax}[1]{
\begin{align*}
\t &::= \types\\
e &::= k \B  e.\m(\bar{e}) \B e.\f \B e.\f  = e \B  \ifthenelse{e}{e}{e}\B e + e \\
&\B x\B \NEW \C {\bar{e}} \B  e\cast{\t}\\
\cl &::= \CLASS \C {\bar \D} { \bar{ \f : \t }, ~ \bar{ \MDEF{\m}{\bar{x :\t}}{\t'}{e} } } \\
\context
v &::= k \B a\\
\objform
\s &::= \emptyset \B  \s( a \is o )\\
F &::=    \square.\m(\bar e) 
   \B     \square.\f
   \B     \square.\f = e
   \B     a.\f = \square
   \B     v.\m(\bar v,\square, \bar e) 
   \B     \ifthenelse{\square}{e}{e} 
   \B     \square + e 
   \B      v + \square\\
   &\B     \square\cast{\tau}
\B \NEW  \C {\bar{v},\square,\bar{e}}\\#1
\end{align*}}

\newcommand{\TVar}{\inferrule*[lab=TVar]{\G(x) = A }{\G \vdash x : A}}
\newcommand{\TInt}{\inferrule*[lab=TInt]{ }{\Gdash \intv{n} : \int}}
\newcommand{\TSub}{\inferrule*[lab=TSub]{\Gdash e : \t' \\ \t' <: \t}{\Gdash e : \t}}

\newcommand{\TUApp}{\inferrule*[lab=TUApp]{\bar{\Gdash e_i : \t_i} \\ \Gdash e : \any}{\Gdash e.\m(\bar{e_i}) : \any}}
\newcommand{\TApp}{\inferrule*[lab=TApp]{ \Gdash e : \C \\ \m(\bar{\t'_i}):\t' \in \C \\ \Gdash e_i : \t_i}{\Gdash e.\m(\bar{e_i}) : \t'}}
\newcommand{\TIf}{\inferrule*[lab=TIf]{ 
     \Gdash e:\int \\ 
     \Gdash e':\t \\ 
     \Gdash e'':\t
}{ 
     \Gdash \ifthenelse{e}{e'}{e''} : \t}}
\newcommand{\TPlus}{\inferrule*[lab=TPlus]{ 
  \Gdash e:\int \\ \
  \Gdash e':\int
}{ \Gdash e+e':\int}}



\newcommand{\TNew}{\inferrule*[lab=TNew]{
  \bar{\Gdash e:\t} \\ 
  \{\ldots \bar{\f:\t} \ldots\} = fields(\C)\\
}{
  \Gdash \NEW \C{\bar e}:\C
}}

\newcommand{\TCast}{\inferrule*[lab=TCast]{
  \Gdash e:\t'
}{
  \Gdash \cast{\t}e}}


\newcommand{\CICast}{\inferrule*[lab=CICast]{
  \Gdash e \tlate e':\t' 
}{
  \Gdash \cast{\t} e\tlate \cast{\t}e':\t
}}

\newcommand{\CICall}{\inferrule*[lab=CICall]{
  \Gdash e \tlate e':\C\\
  \MTYPE\m{\bar\t}{\t'} \in \C \\
  \bar{\Gdash e' \tlate e'' : \t} 
}{
  \Gdash e.\m(\bar{e'}) \tlate e'.\m(\bar{e''}):\t
}}

\newcommand{\CICallAny}{\inferrule*[lab=CICallAny]{ 
  \Gdash e \tlate e'':\any \\  
  \bar{\Gdash e' \tlate e''':\t'} \\ 
}{
  \Gdash e.\m(\bar{e'}) \tlate e''.\m(\bar{e'''}) : \any
}}

\newcommand{\CIIf}{\inferrule*[lab=CIIf]{
  \Gdash e_1 \tlate e_1' : \int \\ 
  \Gdash e_2\tlate e_2':\t_2 \\ 
  \Gdash e_3 \tlate e_3' : \t_2
}{
  \Gdash \ifthenelse{e_1}{e_2}{e_3} \tlate \ifthenelse{e_1'}{e_2'}{e_3'} : \t_2
} }

\newcommand{\CIPlus}{\inferrule*[lab=CIPlus]{
  \Gdash e_1 \tlate e_1':\int \\ 
  \Gdash e_2 \tlate e_2' : \int \\ 
}{
  \Gdash e_1 + e_2 \tlate e_1' + e_2' :\int 
}}

\newcommand{\CIVar}{\inferrule*[lab=CIVar]{
  x:\t \in \G
}{
  \Gdash x \tlate x : \t
}}

\newcommand{\CINew}{\inferrule*[lab=CINew]
      {\C=\{\bar{\f :\t},\ldots\} \in \G \\ 
       \bar{\Gdash e \tlate e' : \t}}
      {\Gdash \NEW \C{\bar e} \tlate \NEW\C{\bar{e'}} : \C}}


\newcommand{\EFrame}{\inferrule*[lab=EFrame]{ e,v \ereduce e',v'}{F[e],v \ereduce F[e'],v'}}

\newcommand{\ENew}{\inferrule*[lab=ENew]{
     \bar{\f : \t} \in \C \\
     \s'=\s(a\is\{\bar{\f=v} \B \C\}) }{ \NEW \C {\bar v},\s \ereduce a,\s'}}

\newcommand{\EInv}{\inferrule*[lab=EInv]{a\is \{\ldots \B \C\} \\ \m(\bar x)=e \in \C}{a.\m(\bar v),\s \ereduce [a/\xt{this}][\bar{v/x}]e,\s}}

\newcommand{\EField}{\inferrule*[lab=EField]{ \s[a\is\{\ldots,\f =v,\ldots\B\t\}] }{a.\f,\s \ereduce v,\s}}

\newcommand{\EAssign}{\inferrule*[lab=EAssign]{ \s' = \s[a\is \{\ldots,\f =v,\ldots\B\t\}] }{a.\f = v,\s \ereduce v,\s'}}

\newcommand{\EIfZ}{\inferrule*[lab=EIfZ]{ }{ \ifthenelse{\intv{0}}{e_1}{e_2},\s \ereduce e_1,\s }}

\newcommand{\EIfNZ}{\inferrule*[lab=EIfNZ]{n\neq 0}{ \ifthenelse{\intv{n}}{e_1}{e_2},\s \ereduce e_2,\s }}

\newcommand{\EPlus}{\inferrule*[lab=EPlus]{ n_1 + n_2 = n_3 }{ \intv{n_1} + \intv{n_2},\s \ereduce \intv{n_3},\s}}

\newcommand{\ECastInt}{\inferrule*[lab=ECastInt]{ }{ \cast{\int}\intv{n},\s \ereduce \intv{n},\s'}}

\newcommand{\wellformedness}{
\subsection{Class well-formedness}

\begin{mathpar}
\inferrule*[lab=WFField]{\G \vdash \t}{\G\vdash\f:\t}

\inferrule*[lab=WFMeth]{\G \vdash \t \\ \bar{\G \vdash \t'} \\ \G,\this:this(\G),\bar{x:\t'} \vdash e : \t}{\G \vdash \m(\bar{x:\t'}):\t = e}

\inferrule*[lab=WFSelfGet]{f:\t \in fields(\G)}{\G \vdash f():\t = \xt{this}.f}

\inferrule*[lab=WFDelGet]{f:\t \not\in fields(\G) \\ \G \vdash e : \t}{\G \vdash f():\t = e}

\inferrule*[lab=WFSelfSet]{f:\t \in fields(\G)}{\G \vdash f!(\xt{x}:\t):\t = (\xt{this}.f=\xt{x})}

\inferrule*[lab=WFDelSet]{f:\t \not\in fields(\G) \\ \G,\xt{x}:\t \vdash e : \t}{\G \vdash f!(\xt{x}:\t):\t = e}
\end{mathpar}
}