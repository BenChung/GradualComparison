%!TEX output_directory=pdfs
\documentclass[a4paper,UKenglish,final]{lipics}
\usepackage{xspace,listings,url,framed,amssymb,
            amsmath,mathpartir,hyperref,stmaryrd, graphicx}
\input{macros}
\begin{document}

\section*{Target Langage}

The target language (TL) is a parred down statically typed object calculus. The
calculus has non-recursive structural substyping\footnote{\bf I am not sure
  that this is the right way to describe what we do -- check. JV} but no
inheritance.\footnote{Structural subtyping is needed for type systems that
  have a notion of ``consistency''. Inheritance does not add anything other
  than code reuse.}  The calculus does not have null values.\footnote{Null
  adds a source of error but otherwise should not be too interesting. We
  should mention something about the type of null.} Fields are accessed by
automicatlly providedd getter and setter methods.\footnote{This is because
  we want an easy way to interpose on field access in wrappers.} Fields
appear in type signatures only through the presence of the getter and setter
methods. Following C\# 4.0~\cite{} the TL allows a dynamic type, denoted
\any, and dynamically-typed method invocation, denoted 

\center\begin{minipage}{4cm}\begin{tabular}{l@{~~~}l}
\e &::=  \x \\
   \Alt{ \Get\e\f }
   \Alt{ \Set\e\f\e }
   \Alt{ \Call\e\m\e }
   \Alt{ \New\C{\b\e} }
   \Alt{ \tCast\t\e }
   \Alt{ \wCast\t\e }
   \Alt{ \cCast\t\e }
   \Alt{ \mCast\t\e }
   \Alt{ \a }
\end{tabular}\end{minipage}\begin{minipage}{4cm}\begin{tabular}{l@{~~~}l}
\md &::=
   \Mdef\m\x\t\t\e \\
   \Alt{ \Mdef\f\x\t\t\e}
   \Alt{ \Mdefz\f\t\e} 
\k &::= \Class \C {\b{\Ftype\f\t}}{\b\md} \\
\mt &::= \Mtype\m\t\t\\
   \Alt{ \Mtype\f\t\t}
   \Alt{ \Mtype\f{}\t}
\E &::= \Ftype\x\t  \B \none\\
\t &::= ~ \any  \B   \Type{\b\mt} 
\end{tabular}\end{minipage}

\hrulefill

\begin{minipage}{8cm}
  \opdef{\Reduce \K\e\s \Kp\ep\sp}
        {\e\s evaluates to \ep in a step}\\[-1mm]
\begin{tabular}{@{}l@{}l@{~}l@{~}l}
\CondRule{E1}{ %% e -> e'
  \Reduce \K\e\s \Kp\ep\sp
}{
 \ReduceA \K{\Ctx\e}\s \Kp{\Ctx\ep}\sp
}
\CondRule{E2}{ %% new C -> a
   \alloc \sp\ap\s{\Obj{\b\a}\C}
}{ 
    \ReduceA \K{\New\C{\b\a}}\s \K\ap\sp
}
\CondRule{E3}{ %% a.m(a) -> e
   \dispatch \x\e\s\a\m
}{
   \ReduceA \K\s{\Call\a\m\ap} \K{[\a/\this~{\ap/\x}]\e}\s
}
\CondRule{E4}{ %% a.f(a) -> e
   \dispatch \x\e\s\a\f
}{
   \ReduceA \K\s{\Call\a\f\ap} \K{[\a/\this~{\ap/\x}]\e}\s
}
\CondRule{E5}{ %% a.f() -> e
   \dispatch{\!}\e\s\a\f
}{
   \ReduceA \K\s{\Call\a\f{}} \K{[\a/\this]\e}\s
}
\CondRule{E6}{ 
     \readfield \ap\s\a\f
}{
  \ReduceA \K{\Get\a\f}\s  \K\ap\s
}
\CondRule{E7}{
     \setfield \sp\s\a\f\ap
}{
     \ReduceA \K{\Set\a\f\ap}\s \K\ap\sp
}
\CondRule{E8}{
  \cast \a\t\s\K{w}  \Kp\e\sp
}{ 
    \ReduceA  \K{\wCast \tp\a}\s \Kp\e\sp
}
\CondRule{E9}{
  \cast \a\t\s\K\m  \Kp\e\sp
}{ 
    \ReduceA \K{\mCast\tp\a}\s \Kp\e\sp
}
\CondRule{E10}{
  \cast \a\t\s\K c  \Kp\e\sp
}{ 
   \ReduceA \K{\cCast \tp\a}\s \Kp\e\sp
}
\CondRule{E11}{
  \cast \a\t\s\K c  \Kp\e\sp
}{ 
   \ReduceA \K{\tCast \tp\a}\s \Kp\e\sp
}
\end{tabular}\end{minipage}

%%%%%%%%%%%%%%%%%%% CONTEXTS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
~\\[3mm]

\begin{minipage}{4cm}\begin{tabular}{l@{~~}l@{~}l}
\s &::= ~~\none ~~ \B ~~
    \Heap\s{\Bind\a{\Obj{\b\a}\C}}\\[2mm]
\E &::= \Get\square\f     ~\B~
        \Set\square\f\e   ~\B~
        \Set\a\f\square   ~\B~  
        \Call\square\m\e   ~\B~
       \Call\a\m{\square} \\
   &\B~
       \mCast\t\square  ~\B~
       \wCast\t\square  ~\B~
       \cCast\t\square \\ &\B~
       \tCast\t\square  ~\B~
       \New\C{\b \a\,\square\,\b\e}
\end{tabular}
\end{minipage}

~\\

\hrulefill

\opdef{$\t \Sub \tp$}{\t is a subtype of \tp}
\begin{mathpar}
\IRule{S-Ref}{
}{
  \t \Sub \t
}

\IRule{S-Top}{
}{
  \t \Sub {\Type{}}
}

\IRule{S-Rec}{
  \t_1 \Sub \t_2 \\
  \t_2' \Sub \t_1' \\
  \Type{ \b{\mt_1}} \Sub \Type{\b{\mt_2}}
}{
  \Type{\Mtype\m{\t_1}{\t_1'}~\b{\mt_1}\,} \Sub
  \Type{\Mtype\m{\t_2}{\t_2'}~\b{\mt_2}\,} 
}


\IRule{S-Rec-2}{
  \t_1 \Sub \t_2 \\
  \Type{ \b{\mt_1}} \Sub \Type{\b{\mt_2}}
}{
  \Type{\Mtype\f{}{\t_1}~\b{\mt_1}\,} \Sub
  \Type{\Mtype\f{}{\t_2}~\b{\mt_2}\,} 
}


\IRule{S-Rec-3}{
  \t_1 \Sub \t_2 \\
  \t_2 \Sub \t_1 \\
  \Type{ \b{\mt_1}} \Sub \Type{\b{\mt_2}}
}{
  \Type{\Mtype\f{\t_1}{\t_1}~\b{\mt_1}\,} \Sub
  \Type{\Mtype\f{\t_2}{\t_2}~\b{\mt_2}\,} 
}
\end{mathpar}


\hrulefill

\opdef{\EnvType\Es\e\t}{\e has type \t in environment \E against heap \s}
\begin{mathpar}
\IRule{W1}{
   \HasType \E\x\t
 }{
   \EnvType \Es\x\t
}

\IRule{W2}{
  \EnvType \Es\e\tp \\
  \tp \Sub \t
 }{
   \EnvType \Es\e\t 
}   

\IRule{W3}{
  \EnvType \Es\e\t \\
  \Mtype \m\tp{\t_1}\inc \t  \\
  \EnvType \Es\ep\tp
}{
  \EnvType \Es{\Call\e\m\ep}{\t_1}
}    

\IRule{W4}{
  \b{\EnvType \Es\e\t} \\ 
  \Class \C {\b{\Ftype\f\t}} {\b\md}
}{
  \EnvType \Es{\New\C{\b\e}}\C
}

\IRule{W5}{
  \EnvType \Es\e\tp
}{
  \EnvType \Es{\tCast\t\e}\t
}

\IRule{W6}{
  \EnvType \Es\e\tp
}{
  \EnvType \Es{\cCast\t\e}\t
}

\IRule{W7}{
  \EnvType \Es\e\tp
}{
  \EnvType \Es{\mCast\t\e}\t
}

\IRule{W8}{
  \EnvType \Es\e\tp
}{
   \EnvType \Es{\wCast\t\e}\t
}

\IRule{W9}{
  \EnvType \Es\e\tp \\
  \Mtype \f{}\t \in \tp
}{
  \EnvType \Es{\Get\e\f}\t
}

\IRule{W10}{
  \EnvType \Es\e\t \\
  \Mtype\f\tp\tp \in \t \\
  \EnvType \Es\ep\tp
}{
  \EnvType \Es{\Set\e\f\ep}\tp
}

\IRule{W11}{
  \s(\a) = \Obj{\b{\a_1}}\C 
}{
  \EnvType \Es\a\C
}
\end{mathpar}


\hrulefill

\begin{mathpar}
\IRule{Cast-Wrap}{
  \D\;\mathit{free} \\
  \Heap \s{\Bind \a{\Obj{\b\ap}\C} } \\
  \Kp = \K\;\wrapper{\C \Rightarrow \t,\D}
}{
  \cast\a\t\s\K{b}  \Kp {\New \D\a} \s
}

\IRule{Cast-Mono1 (monotonic)}{
  \Heap \s{\Bind \a{\Obj{\a_1 \dots \a_n}\C}} \\
  \C \not\equiv \meet \t\C \\
  \Kp = \K\;\spec{\Class\C{\b{\Ftype\f\t}}{\b\md}, \D, \meet \t\C} \\
  \sp = \Heap \s{\Bind \a{\Obj{\b{\a_1}}\D}} \\
  \s_1 = \castfn{\a_1}{\t_1}{\sp}\Kp \\ \ldots \\
  \s_n = \castfn{\a_n}{\t_n}{\s_{n-1}}\Kp \\
}{
  \cast \a\t\s\K m   \Kp \a {\s_n}\\
}


\IRule{Cast-Mono2 (monotonic)}{
  \Heap \s{\Bind \a{\Obj{\b{\a_1}}\C}} \\
  \C \equiv \meet \t\C
}{
  \cast \a\t\s\K m  \K\a\s
}

\IRule{Cast-Check (concrete)}{
  \Heap \s{\Bind \a{\Obj{\b{\a_1}}\C}} \\
  \C <: \t
}{
  \cast \a\t\s\K c  \K\a\s
}

\IRule{Cast-Any (star)}{
}{
  \cast \a\any\s\K x   \K\a\s
}

\end{mathpar}


\hrulefill


\begin{mathpar}
\IRule{UTWrap}{
   \Class\C{\b{\Mdef\m\x{\tp1}{\tp2}\e}~\b{\Mdef{\m'_u}\x{\tp1}{\tp2}\e}}
}{
    \wrapper{\C\Rightarrow\any,\D} = \Class \D{\xt{s}:\C}{\b{\Mdef{\m_\xt{u}}\x{\any}\any{\cCast \any{\this.\xt{s}.\m(\b{\cCast{\tp1}{\x}})}}} ~ \b{\Mdef{\m'_u}\x{\tp1}{\tp2}{\xt{s}.\m'_u(\b{x})}}}
}

\IRule{TWrap}{
	\Class\C{\b\fd}{\b\md} \\ 
}{
	\wrapper{\C\Rightarrow\{\b{\mt}\},\D} = \Class \D{\xt{s} : \C}{\tw{\b\md, \b\mt} ~ {\utw{\b\md, \b\mt}}}
}

\IRule{MTWrap}{
}{
  \tw{\Mdef{\m_\xt{u}}\x\any\any\e;\b{\md},\Mtype\m{\b{\tp1}}{\tp2};\b{\mt}} = \Mdef{\m}\x{\tp1}{\tp2}{\cCast{\tp2}{\this.\xt{s}.{\m_\xt{u}(\b{\cCast{\any}{\x}})}}} ~ \tw{\b{\md},\b{\mt}}
}

\IRule{MUTWrap}{
	\m \not\in\b{\mt}
}{
  \utw{\Mdef{\m_\xt{u}}\x\any\any\e;\b{\md},\b{\mt}} = \Mdef{\m_\xt{u}}\x\any\any\e ~ \utw{\b{\md},\b{\mt}}
}
\end{mathpar}


\hrulefill

\opdef{
  $\meet{\t_1}{\t_2} \equiv \t$
}{
  The most specific type common to $\t_1$ and $\t_2$ is $\t$
}
\begin{mathpar}
\IRule{M1}{ }{\meet{\t}{\any} \equiv \t}

\IRule{M2}{ }{\meet{\any}{\t} \equiv \t}

\IRule{M3}{ }{\meet{\t}{\t} \equiv \t}

\IRule{M4}{
      \b{\meet{\t_3}{\t_1}  \equiv \t_5} \\
    \meet{\t_2}{\t_4} \equiv \t_6\\
    \meet{\Type{\b{\md_1}}}{\Type{\b{\md_2}}} \equiv \Type{\b{\md_3}} 
}{
  \meet{\Type{\Mtype\m{\t_1}{\t_2}~ \b{\md_1}}}{\Type{\Mtype\m{\t_3}{\t_4} ~ \b{\md_2}}} \equiv \Type{\Mtype\m{\b{\t_5}}{\t_6} ~ \b{\md_3}}
}
\end{mathpar}

\hrulefill

\begin{mathpar}
\IRule{Refine-Method}{
  \b{\meet{\t_1}{\t_1'} = \t_1''}\\
  {\meet{\t_2}{\t_2'} = \t_2''}
}{
  \spec{\m(\b{\x:\t_1}):\t_2 = \e,\m(\b{\t_1'}):\t_2'} = 
  (\m(\b{\x:\t_1''}):\t_2'' = \cCast{\t_2''}{\e}), \\
  (\m_\xt{u}(\b{\x:\any}):\any = \cCast{\any}{\this.{\m}(\cCast{\t_1''}{\x})})
}

\IRule{Refine-Class}{
  \b{\meet{\t}{\t'} = \t''}
}{
  \spec{\Class{\C}{\b{\f : \t}}{\b{\md}}, \xt{D}, \{\b{\f():\t'},\b{\mt}\}} = \Class{\D}{\b{\f : \t''}}{\b{\spec{\f:\t,\t'}},\b{\spec{\md,\mt}}}
}
\end{mathpar}


\hrulefill

\begin{mathpar}
\IRule{Insert-Recv (eager cast)}{
  \GenCast \E{\e_1}{\e_3}{\t_1} \\
  \m(\b{x : \t_2}):\t_3 \in \t_1 \\
  \b{\AnaCast \E{\e_2}{\e_4}{\t_2}}
}{
  \inv \E{\Call{\e_1}\m{\b{\e_2}}} = \Call{\e_3}{\m}{\b{\e_4}}, \t_3
}

\IRule{Insert-Dyn}{
  \GenCast{\E}{\e_1}{\e_3}{\any} \\
  \AnaCast{\E}{\e_2}{\e_4}{\any}
}{
  \inv \E{\Call{\e_1}\m{\b{\e_2}}} =
  \Call{\cCast{(\Type{\Mtype{\m_\xt{u}}{\b\any}\any}}{\e_3})}{\m_\xt{u}}{\b{\e_4}}, \any
}

\IRule{Insert-Check (lazy cast)}{
  \GenCast \E{\e_1}{\e_3}{\t_1} \\
  \m(\b{x : \t_2}):\t_3 \in \t_1 \\
  \b{\AnaCast \E{\e_2}{\e_4}{\t_2}}
}{
  \inv{\E}{\Call{\e_1}\m{\b{\e_2}}} =
  \cCast{\t_1}{(\Call{(\cCast{\Type{\Mtype{\m_\xt{u}}{\b\any}\any}}{\e_3})}{\m_\xt{u}}{\b{\cCast \any{\e_4}}})}, \t_1
}
\end{mathpar}

\end{document}
\section{Addendum}

\input{figures/syncast}

\hrulefill

\input{figures/anacast}

\hrulefill

\input{figures/classtrans}

\hrulefill

\input{figures/conssub}

\hrulefill

\begin{mathpar}
\IRule{No-Cons}{ \t_1 \Sub \t_2 }{\MetaSub{\t_1}{\t_2}}

\IRule{Has-Cons}{\stcons{\t_1}{\t_2}}{\MetaSub{\t_1}{\t_2}}
\end{mathpar}

\end{document}
