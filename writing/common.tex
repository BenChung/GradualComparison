%!TEX output_directory=pdfs
\documentclass[a4paper,UKenglish,final]{lipics}
\usepackage{xspace,listings,url,framed,amssymb,
            amsmath,mathpartir,hyperref,stmaryrd, graphicx}
\input{macros}
\begin{document}

\section*{Target Langage}

The target language (TL) is a parred down statically typed object
calculus. The calculus has non-recursive structural substyping\footnote{\bf
  I am not sure that this is the right way to describe what we do --
  check. JV} but no inheritance.\footnote{Structural subtyping is needed for
  type systems that have a notion of ``consistency''. Inheritance does not
  add anything other than code reuse.}  The calculus does not have null
values.\footnote{Null adds a source of error but otherwise should not be too
  interesting. We should mention something about the type of null.} Fields
are accessed by automicatlly providedd getter and setter methods, denoted
\Get\x\f and \Set\x\f\e.\footnote{This is because we want an easy way to
  interpose on field access in wrappers.} Fields appear in type signatures
only through the presence of the getter and setter methods. Method calls are
denoted \Call\x\m\e.\footnote{The single argument limitation is purely to
  lighten the notation.} Following C\# 4.0~\cite{} the TL allows a dynamic
type, denoted \any, and dynamically-typed method invocation, denoted
\DynCall\x\m\e. Dynamically-typed method invocation treats all arguments as
\any. A new object is created with a class name and a sequence of arguments
given in the order of definition of fields, \New\C{\b\e}.  Meta-variable \x
ranges over argument names, \a over memory locations, \f over field names,
\m over method names, \C over class names. The language has four different
kinds of cast expressions (described below).

\begin{minipage}{7cm}\begin{tabular}{l@{~~}l@{}l@{}l@{}l}
\e &::=  \x \\
   &\B \Get\e\f    &\B \Set\e\f\e    &\B \Call\e\m\e    \\
   &\B \DynGet\e\f &\B \DynSet\e\f\e &\B \DynCall\e\m\e \\
   \Alt{ \New\C{\b\e} }
   &\B \tCast\t\e  &\B \wCast\t\e    &\B \cCast\t\e &\B  \mCast\t\e \\
   \Alt{ \a }
\end{tabular}\end{minipage}
~~
\begin{minipage}{6cm}\begin{tabular}{l@{~~}l@{}l}
\k &::= \Class \C {\b{\Ftype\f\t}}{\b\md} \\
\end{tabular}
\begin{tabular}{l@{~~}l@{}l@{}l}
\md &::= \Mdef\m\x\t\t\e \\
    &\B  \Mdef\f\x\t\t\e ~\B~ \Mdefz\f\t\e \\
\mt &::= \Mtype\m\t\t ~\B~  \Mtype\f\t\t  ~\B~ \Mtype\f{}\t \\
\E &::= \Ftype\x\t  \B \none\\
\t &::= ~ \any  \B   \Type{\b\mt} 
\end{tabular}\end{minipage}

The semantics of TL is defined by a small step operational semantics with
evaluation contexts.  The context are deterministic. Program error is
denoted by a stuck term. Meta-variable \k ranges over class definitions.
The sematnics operate over an explicit class table, denoted \K, which is a
sequence of class definitions. A heap, denoted \s, maps memory locations to
objects. We use the notation \Heap\s{\Bind\a{\obj\C{\b\a}}} to denote the
heap \s extended by the binding of location \a to object \obj\C{\b\a}.  A
configuration \K\e\s evaluates in one step to a new configuration, denoted
\Reduce \K\e\s \Kp\ep\sp. Execution terminate if \ep\xspace is a value, \a,
or if there is no applicable reduction, in which case the program is
stuck.\footnote{Intuitively we would expect that the program can only get
  stuck at dynamic calls or at structural casts. But generative casts add
  some complexity to that statement.}

The \dispatch \x\e\s\a\f

\hrulefill

\begin{minipage}{8cm}
  \opdef{\Reduce \K\e\s \Kp\ep\sp}
        {\e\s evaluates to \ep\xspace in a step}\\[-1mm]
\begin{tabular}{@{}l@{}l@{~}l@{~}l}
\CondRule{E1}{ %% e -> e'
  \Reduce \K\e\s \Kp\ep\sp
}{
 \ReduceA \K{\Ctx\e}\s \Kp{\Ctx\ep}\sp
}
\CondRule{E2}{ %% new C -> a
   \sp = \Heap\s{\Bind\ap{\obj\C{\b\a}}} $\wedge ~$ \ap fresh
}{ 
    \ReduceA \K{\New\C{\b\a}}\s \K\ap\sp
}
\CondRule{E3}{ %% a.m(a) -> e
    \Mdef\m\x\t\tp\e \In \classof\s\a $\wedge~ \t \not= \any$
}{
   \ReduceA \K\s{\Call\a\m\ap} \K{[\a/\this~{\ap/\x}]\e}\s
}
\CondRule{E4}{ %% a.f(a) -> e
    \Mdef\f\x\t\tp\e \In \classof\s\a $\wedge~ \t \not= \any$
}{
   \ReduceA \K\s{\Call\a\f\ap} \K{[\a/\this~{\ap/\x}]\e}\s
}
\CondRule{E5}{ %% a.f() -> e
    \Mdefz\f\t\e \In \classof\s\a $\wedge~ \t \not= \any$
}{
   \ReduceA \K\s{\Call\a\f{}} \K{[\a/\this]\e}\s
}
\CondRule{E3}{ %% a.m(a) -> e
    \Mdef\m\x\any\any\e \In \classof\s\a
}{
   \ReduceA \K\s{\DynCall\a\m\ap} \K{[\a/\this~{\ap/\x}]\e}\s
}
\CondRule{E4}{ %% a.f(a) -> e
    \Mdef\f\x\any\any\e \In \classof\s\a 
}{
   \ReduceA \K\s{\DynCall\a\f\ap} \K{[\a/\this~{\ap/\x}]\e}\s
}
\CondRule{E5}{ %% a.f() -> e
    \Mdefz\f\any\e \In \classof\s\a 
}{
   \ReduceA \K\s{\DynCall\a\f{}} \K{[\a/\this]\e}\s
}
\CondRule{E6}{ 
     \readfield \ap\s\a\f
}{
  \ReduceA \K{\Get\a\f}\s  \K\ap\s
}
\CondRule{E7}{
     \setfield \sp\s\a\f\ap
}{
     \ReduceA \K{\Set\a\f\ap}\s \K\ap\sp
}
\CondRule{E8}{
  \cast \a\t\s\K{w}  \Kp\e\sp
}{ 
    \ReduceA  \K{\wCast \tp\a}\s \Kp\e\sp
}
\CondRule{E9}{
  \cast \a\t\s\K\m  \Kp\e\sp
}{ 
    \ReduceA \K{\mCast\tp\a}\s \Kp\e\sp
}
\CondRule{E10}{
  \cast \a\t\s\K c  \Kp\e\sp
}{ 
   \ReduceA \K{\cCast \tp\a}\s \Kp\e\sp
}
\CondRule{E11}{
  \cast \a\t\s\K c  \Kp\e\sp
}{ 
   \ReduceA \K{\tCast \tp\a}\s \Kp\e\sp
}
\end{tabular}\end{minipage}

%%%%%%%%%%%%%%%%%%% CONTEXTS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
~\\[3mm]

\begin{minipage}{4cm}\begin{tabular}{l@{~~}l@{~}l}
\s &::= ~~\none ~~ \B ~~
    \Heap\s{\Bind\a{\obj\C{\b\a}}}\\[2mm]
\E &::= \Get\square\f     ~\B~
        \Set\square\f\e   ~\B~
        \Set\a\f\square   ~\B~  
        \Call\square\m\e   ~\B~
       \Call\a\m{\square} \\
   &\B~
       \mCast\t\square  ~\B~
       \wCast\t\square  ~\B~
       \cCast\t\square \\ &\B~
       \tCast\t\square  ~\B~
       \New\C{\b \a\,\square\,\b\e}
\end{tabular}
\end{minipage}

~\\

\hrulefill

\opdef{$\t \Sub \tp$}{\t is a subtype of \tp}
\begin{mathpar}
\IRule{S-Ref}{
}{
  \t \Sub \t
}

\IRule{S-Top}{
}{
  \t \Sub {\Type{}}
}

\IRule{S-Rec}{
  \t_1 \Sub \t_2 \\
  \t_2' \Sub \t_1' \\
  \Type{ \b{\mt_1}} \Sub \Type{\b{\mt_2}}
}{
  \Type{\Mtype\m{\t_1}{\t_1'}~\b{\mt_1}\,} \Sub
  \Type{\Mtype\m{\t_2}{\t_2'}~\b{\mt_2}\,} 
}


\IRule{S-Rec-2}{
  \t_1 \Sub \t_2 \\
  \Type{ \b{\mt_1}} \Sub \Type{\b{\mt_2}}
}{
  \Type{\Mtype\f{}{\t_1}~\b{\mt_1}\,} \Sub
  \Type{\Mtype\f{}{\t_2}~\b{\mt_2}\,} 
}


\IRule{S-Rec-3}{
  \t_1 \Sub \t_2 \\
  \t_2 \Sub \t_1 \\
  \Type{ \b{\mt_1}} \Sub \Type{\b{\mt_2}}
}{
  \Type{\Mtype\f{\t_1}{\t_1}~\b{\mt_1}\,} \Sub
  \Type{\Mtype\f{\t_2}{\t_2}~\b{\mt_2}\,} 
}
\end{mathpar}


\hrulefill

\opdef{\EnvType\Es\e\t}{\e has type \t in environment \E against heap \s}
\begin{mathpar}
\IRule{W1}{
   \HasType \E\x\t
 }{
   \EnvType \Es\x\t
}

\IRule{W2}{
  \EnvType \Es\e\tp \\
  \tp \Sub \t
 }{
   \EnvType \Es\e\t 
}   

\IRule{W3}{
  \EnvType \Es\e\t \\
  \Mtype \m\tp{\t_1}\inc \t  \\
  \EnvType \Es\ep\tp
}{
  \EnvType \Es{\Call\e\m\ep}{\t_1}
}    

\IRule{W4}{
  \b{\EnvType \Es\e\t} \\ 
  \Class \C {\b{\Ftype\f\t}} {\b\md}
}{
  \EnvType \Es{\New\C{\b\e}}\C
}

\IRule{W5}{
  \EnvType \Es\e\tp
}{
  \EnvType \Es{\tCast\t\e}\t
}

\IRule{W6}{
  \EnvType \Es\e\tp
}{
  \EnvType \Es{\cCast\t\e}\t
}

\IRule{W7}{
  \EnvType \Es\e\tp
}{
  \EnvType \Es{\mCast\t\e}\t
}

\IRule{W8}{
  \EnvType \Es\e\tp
}{
   \EnvType \Es{\wCast\t\e}\t
}

\IRule{W9}{
  \EnvType \Es\e\tp \\
  \Mtype \f{}\t \in \tp
}{
  \EnvType \Es{\Get\e\f}\t
}

\IRule{W10}{
  \EnvType \Es\e\t \\
  \Mtype\f\tp\tp \in \t \\
  \EnvType \Es\ep\tp
}{
  \EnvType \Es{\Set\e\f\ep}\tp
}

\IRule{W11}{
  \s(\a) = \obj\C{\b{\a_1}}
}{
  \EnvType \Es\a\C
}
\end{mathpar}


\hrulefill

\begin{mathpar}
\IRule{Cast-Wrap}{
  \D\;\mathit{free} \\
  \Heap \s{\Bind \a{\obj\C{\b\ap}} } \\
  \Kp = \K\;\wrapper{\C \Rightarrow \t,\D}
}{
  \cast\a\t\s\K{b}  \Kp {\New \D\a} \s
}

\IRule{Cast-Mono1 (monotonic)}{
  \Heap \s{\Bind \a{\obj\C{\a_1 \dots \a_n}}} \\
  \C \not\equiv \meet \t\C \\
  \Kp = \K\;\spec{\Class\C{\b{\Ftype\f\t}}{\b\md}, \D, \meet \t\C} \\
  \sp = \Heap \s{\Bind \a{\obj\D{\b{\a_1}}}} \\
  \s_1 = \castfn{\a_1}{\t_1}{\sp}\Kp \\ \ldots \\
  \s_n = \castfn{\a_n}{\t_n}{\s_{n-1}}\Kp \\
}{
  \cast \a\t\s\K m   \Kp \a {\s_n}\\
}


\IRule{Cast-Mono2 (monotonic)}{
  \Heap \s{\Bind \a{\obj\C{\b{\a_1}}}} \\
  \C \equiv \meet \t\C
}{
  \cast \a\t\s\K m  \K\a\s
}

\IRule{Cast-Check (concrete)}{
  \Heap \s{\Bind \a{\obj\C{\b{\a_1}}}} \\
  \C <: \t
}{
  \cast \a\t\s\K c  \K\a\s
}

\IRule{Cast-Any (star)}{
}{
  \cast \a\any\s\K x   \K\a\s
}

\end{mathpar}


\hrulefill


\begin{mathpar}
\IRule{UTWrap}{
   \Class\C{\b{\Mdef\m\x{\tp1}{\tp2}\e}~\b{\Mdef{\m'_u}\x{\tp1}{\tp2}\e}}
}{
    \wrapper{\C\Rightarrow\any,\D} = \Class \D{\xt{s}:\C}{\b{\Mdef{\m_\xt{u}}\x{\any}\any{\cCast \any{\this.\xt{s}.\m(\b{\cCast{\tp1}{\x}})}}} ~ \b{\Mdef{\m'_u}\x{\tp1}{\tp2}{\xt{s}.\m'_u(\b{x})}}}
}

\IRule{TWrap}{
	\Class\C{\b\fd}{\b\md} \\ 
}{
	\wrapper{\C\Rightarrow\{\b{\mt}\},\D} = \Class \D{\xt{s} : \C}{\tw{\b\md, \b\mt} ~ {\utw{\b\md, \b\mt}}}
}

\IRule{MTWrap}{
}{
  \tw{\Mdef{\m_\xt{u}}\x\any\any\e;\b{\md},\Mtype\m{\b{\tp1}}{\tp2};\b{\mt}} = \Mdef{\m}\x{\tp1}{\tp2}{\cCast{\tp2}{\this.\xt{s}.{\m_\xt{u}(\b{\cCast{\any}{\x}})}}} ~ \tw{\b{\md},\b{\mt}}
}

\IRule{MUTWrap}{
	\m \not\in\b{\mt}
}{
  \utw{\Mdef{\m_\xt{u}}\x\any\any\e;\b{\md},\b{\mt}} = \Mdef{\m_\xt{u}}\x\any\any\e ~ \utw{\b{\md},\b{\mt}}
}
\end{mathpar}


\hrulefill

\opdef{
  $\meet{\t_1}{\t_2} \equiv \t$
}{
  The most specific type common to $\t_1$ and $\t_2$ is $\t$
}
\begin{mathpar}
\IRule{M1}{ }{\meet{\t}{\any} \equiv \t}

\IRule{M2}{ }{\meet{\any}{\t} \equiv \t}

\IRule{M3}{ }{\meet{\t}{\t} \equiv \t}

\IRule{M4}{
      \b{\meet{\t_3}{\t_1}  \equiv \t_5} \\
    \meet{\t_2}{\t_4} \equiv \t_6\\
    \meet{\Type{\b{\md_1}}}{\Type{\b{\md_2}}} \equiv \Type{\b{\md_3}} 
}{
  \meet{\Type{\Mtype\m{\t_1}{\t_2}~ \b{\md_1}}}{\Type{\Mtype\m{\t_3}{\t_4} ~ \b{\md_2}}} \equiv \Type{\Mtype\m{\b{\t_5}}{\t_6} ~ \b{\md_3}}
}
\end{mathpar}

\hrulefill

\begin{mathpar}
\IRule{Refine-Method}{
  \b{\meet{\t_1}{\t_1'} = \t_1''}\\
  {\meet{\t_2}{\t_2'} = \t_2''}
}{
  \spec{\m(\b{\x:\t_1}):\t_2 = \e,\m(\b{\t_1'}):\t_2'} = 
  (\m(\b{\x:\t_1''}):\t_2'' = \cCast{\t_2''}{\e}), \\
  (\m_\xt{u}(\b{\x:\any}):\any = \cCast{\any}{\this.{\m}(\cCast{\t_1''}{\x})})
}

\IRule{Refine-Class}{
  \b{\meet{\t}{\t'} = \t''}
}{
  \spec{\Class{\C}{\b{\f : \t}}{\b{\md}}, \xt{D}, \{\b{\f():\t'},\b{\mt}\}} = \Class{\D}{\b{\f : \t''}}{\b{\spec{\f:\t,\t'}},\b{\spec{\md,\mt}}}
}
\end{mathpar}


\hrulefill

\begin{mathpar}
\IRule{Insert-Recv (eager cast)}{
  \GenCast \E{\e_1}{\e_3}{\t_1} \\
  \m(\b{x : \t_2}):\t_3 \in \t_1 \\
  \b{\AnaCast \E{\e_2}{\e_4}{\t_2}}
}{
  \inv \E{\Call{\e_1}\m{\b{\e_2}}} = \Call{\e_3}{\m}{\b{\e_4}}, \t_3
}

\IRule{Insert-Dyn}{
  \GenCast{\E}{\e_1}{\e_3}{\any} \\
  \AnaCast{\E}{\e_2}{\e_4}{\any}
}{
  \inv \E{\Call{\e_1}\m{\b{\e_2}}} =
  \Call{\cCast{(\Type{\Mtype{\m_\xt{u}}{\b\any}\any}}{\e_3})}{\m_\xt{u}}{\b{\e_4}}, \any
}

\IRule{Insert-Check (lazy cast)}{
  \GenCast \E{\e_1}{\e_3}{\t_1} \\
  \m(\b{x : \t_2}):\t_3 \in \t_1 \\
  \b{\AnaCast \E{\e_2}{\e_4}{\t_2}}
}{
  \inv{\E}{\Call{\e_1}\m{\b{\e_2}}} =
  \cCast{\t_1}{(\Call{(\cCast{\Type{\Mtype{\m_\xt{u}}{\b\any}\any}}{\e_3})}{\m_\xt{u}}{\b{\cCast \any{\e_4}}})}, \t_1
}
\end{mathpar}

\end{document}
\section{Addendum}

\input{figures/syncast}

\hrulefill

\input{figures/anacast}

\hrulefill

\input{figures/classtrans}

\hrulefill

\input{figures/conssub}

\hrulefill

\begin{mathpar}
\IRule{No-Cons}{ \t_1 \Sub \t_2 }{\MetaSub{\t_1}{\t_2}}

\IRule{Has-Cons}{\stcons{\t_1}{\t_2}}{\MetaSub{\t_1}{\t_2}}
\end{mathpar}

\end{document}
