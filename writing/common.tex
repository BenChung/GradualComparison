\documentclass[a4paper,UKenglish,final]{tex/lipics-v2016}
\usepackage{xspace,listings,url,framed,amssymb,
            amsmath,tex/mathpartir,hyperref,stmaryrd, graphicx, mathtools}
\input{macros}
\begin{document}



Type checking is standard.

Field accessor rules W3 and W4 require a typed receiver, since \any does
not have any methods a receiver typed at \any will never typecheck.

Shallow casts, W9, do not change the type of the expression. We are casting
to the name of \t not to \t.  In practice that means that all expression
types in Transient will drift towards \any.

\hrulefill

\opdef{\EnvType\Es\e\t}{\e has type \t in environment \E against heap \s}
\begin{mathpar}
\IRule{W1}{
   \HasType \E\x\t
 }{
   \EnvType \Es\x\t
}

\IRule{W2}{
  \EnvType \Es\e\tp \\
 \BasicType{\M{\none}}{\tp \Sub \t}
 }{
   \EnvType \Es\e\t 
}   

\IRule{W3}{
  \EnvType \Es\e\t \\
  \Mtype \f{}\tp \inc \t  
}{
  \EnvType \Es{\Get\e\f}\tp
}    

\IRule{W4}{
  \EnvType \Es\e\t \\
  \Mtype \f\tp\tp \inc \t  \\
  \EnvType \Es\ep\tp
}{
  \EnvType \Es{\Set\e\f\ep}\tp
}    

\IRule{W5}{
  \EnvType \Es\e\t \\
  \Mtype \m\tp\tpp\inc \t  \\
  \EnvType \Es\ep\tp
}{
  \EnvType \Es{\Call\e\m\ep}\tpp
}    

\IRule{W6}{
  \EnvType \Es\e\any \\
  \EnvType \Es\ep\any
}{
  \EnvType \Es{\DynCall\e\m\ep}\any
}    

\IRule{W7}{
  \b{\EnvType \Es\e\t} \\ 
  \Class \C {\b{\Ftype\f\t}} {\b\md}
}{
  \EnvType \Es{\New\C{\b\e}}\C
}

\IRule{W8}{
  \EnvType \Es\e\tp
}{
  \EnvType \Es{\SubCast\t\e}\t
}

\IRule{W9}{
  \EnvType \Es\e\tp
}{
  \EnvType \Es{\ShaCast\t\e}\any  %%!!!  not \t !!!
}

\IRule{W10}{
  \EnvType \Es\e\tp
}{
  \EnvType \Es{\BehCast\t\e}\t
}

\IRule{W11}{
  \EnvType \Es\e\tp
}{
   \EnvType \Es{\MonCast\t\e}\t
}

\IRule{W12}{
  \s(\a) = \obj\C{\b{\a_1}}
}{
  \EnvType \Es\a\C
}
\end{mathpar}

%%% defining the auxiliary functions below, they include:
%%% methdef
%%% typeof
%%% read (field)
%%% write (field)


\opdef{\convert{\md}}{Conversion function: Method definition to method type}

\convert{\Mdef\m\x\t\t\e} = \Mtype\m\t\t 

\convert{\Mdef\f\x\t\t\e} = \Mtype\f\t\t 

\convert{\Mdefz\f\t\e} = \Mtype\f{}\t 

\hrulefill

\opdef{\convertFD{\Ftype{\f}{\t}}}{Conversion function: Field definition to field types}

\convertFD{\Ftype{\f}{\t}} = \Mtype\f\t\t, \Mtype\f{}\t

\hrulefill

\opdef{\names{\mt}}{Naming function: Method types}

\names{\Mdef\m\x\t\t\e} = \m

\names{\Mdef\f\x\t\t\e} = \f

\names{\Mdefz\f\t\e} = \f

\hrulefill

\opdef{\names{\md}}{Naming function: Method definition\footnote{All of these simply functions should go into the appendix.}}

\names{\Mtype\m\t\t} = \m

\names{\Mtype\f\t\t} = \f

\names{\Mtype\f{}\t} = \f


% 
% \hrulefill
% 
% \opdef{\getmdef({\m,\C,\K})}{Gets the definition of \m in \C with respect to \K}
% 
% $\getmdef({\m,\C,\K_1 ~ \Class\C\fd{\md_1 ~ \Mdef\m\x{\t_1}{\t_2}{ \e } ~ \md_2} ~ \K_2}) = \Mdef\m\x{\t_1}{\t_2}{ \e }$
% 
% \hrulefill
% 
\newcommand{\getmtype}{\text{mtype}}
% 
% \opdef{\getmtype({\m,\C,\K})}{Gets the type of \m in \C with respect to \K}
% 
% $\getmtype({\m,\C,\K_1 ~ \Class\C\fd{\md_1 ~ \Mdef\m\x{\t_1}{\t_2}{ \e } ~ \md_2} ~ \K_2}) = \Mtype\m{\t_1}{\t_2}$

\section{Generative Casts}

\subsection{Behavioral}



\hrulefill

\begin{mathpar}
\IRule{Cast-Wrap}{
  \D\;\mathit{fresh} \\
  \ap\;\mathit{fresh} \\
  \obj\C{\b{\a_1}} = \s(\a) \\
  \sp = \Heap \s{\Bind \ap{\obj\D{\a}} } \\
  \k = \wrapper{\C,\t,\D}
}{
  \behcast\a\t\s\K {\K,~\Bind{\D}{\k}~}\ap\sp
}
\end{mathpar}

What does the wrap function do? In english.

At its core, the wrap function protects types. If a function on an object has a declared argument type, then the wrap function will produce a wrapper for that function that ensures that any argument passed in matches the declared type. Likewise, if we assert that an untyped function has a return type, then the generated wrapper guarantees that the returned value of the untyped function is of the asserted type by inserting a cast to the right type.

In our context, wrappers are just generated classes, produced when the runtime system encounters a behavioral cast. These casts need to ensure two key properties, which we will refer to as \emph{soundness} and \emph{completeness}. In the context of casts, soundness refers to correct enforcement of types, whereby protected methods will not observably violate their type guarantees, while completeness ensures that a cast will not lose methods.

This last requirement is somewhat unconventional, and its need is illustrated in a simple example. 

\begin{verbatim}
class C {
  m(x:int):int { ... }
}
class D {
  m(x:*):* { ... }
  f(x:*):* { ... }
}
(<D>(<C>new D()))@f(2)
\end{verbatim}

In this example, if we were to implement wrappers by wrapping over only the declared methods, despite D having a method f, it is "lost" when D is cast to C. As a result, when we cast it back from C to D, the wrapper added to ensure that C's invariants held does not have a method f, and our call will produce a method not understood exception. To avoid this issue, our wrappers will have to retain all untyped methods when casting untyped to typed, and typed methods if a typed cast does not mention them, so that they may be recovered in a later cast.

\hrulefill

\newcommand{\tfa}{\text{\emph{for every }}}
\newcommand{\wh}{\text{\emph{where}}}
\newcommand{\wc}{\text{wrapClass}}

\begin{align*}
\xt{n} &::= \m \B \f
\end{align*}

\begin{tabbing}
$\wrapper{\C,$\=$ \Cp, \D} = $\\
\>$\xt{class}~\D$\=$~\{$\\
\>\>$\xt{th}$\=$\xt{at} : \C $ \\
\>\>$\Mdefa\n{\b{\HT\x{\t_2}}}{\tp_2} { \BehCast{\tp_2}{\this.\that.\n(\b{\BehCast{\t_1}{\x}})}}$\\
\>\>\>$\tfa \Mtype\n{\b{\t_1}}{\tp_1} \in \classoff\C\K \wedge \Mtype\n{\b{\t_2}}{\tp_2} \in \classoff\Cp\K$\\
\\
\>\>$\Mdefa\n{\b{\HT\x{\t_1}}}{\tp_1} { \this.\that.\n(\b{\x})}$\\
\>\>\>$\tfa \Mtype\n{\b{\t_1}}{\tp_1} \in \classoff\C\K \wedge \Mtype\n{\b{\t_2}}{\tp_2} \not\in \classoff\Cp\K$\\
\\
\>\>$\Mdefa\n{\b{\HT\x{\t_2}}}{\tp_2} { \New{\xt{Error}}{}@\xt{error}()}$\\
\>\>\>$\tfa \Mtype\n{\b{\t_1}}{\tp_1} \not\in \classoff\C\K \wedge \Mtype\n{\b{\t_2}}{\tp_2} \in \classoff\Cp\K$\\
\>$\}$
\\
\\
$\wrapper{\C,$\=$ \any, \D} = $\\
\>$\xt{class}~\D$\=$~\{$\=\\
\>\>$\xt{that} : \C$ \\ \\
\>\>$\Mdefa\n{\b{\HT\x\any}}{\any}{\BehCast{\any}{\this.\xt{that}.\n(\b{\BehCast{\t}{\x}})}}$ \\
\>\>\>$\tfa \Mtype\n{\b{\t}}{\tp} \in \classoff\C$\\
\>$\}$\\
\end{tabbing}


\wc is more complex than TODO, because different wrappers are needed, depending on if the target type is a concrete type \C, or is the dynamic type \any. If the target type is \C, then it will generate the wrapper methods for the type \C, then insert ``passthrough'' methods. methods of the same type as the original and that just call the original internally, that provide the completness property mentioned above. Likewise, if the target type is \any, then \wc will simply generate a method that casts its argument to the right type and its return type to \any for every one of the typed methods in the source, ensuring soundness and completness.


\subsection{Monotone}

%The motivation behind the monotonic semantics is that we must ensure that every reference to an object is still valid up to \any types, and as a result, can only proceed by replacing \any types with concrete types, possibly recursively. We accomplish this by \emph{rewriting} the class that objects are associated with, enforcing the new type guarantee, while simultaneously checking that all of the extant field values match the type that they need to be.

%In order to do any of this, however, the new type of the object is required. In Siek et al.'s original formalism, the new type was computed simultaneously as the object was being cast, but this creates problems when recursive objects are encountered. For example, consider the following scenario:

%\begin{verbatim}
%class C { x:any y:any m(y:any):any }
%class D {}
%class E { x:{x:{y:int}} y:any}

%a = new C(new D(),2)
%b = new C(a, 2)
%a.x(b)
%c = <E>a
%\end{verbatim}

%Here, when we go to update the value at \x, we then need to go into the type recursively, which points to a new instance of \C. Then, we assert a new type for \x in that new \C, which sends us back to the starting object, where we update the type of \xt{y} to be int, from \any. As a result, we cannot cast simply by examining the statically knowable types, but have to consider the heap structure when determining the final typing for any object.

%We break this operation up into two steps:

%\begin{itemize}
%\item \emph{Type Determination}. We first determine a valid heap typing that both retains the monotonic property, while satisfying the new cast assertion. To do this, we recursively examine the heap structure, iterating until the heap is unchanged by the last type alteration.
%\item \emph{Heap Update}. In the previous phase, we only determined a new valid typing for the heap. In the second step, we take this typing and apply it to the objects that exist in the heap.
%\end{itemize}

%By splitting out the two concerns, we avoid issues where the future state of the heap depends on values produced in the casting process and that do not exist yet. 

Monotonic aims to have \emph{every typed reference still be valid}, including the ones that previously existed, as well as the reference created by the cast. If a reference has a type with a non-star value, then the monotonic semantics will ensure that that type is not violated. To accomplish this, the monotonic cast needs to make sure of two properties:
\begin{itemize}
\item The values that \emph{currently} exist cannot violate any of the types that point to them. Casting needs to recursively ensure that all values referred to by the current object are of the claimed type.
\item Functions can not be called with or return values that violate any of the types that they are referred to with. The behaviour of the class needs to check that its types are not violated by lesser-typed call sites.
\end{itemize}
The second property is strongly reminisicent of the behavioural semantics, though with the interesting caveat that we now need to make sure that \emph{all} method invocations follow the typed calling conventions, rather than just the ones that inherit this particular type assertion.


\hrulefill

\newcommand{\rectype}[1]{\xt{recType}(#1)}
\newcommand{\htype}[1]{\xt{hType}(#1)}
\newcommand{\fieldtypes}[1]{\xt{fieldTypes}(#1)}
\newcommand{\typeof}[1]{\xt{typeOf}(#1)}
\newcommand{\classgen}[1]{\xt{classGen}(#1)}

\begin{align*}
\Sigma &::= \b{\a:\t}
\end{align*}

\begin{mathpar}
\IRule{Cast-Mono (monotonic)}{
  \rectype{\a, \t, \s, \K, \cdot} = \Sigma~\Kp\\
  \spec{\Sigma, \s, \Kp} = \sp
}{
  \moncast \a\t\s\K   \Kp {\sp}\\
}
\end{mathpar}

\hrulefill

\begin{mathpar}
\IRule{HT1}{
  \a \not\in \text{addr}(\Sigma)
}{
  \htype{\a,\Sigma,\sigma[\a \mapsto \C\{\b\ap\}]} = \C
}

\IRule{HT2}{
}{
  \htype{\a,\Sigma~\a:\t~\Sigma,\sigma} = \t
}
\end{mathpar}

\hrulefill

\newcommand{\J}{\EMxt J}

\opdef{
  $\J \vdash \t \approx \t_1$
}{
}


\begin{mathpar}
\IRule{EQ1}{ \cdot \vdash \t <: \tp \\ \cdot \vdash \tp <: \t }{\t \approx \tp }
\end{mathpar}

\hrulefill

\renewcommand{\P}{\EMxt P}
\newcommand{\dmeet}[2]{#1\overset{\rightharpoonup}{\sqcap}#2}
\begin{mathpar}
\IRule{RC1}{
  \htype{\a,\Sigma,\sigma} = \tp\\
  \meett{\cdot, \K, \tp, \t} = \tpp~{\K'} \\ 
  \cdot \vdash \tp \not\approx \tpp \\
%   \fieldtypes{\tpp,\K,\s,\a} = \ap_1 \ldots \ap_n, \t^*_1 \ldots \t^*_n\\
%   \text{update}(\a : \tpp, \Sigma) = \Sigma_1\\
  \fieldtypes{\tpp,\K',\s,\a} = \a_1 \ldots \a_n~\t_1 \ldots \t_n\\
  \Sigma_1 = \text{update}(\a:\tpp,\Sigma) \\
  \K_1 = \K'\\
%   \b{\rectype{\ap, \t_f, \s, \K',\meet\Sigma{\a:\tpp}} = \Sigma'~\K''}
  \rectype{\a_1, \t_1, \s, \K_1, \Sigma_1} = \Sigma_{2}~\K_{2} ~~ \ldots ~~
  \rectype{\a_n, \t_n, \s, \K_n, \Sigma_n} = \Sigma_{n+1}~\K_{n+1}
}
{\rectype{\a, \t, \s, \K, \Sigma} = \Sigma_{n+1}, \K_{n + 1}}

\IRule{RC2}{
  \htype{\a,\Sigma,\sigma} = \tp\\
  \meett{\cdot, \K, \tp, \t} = \tpp~{\K'} \\
%   \cdot~\K \vdash \dmeet{\tp}{\t} \equiv \tpp \dashv \K'\\ % is this Omega right?
  \cdot \vdash \tp \approx \tpp \\
}{
  \rectype{\a, \t, \s, \K, \Sigma} = \Sigma~\K
}
\end{mathpar}

\hrulefill

\begin{mathpar}
\IRule{SP1}{
            \spec{\Sigma,\sigma,\K} = \sigma'}{
            \spec{\a : \D ~ \Sigma, \sigma[\a \mapsto \C\{\b{\ap}\}], \K} = \sigma'[\a\mapsto \D\{\b\ap\}]
            }


\IRule{SP2}{}{
            \spec{\cdot, \sigma, \K} = \cdot
            }
\end{mathpar}

The \texttt{spec} functin.


\hrulefill

\opdef{
  $\meett{\P, \K, \t, \tp} = {\tpp}~\K$
}{
%   Specializing $\t_1$ with $\t_2$ to produces $\t$ and $\K'$, under \P and \K 
}
\begin{align*}
\P &::= \b{(\t,\tp) \mapsto \tpp}
\end{align*}

\begin{mathpar}
\IRule{M1}{ }{\meett{\P, \K, \t, \any} = \t~\K}

\IRule{M2}{ }{\meett{\P, \K, \any, \t} = \t~\K}

\IRule{M3}{ }{\meett{\P, \K, \t, \t} = \t~\K}

\IRule{M4}{
  \EC \text{ fresh}\\
  ({\C},{\D}) \not\in \text{dom}(\P) \\
  {\P'} = \P,~({\C},{\D}) \mapsto \EC \\
  {\text{mtypes}}(\C,\K) = {\Type{\b\mt}}\\
  {\text{mtypes}}(\D,\K) = {\Type{\b\mtp}}\\
  \meett{{\P'}, {\K}, {\Type{\b\mt}}, {\Type{\b\mtp}}} = \tpp~{\K'}\\
  \K'' = \K'~\classgen{\C,\tpp,\EC,\K'}\\
}{
    \meett{\P, \K, \C, \D} = \EC~{\K''}
}

\IRule{M5}{
    \P({\C},{\D}) = \EC
}{
    \meett{\P, \K, \C, \D} = \EC~\K
}

\end{mathpar}

The \texttt{meet} functions takes four arguments, an environment $\P$, a class table $\K$, the original type $\t$, the cast type $\tp$, 
and outputs a type $\tpp$ and a class table $\Kp$. The environment $\P$ is a set of mappings from a pair of types ($\t,\tp$) to a type $\tpp$.


\hrulefill

\opdef{
  $\meett{\P, \K, {\Type{\b\mt}}, {\Type{\b\mt}}} = {\Type{\b\mt}}~\K$
}{
%   Specializing $\t_1$ with $\t_2$ to produces $\t$ and $\K'$, under \P and \K 
}

\begin{mathpar}
\IRule{M6}{ 
}{ \meett{\P, \K, {\Type{\b\mt}}, {\Type{}}} = {\Type{\b\mt}}~{\K} }

\IRule{M7}{
      \meett{\P, \K, {\t_3}, {\t_1}} = {\t_5}~{\K'} \\
      \meett{\P, {\K'}, {\t_2}, {\t_4}} = {\t_6}~{\K''} \\
      \meett{\P, {\K''}, {\Type{\b{\mt_1}}}, {\Type{\b{\mt_2}}}} = {\Type{\b{\mt_3}}}~{\K'''}
}{
    \meett{\P, \K, {\Type{\Mtype\m{{\t_1}}{\t_2}~\b{\mt_1}}}, {\Type{\Mtype\m{{\t_3}}{\t_4}~\b{\mt_2}}}} = {\Type{\Mtype\m{{\t_5}}{\t_6}~\b{\mt_3}}}~{\K'''}
}

\IRule{M8}{
      {\meett{\P, \K, {\t_3}, {\t_1}} = {\t_5}~{\K'}} \\
      \meett{\P, {\K'}, {\t_2}, {\t_4}} = {\t_6}~{\K''} \\
      \meett{\P, {\K''}, {\Type{\b{\mt_1}}}, {\Type{\b{\mt_2}}}} = {\Type{\b{\mt_3}}}~{\K'''}
}{
    \meett{\P, \K, {\Type{\Mtype\f{{\t_1}}{\t_2}~\b{\mt_1}}}, {\Type{\Mtype\f{{\t_3}}{\t_4}~\b{\mt_2}}}} = {\Type{\Mtype\f{{\t_5}}{\t_6}~\b{\mt_3}}}~{\K'''}
}

\IRule{M9}{
      \meett{\P, {\K}, {\t_2}, {\t_4}} = {\t_6}~{\K'} \\
      \meett{\P, {\K'}, {\Type{\b{\mt_1}}}, {\Type{\b{\mt_2}}}} = {\Type{\b{\mt_3}}}~{\K''}
}{
    \meett{\P, \K, {\Type{\Mtype\f{{}}{\t_2}~\b{\mt_1}}}, {\Type{\Mtype\f{{}}{\t_4}~\b{\mt_2}}}} = {\Type{\Mtype\f{{}}{\t_6}~\b{\mt_3}}}~{\K''}
}
\end{mathpar}

% \hrulefill
% 
% The figure above is semantics for the meet operator for the semantics of the monotonic cast.
% 
% \begin{verbatim}
% class C:
%   def m1(self,x:C)->Dyn:
%       return 2
% 
% class E:
%   def m1(self,x:E)->Int:
%       return 2
% 
%  c = C()
%  e = castE(c)
%  c.m1(c)
% \end{verbatim}


\hrulefill

\begin{mathpar}
\IRule{FT1}{
 \s(\a) = \obj\C{\b\a} \\
 \K(\C) = \Class \C {\b{\Ftype\f\t}}{\b\md} \\
 $|~\b\a|~$ = $~|~\b{\Ftype\f\t}|$ \\
}{
  \fieldtypes{\C,\K,\s,\a} = \b\a~\typeof{\b{\Ftype\f\t}}
}

\IRule{FT2}{
 \s(\a) = \obj\C{\b\a} \\
 \K(\C) = \Class \C {\b{\Ftype\f\t}}{\b\md} \\
 $|~\b\a|~$ = $~|~\b{\Ftype\f\t}|$ \\
}{
  \fieldtypes{\any,\K,\s,\a} = \b\a~\typeof{\b{\Ftype\f\t}}
}
\end{mathpar}

\hrulefill

\begin{tabbing}
$\classgen{\C,$\=$ ~\C',$\=$ ~\D, \K} = $\\
\>$\xt{class}~\D$\=$~\{$\=\\
\>\>$\f : \tp_1$\\
\>\>\>$\tfa \f : \t_1 \in \field\C\K \wedge \f:\tp_1 \in \ftype{\f}{\C'}\K$\\
\\
\>\>$\Mdefa\n{\b{\HT\x{\any}}}{\any} { \MonCast{\any}{\this.\n(\b{\MonCast{\t_1}{\x}})}}$\\
\>\>\>$\tfa \Mtype\n{\b{\t_1}}{\tp_1} \in \classoff\C\K \wedge \t_1 \neq \any$\\
\\
\>\>$\Mdefa\n{\b{\HT\x{\t_1}}}{\tp_1} { \MonCast{\tp_1}{\e}}$\\
\>\>\>$\tfa \Mtype\n{\b{\t_1}}{\tp_1} \in \classoff\C\K \wedge \Mdefa\n{\b{\HT\x{\t_2}}}{\tp_2}\e \in \xt{methods}(\C,\K) \wedge \t_1 \neq \any$\\
\\
\>\>$\Mdefa\n{\b{\HT\x{\any}}}{\any} { \e}$\\
\>\>\>$\tfa \Mtype\n{\b{\any}}{\any} \in \classoff\C\K \wedge \Mdefa\n{\b{\HT\x{\any}}}{\any}\e \in \xt{methods}(\C,\K)$\\
\>$\}$
\end{tabbing}

\end{document}
