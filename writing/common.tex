%!TEX output_directory=pdfs
\documentclass[a4paper,UKenglish,final]{lipics}
\usepackage{xspace,listings,url,framed,amssymb,
            amsmath,mathpartir,hyperref,stmaryrd, graphicx, mathtools}
\input{macros}
\begin{document}

\section*{Target Langage}

The target language (TL) is built around a parred down statically typed
object calculus. The calculus has non-recursive structural
substyping\footnote{\bf I am not sure that this is the right way to describe
  what we have -- check it is. JV} without inheritance.\footnote{Structural
  subtyping is needed for type systems that have a notion of
  ``consistency''. Inheritance does not add anything other than code reuse.}
The calculus does not have null values.\footnote{Null adds a source of error
  but otherwise should not be too interesting. We should mention what is the
  type of null.} Fields are accessed by automatically provided getter and
setter methods, respectively denoted \Get\x\f and \Set\x\f\e.\footnote{This
  is because we want an easy way to interpose on field access in wrappers.}
Fields appear in type signatures only through the presence of the getter and
setter methods. Method calls are denoted \Call\x\m\e.\footnote{The single
  argument limitation is purely to lighten the notation.} Following C\#
4.0~\cite{} the TL allows a dynamic type, denoted \any, and
dynamically-typed method invocation, denoted
\DynCall\x\m\e. Dynamically-typed method invocation treats arguments and
return value as \any. A new object is created with a class name and a
sequence of arguments in the order of definition of fields, denoted
\New\C{\b\e}.  Meta-variable \x ranges over argument names, \a over memory
locations, \f over field names, \m over method names, \C over class
names. The language has four different kinds of cast expressions: it has two
structural casts and two generative casts. The structural subtype cast,
denoted \SubCast\t\a, asserts that the object at location \a is of type
\t.  The structural shallow cast, denoted \ShaCast\t\a, asserts that the
object at location \a has methods with names matching those of \t. This does
not make any guarantee about the type of arguments.  The generative
behavioral cast, denoted \BehCast\t\a, will ensure that either \a behaves
as a \t or that it get stuck. The generative monotonic cast, denoted
\MonCast\t\a, is a behavioral cast that, in addition, imposes constraints
on fields.

\this is a distinguished variable name that denotes the current object.
\that is a distinguished field name that denotes the target of a wrapper.

\D is a meta-variable used to range over dynamically generated class names.

\begin{minipage}{7cm}\begin{tabular}{l@{~~}l@{}l@{}l@{}ll}
\e &::=  \x &\B \this &\B \that \\
   &\B \Get\e\f    &\B \Set\e\f\e    &\B \Call\e\m\e  &\B \DynCall\e\m\e \\
   &\B \New\C{\b\e} \\
   &\B \SubCast\t\e  &\B \ShaCast\t\e    &\B \BehCast\t\e &\B  \MonCast\t\e \\
   &\B \a \\ 
\Mxt{M} &::= ~~\none ~~ \B \b{\t \Sub \t} \\
\Mxt{K} &::= ~~\none ~~ \B \b{\Bind{\C}{\k}}     
\end{tabular}\end{minipage}
~~
\begin{minipage}{6cm}\begin{tabular}{l@{~~}l@{}l}
\k &::= \Class \C {\b{\Ftype\f\t}}{\b\md} \\
\end{tabular}
\begin{tabular}{l@{~~}l@{}l@{}l}
\md &::= \Mdef\m\x\t\t\e \\
    &\B  \Mdef\f\x\t\t\e ~\B~ \Mdefz\f\t\e \\
\mt &::= \Mtype\m\t\t ~\B~  \Mtype\f\t\t  ~\B~ \Mtype\f{}\t  \\
%     &\B  $\mu$\ta.\mt \\
\E  &::= \Ftype\x\t  \B \none\\
\t  &::= ~ \any  \B   \C \\ 
% \B \ta \\
\s  &::= ~~\none ~~ \B ~~
    \Heap{\s}{\b{\Bind{\a}{\obj\C{\b\a}}}}
\end{tabular}\end{minipage}

The semantics of TL is defined by a small step operational semantics with
evaluation contexts.  The context are deterministic. Program error is
denoted by a stuck term. Meta-variable \k ranges over class definitions.
The semantics operate over an explicit class table, denoted \K, which is a
sequence of class definitions. A heap, denoted \s, maps memory locations to
objects. We use the notation \Heap\s{\Bind\a{\obj\C{\b\a}}} to denote the
heap \s extended by the binding of location \a to object \obj\C{\b\a}.  A
configuration \K\e\s evaluates in one step to a new configuration, denoted
\Reduce \K\e\s \Kp\ep\sp. Execution terminate if \ep\xspace is a value, \a,
or if there is no applicable reduction, in which case the program is
stuck.\footnote{Intuitively we would expect that the program can only get
  stuck at dynamic calls or at structural casts. But generative casts add
  some complexity to that statement.}

New object creation picks a fresh memory location \ap and binds it to the
newly created. Operations on fields are require a typed receiver, for
example in the expression \Get\this\f, \this is always of the type of the
current class. Field access through a getter method, works as follows. If
the receiver's class has a getter method, that method is evaluated,
otherwise the field corresponding the getter's name is updated. Methods are
segregated into typed method (methods whose argument is not \any) and
untyped method (methods whose argument is \any). The former can be called by
statically resolved method, the latter must be called by dynamically
resolved methods.

The auxiliary function \texttt{names} return the list of function names in a class
or type, functions that have \any as return values are prefixed with the
symbol \any. The auxiliary function \texttt{typeof} return the type of the object 
at the location \a in the heap \s. The auxiliary function \texttt{read} return
the location \ap pointing to the field \f of the object at location \a. The 
auxiliary function \texttt{write} return the heap \sp with the field \f of
the object at location \a updated to the location \ap.


\hrulefill

\begin{minipage}{8cm}
  \opdef{\Reduce \K\e\s \Kp\ep\sp}
        {\e\s evaluates to \ep\xspace in a step}\\[-1mm]
\begin{tabular}{@{}l@{}l@{~}l@{~}l}
\CondRule{E2}{ %% new C -> a
   \sp = \Heap\s{\Bind\ap{\obj\C{\b\a}}} $\wedge ~$ \ap fresh
}{ 
    \ReduceA \K{\New\C{\b\a}}\s \K\ap\sp
}
\CondRule{E5}{ %% a.f() -> e
    \Mdefz\f\t\e \In \methdef\a\s\K 
}{
   \ReduceA \K{\Get\a\f}\s \K{[\a/\this]\e}\s
}
\CondRule{E4}{ %% a.f(a) -> e
    \Mdef\f\x\t\t\e \In \methdef\a\s\K
}{
   \ReduceA \K{\Set\a\f\ap}\s \K{[\a/\this~{\ap/\x}]\e}\s
}
\CondRule{E6}{  %% a.f() -> e
 \ap = \readf \s\a{\f} 
}{
  \ReduceA \K{\Get\a{\f}}\s  \K\ap\s
}
\CondRule{E7}{ %% a.f(e) -> e
 \sp = \setf \s\a{\f}\ap

}{
  \ReduceA \K{\Set\a{\f}\ap}\s \K\ap\sp
}
\CondRule{E3}{ %% a.m(a) -> e
  \Mdef\m\x\t\tp\e \In \methdef\a\s\K $\wedge~ \t \not= \any$
}{
 \ReduceA \K{\Call\a\m\ap}\s \K{[\a/\this~{\ap/\x}]\e}\s
}
\CondRule{E3}{ %% a@m(a) -> e
    \Mdef\m\x\any\any\e \In \methdef\a\s\K
}{
  \ReduceA \K{\DynCall\a\m\ap}\s \K{[\a/\this~{\ap/\x}]\e}\s
}
\CondRule{E10}{  %% Subtypecast
   \BasicType {\none} {\classof\a\s\K \Sub \t} $~\vee~$ \t $= \any$
}{ 
  \ReduceA \K{\SubCast \t\a}\s \K\a\s
}
\CondRule{E11}{
 \names{\classof\a\s\K}  $\supseteq$  \names\t
}{ 
  \ReduceA \K{\ShaCast \t\a}\s \K\a\s
}
\CondRule{E8}{
  \behcast \a\t\s\K  \Kp\ap\sp
}{ 
  \ReduceA  \K{\BehCast \t\a}\s \Kp\ap\sp
}
\CondRule{E9}{
  \moncast \a\t\s\K  \Kp\sp
}{ 
  \ReduceA \K{\MonCast\t\a}\s \Kp\a\sp
}
\CondRule{E1}{ %% e -> e'
  \Reduce \K\e\s \Kp\ep\sp
}{
 \ReduceA \K{\Ctx\e}\s \Kp{\Ctx\ep}\sp
}
\end{tabular}\end{minipage}

%%%%%%%%%%%%%%%%%%% CONTEXTS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
~\\[3mm]

\begin{minipage}{4cm}\begin{tabular}{l@{~~}l@{~}l}
\E &::= \Get\square\f     ~\B~
        \Set\square\f\e   ~\B~
        \Set\a\f\square   ~\B~  
        \Call\square\m\e   ~\B~
        \Call\a\m{\square} \\
   &\B~
        \DynCall\square\m\e   ~\B~
        \DynCall\a\m\square   ~\B~\\
   &\B~
       \SubCast\t\square  ~\B~
       \ShaCast\t\square  ~\B~
       \BehCast\t\square \\ &\B~
       \MonCast\t\square  ~\B~
       \New\C{\b \a\,\square\,\b\e}
\end{tabular}
\end{minipage}


Types are represented as a set of methods. 

\hrulefill

\opdef{\BasicType \MN {$~\t \Sub \tp$}}{\t is a subtype of \tp}
\begin{mathpar}
\IRule{SRef}{
}{
 \BasicType \MN {\t \Sub \t}
}

\IRule{STop}{
}{
 \BasicType \MN {\t \Sub {\Type{}}}
}

\IRule{SAssump}{
\t \Sub \tp \in \M{M} 
}{
 \BasicType \MN {\t \Sub \tp}
}

\IRule{SRec}{
 \classoff\C\K = \Type{\mt~\b{\mt_1}\,} \qquad
 \classoff\Cp\K = \Type{\mt'~\b{\mt_2}\,} \\
 \BasicType {\MNargs{\Type{\mt~\b{\mt_1}\,} \Sub  \Type{\mt'~\b{\mt_2}\,}}} {\mt\Sub\mt'} \\
 \BasicType {\MNargs{\Type{\mt~\b{\mt_1}\,} \Sub  \Type{\mt'~\b{\mt_2}\,}}} {\Type{ \b{\mt_1}} \Sub \Type{\b{\mt_2}}}
}{
 \BasicType \MN {\C} \Sub
  \Cp 
}

\IRule{SMeth}{
   \BasicType \MN {\t_2 \Sub \t_1} \\ \BasicType \MN {\t_1' \Sub \t_2'} 
}{
  \BasicType \MN {\Mtype\m{\t_1}{\t_1'} \Sub \Mtype\m{\t_2}{\t_2'}}
}

\IRule{SFd1}{
}{
 \BasicType \MN {\Mtype\f{}\t \Sub  \Mtype\f{}\t}
}

\IRule{SFd2}{
}{
 \BasicType \MN {\Mtype\f\t\t \Sub \Mtype\f\t\t}
}

\end{mathpar}

\hrulefill

\opdef{\BasicType \Sk {$~\Class \C {\b{\Ftype\f\t}}{\b\md} \OK$}}{class well-formedness }
\begin{mathpar}
\IRule{WFClass}{
%  $|\{$\b\md$\}|~$ = $~|\{$\b{\names{\md}}$\}|$ \\
%  $|\{$\b\f$\}|~$ = $~|\{$\b{\names{\f}}$\}|$ \\
 \b{\names{\md}} $~unique$ \\
 \b\f $~unique$ \\
 \BasicType {\none ~\none} {\b\md \OK} \\
%   \Kp = \K,~\Bind{\C}{\Class \C {\b{\Ftype\f\t}}{\b\md}}
}{
 \BasicType {} {\Class \C {\b{\Ftype\f\t}}{\b\md} \OK}
}
\end{mathpar}

\hrulefill

\opdef{\BasicType \Sk {$~\md \OK$}}{method well-formedness}
\begin{mathpar}
\IRule{WFMeth}{
 \EnvType {\EsE{\Ftype\x\tp}}{\e}{\t} 
}{
 \BasicType {\Es} {\Mdef\m\x\tp\t\e \OK}
}

\IRule{WFFieldS}{
 \EnvType {\EsE{\Ftype\x\tp}}{\e}{\t} 
}{
 \BasicType {\Es} {\Mdef\f\x\tp\t\e \OK}
}

\IRule{WFFieldR}{
 \EnvType \Es\e\t 
}{
 \BasicType {\Es} {\Mdefz\f\t\e \OK}
}

\end{mathpar}


Type checking is standard.

Field accessor rules W3 and W4 require a typed receiver, since \any does
not have any methods a receiver typed at \any will never typecheck.

Shallow casts, W9, do not change the type of the expression. We are casting
to the name of \t not to \t.  In practice that means that all expression
types in Transient will drift towards \any.

\hrulefill

\opdef{\EnvType\Es\e\t}{\e has type \t in environment \E against heap \s}
\begin{mathpar}
\IRule{W1}{
   \HasType \E\x\t
 }{
   \EnvType \Es\x\t
}

\IRule{W2}{
  \EnvType \Es\e\tp \\
 \BasicType{\M{\none}}{\tp \Sub \t}
 }{
   \EnvType \Es\e\t 
}   

\IRule{W3}{
  \EnvType \Es\e\t \\
  \Mtype \f{}\tp \inc \t  
}{
  \EnvType \Es{\Get\e\f}\tp
}    

\IRule{W4}{
  \EnvType \Es\e\t \\
  \Mtype \f\tp\tp \inc \t  \\
  \EnvType \Es\ep\tp
}{
  \EnvType \Es{\Set\e\f\ep}\tp
}    

\IRule{W5}{
  \EnvType \Es\e\t \\
  \Mtype \m\tp\tpp\inc \t  \\
  \EnvType \Es\ep\tp
}{
  \EnvType \Es{\Call\e\m\ep}\tpp
}    

\IRule{W6}{
  \EnvType \Es\e\any \\
  \EnvType \Es\ep\any
}{
  \EnvType \Es{\DynCall\e\m\ep}\any
}    

\IRule{W7}{
  \b{\EnvType \Es\e\t} \\ 
  \Class \C {\b{\Ftype\f\t}} {\b\md}
}{
  \EnvType \Es{\New\C{\b\e}}\C
}

\IRule{W8}{
  \EnvType \Es\e\tp
}{
  \EnvType \Es{\SubCast\t\e}\t
}

\IRule{W9}{
  \EnvType \Es\e\tp
}{
  \EnvType \Es{\ShaCast\t\e}\any  %%!!!  not \t !!!
}

\IRule{W10}{
  \EnvType \Es\e\tp
}{
  \EnvType \Es{\BehCast\t\e}\t
}

\IRule{W11}{
  \EnvType \Es\e\tp
}{
   \EnvType \Es{\MonCast\t\e}\t
}

\IRule{W12}{
  \s(\a) = \obj\C{\b{\a_1}}
}{
  \EnvType \Es\a\C
}
\end{mathpar}


%%% defining the auxiliary functions below, they include:
%%% methdef
%%% typeof
%%% read (field)
%%% write (field)

\hrulefill

\opdef{\methz\m\C\K}{Auxiliary function: Method definition}

\begin{equation*}
\methz\m\C\K = \md ~~s.t.~~ \begin{cases}

 \K(\C) = \Class \C {\b{\Ftype\f\t}}{\dots \md \dots} \\
 \m == \names\md  \\
\end{cases}
\end{equation*}

\hrulefill

\opdef{\mtype\m\C\K}{Auxiliary function: Method definition}

\mtype\m\C\K = \convert{\methz\m\C\K} 

\hrulefill

\opdef{\field\C\K}{Auxiliary function: Field definition}

\begin{equation*}
\field\C\K = \b{\Ftype\f\t} ~~s.t.~~ \begin{cases}

 \K(\C) = \Class \C {\b{\Ftype\f\t}}{\b\md}
\end{cases}
\end{equation*}

\hrulefill

\opdef{\methdef\a\s\K}{Auxiliary function: Method definition}

\begin{equation*}
\methdef\a\s\K = \method\C\K ~~s.t.~~ \begin{cases}

 \s(\a) = \obj\C{\b\a}\\
\end{cases}
\end{equation*}


\hrulefill

\opdef{\classof\a\s\K}{Auxiliary function: Type definition}

\begin{equation*}
\classof\a\s\K = \classoff\C\K ~~s.t.~~ \begin{cases}

 \s(\a) = \obj\C{\b\a}\\

\end{cases}
\end{equation*}

\hrulefill

\opdef{\classoff\C\K}{Auxiliary function: Type definition}

\begin{equation*}
\classoff\C\K = \Mxt{MT} ~~s.t.~~ \begin{cases}

 \K(\C) = \Class \C {\b{\Ftype\f\t}}{\b\md} \\
 \Mxt{MT} = \{\convert{\b\md} \oplus \forall ~\Ftype\fp\tp \in \b{\Ftype\f\t} ~|~ \fp \notin \b{\names{\md}} ~.~ \convertFD{\Ftype\fp\tp}\}

\end{cases}
\end{equation*}

\hrulefill

\opdef{\readf \s\a\f}{Auxiliary function: Field read}

\begin{equation*}
\readf \s\a{\f_{i}} = \a_{i} ~~s.t.~~ \begin{cases}

 \s(\a) = \obj\C{\dots \a_{i} \dots}\\
 \K(\C) = \Class \C {\dots \Ftype{\f_{i}}{\t_{i}} \dots}{\b\md}\\
\end{cases}
\end{equation*}

\hrulefill

\opdef{\setf \s\a\f\ap}{Auxiliary function: Field write}

\begin{equation*}
\setf \s\a{\f_{i}}\ap = \sp ~~s.t.~~ \begin{cases}

 \s(\a) = \obj\C{\dots \a_{i} \dots}\\
 \K(\C) = \Class \C {\dots \Ftype{\f_{i}}{\t_{i}} \dots}{\b\md}\\
 \sp = \s[\Bind{\a}{\obj\C{\dots \ap \dots}}]
\end{cases}
\end{equation*}

\hrulefill

\opdef{\convert{\md}}{Conversion function: Method definition to method type}

\convert{\Mdef\m\x\t\t\e} = \Mtype\m\t\t 

\convert{\Mdef\f\x\t\t\e} = \Mtype\f\t\t 

\convert{\Mdefz\f\t\e} = \Mtype\f{}\t 

\hrulefill

\opdef{\convertFD{\Ftype{\f}{\t}}}{Conversion function: Field definition to field types}

\convertFD{\Ftype{\f}{\t}} = \Mtype\f\t\t, \Mtype\f{}\t

\hrulefill

\opdef{\names{\mt}}{Naming function: Method types}

\names{\Mdef\m\x\t\t\e} = \m

\names{\Mdef\f\x\t\t\e} = \f

\names{\Mdefz\f\t\e} = \f

\hrulefill

\opdef{\names{\md}}{Naming function: Method definition\footnote{All of these simply functions should go into the appendix.}}

\names{\Mtype\m\t\t} = \m

\names{\Mtype\f\t\t} = \f

\names{\Mtype\f{}\t} = \f


\section{Generative Casts}

\subsection{Behavioral}



\hrulefill

\begin{mathpar}
\IRule{Cast-Wrap}{
  \D\;\mathit{fresh} \\
  \ap\;\mathit{fresh} \\
  \obj\C{\b{\a_1}} = \s(\a) \\
  \sp = \Heap \s{\Bind \ap{\obj\D{\a}} } \\
  \Kp = \K\;\wrapper{\C,\t,\D}
}{
  \behcast\a\t\s\K  \Kp\ap\sp
}
\end{mathpar}

What does the wrap function do? In english.

At its core, the wrap function protects types. If a function on an object has a declared argument type, then the wrap function will produce a wrapper for that function that ensures that any argument passed in matches the declared type. Likewise, if we assert that an untyped function has a return type, then the generated wrapper guarantees that the returned value of the untyped function is of the asserted type by inserting a cast to the right type.

In our context, wrappers are just generated classes, produced when the runtime system encounters a behavioral cast. These casts need to ensure two key properties, which we will refer to as \emph{soundness} and \emph{completeness}. In the context of casts, soundness refers to correct enforcement of types, whereby protected methods will not observably violate their type guarantees, while completeness ensures that a cast will not lose methods.

This last requirement is somewhat unconventional, and its need is illustrated in a simple example. 

\begin{verbatim}
class C {
  m(x:int):int { ... }
}
class D {
  m(x:*):* { ... }
  f(x:*):* { ... }
}
(<D>(<C>new D()))@f(2)
\end{verbatim}

In this example, if we were to implement wrappers by wrapping over only the declared methods, despite D having a method f, it is "lost" when D is cast to C. As a result, when we cast it back from C to D, the wrapper added to ensure that C's invariants held does not have a method f, and our call will produce a method not understood exception. To avoid this issue, our wrappers will have to retain all untyped methods when casting untyped to typed, and typed methods if a typed cast does not mention them, so that they may be recovered in a later cast.

\hrulefill
\newcommand{\wm}{\text{wrapMethod}}
\begin{align*}
%\wm{(\xt{wrap},\Mdef\m\x\any\any\e,\Mtype\m\t\tp)} &= \Mdef\m\x\t\tp{\BehCast{\tp}{\Call{{\this}.{\xt{wrap}}}{\m}{\BehCast{\any}{\x}}}}\\
%\wm{(\xt{wrap},\Mdef\m\x\t\tp\e,\Mtype\m\any\any)} &= \Mdef\m\x\any\any{\BehCast{\any}{\Call{\this.\xt{wrap}}{\m}{\BehCast{\t}{\x}}}}\\
\wm{(\Mdef\m\x{\t_1}{\tp_1}\e,\Mtype\m{\t_2}{\tp_2})} = \Mdef\m\x{\t_2}{\tp_2}{\BehCast{\tp_2}{\Call{\this.\xt{that}}{\m}{\BehCast{\t_1}{\x}}}}\\
\end{align*}

%TODO: define mdef & mtype
\newcommand{\getmdef}{\text{mdef}}
\newcommand{\getmtype}{\text{mtype}}
\newcommand{\wc}{\text{wrapClass}}
\begin{tabbing}
$\wc(\Heap\s{$\=$\a\mapsto \{ \b{a}\B\C\} }, \a, \Cp) = $\\
\>$\xt{class}~\D$\=$~\{$\\
\>\>$\xt{that} : \C$ \\
\>\>$\wm($\=$\getmdef(\m,\C,\K),\getmtype(\m,\Cp,\K))$ \\
\qquad\qquad\qquad\qquad\qquad\qquad $\text{ \emph{for every } } \m \in \names{\classoff\C\K} \wedge \m \in \names{\classoff\Cp\K} $\\
\>\>$\Mdef\m\x{\t_1}{\tp_1}{\this.\xt{that}.\m(\x)}$ \\
\qquad\qquad\qquad\qquad\qquad\qquad $\text{ \emph{for every} } \Mtype\m{\t_1}{\tp_1} = \getmtype(\m,\C,\K) \wedge \m \not\in \names{\classoff\Cp\K}$\\
\>\>$\Mdefz\f\t{\this.\xt{that}.\f()}$ \\
\qquad\qquad\qquad\qquad\qquad\qquad $\text{ \emph{for every} } \f:\t \in \names{\classoff\Cp\K} \vee \Mtype\f{}\t \in \names{\classoff\Cp\K}$\\
\>\>$\Mdef\f\x\t\t{\this.\xt{that}.\f(\x)}$ \\
\qquad\qquad\qquad\qquad\qquad\qquad $\text{ \emph{for every} } \f:\t \in \names{\classoff\Cp\K} \vee \Mtype\f{\x:\t}\t \in \names{\classoff\Cp\K}$\\
\>$\}$\\
\\
\\
$\wc(\Heap\s{$\=$\a\mapsto \{ \b{a}\B\C\} }, \a, \any) = $\\
\>$\xt{class}~\D$\=$~\{$\\
\>\>$\xt{that} : \C$ \\
\>\>$\Mdef\m\x{\any}{\any}{\BehCast{\any}{\this.\xt{that}.\m(\BehCast{\t_1}{\x})}}$ \\
\qquad\qquad\qquad\qquad\qquad\qquad $\text{ \emph{if} } \Mdef\m\x{\t_1}{\tp_1}{\e} \in \method\C\K$\\
\>\>$\Mdefz\f\any{\BehCast{\any}{\this.\xt{that}.\f()}}$ \\
\qquad\qquad\qquad\qquad\qquad\qquad $\text{ \emph{for every} } \f:\t \in \field\C\K ~~\vee~~ \Mtype\f{}\t \in \classoff\C\K$\\
\>\>$\Mdef\f\x\any\any{\BehCast{\any}{\this.\xt{that}.\f(\BehCast{\t}\x)}}$ \\
\qquad\qquad\qquad\qquad\qquad\qquad $\text{ \emph{for every} } \f:\t \in \field\C\K ~~\vee~~ \Mtype\f{\x:\t}\t \in \classoff\C\K$\\
\>$\}$\\
\end{tabbing}

Based on this intuition, we have two methods to generate wrappers: \wm, which generates the methods in the wrapper, and \wc, which generates the wrapper class. If the source and target types are compatible, \wm will generate a method that casts the arguments correctly and then casts the return type. 

\wc is more complex than \wm, because different wrappers are needed, depending on if the target type is a concrete type \C, or is the dynamic type \any. If the target type is \C, then it will generate the wrapper methods for the type \C, then insert ``passthrough'' methods. methods of the same type as the original and that just call the original internally, that provide the completness property mentioned above. Likewise, if the target type is \any, then \wc will simply generate a method that casts its argument to the right type and its return type to \any for every one of the typed methods in the source, ensuring soundness and completness.


\subsection{Monotone}

%The motivation behind the monotonic semantics is that we must ensure that every reference to an object is still valid up to \any types, and as a result, can only proceed by replacing \any types with concrete types, possibly recursively. We accomplish this by \emph{rewriting} the class that objects are associated with, enforcing the new type guarantee, while simultaneously checking that all of the extant field values match the type that they need to be.

%In order to do any of this, however, the new type of the object is required. In Siek et al.'s original formalism, the new type was computed simultaneously as the object was being cast, but this creates problems when recursive objects are encountered. For example, consider the following scenario:

%\begin{verbatim}
%class C { x:any y:any m(y:any):any }
%class D {}
%class E { x:{x:{y:int}} y:any}

%a = new C(new D(),2)
%b = new C(a, 2)
%a.x(b)
%c = <E>a
%\end{verbatim}

%Here, when we go to update the value at \x, we then need to go into the type recursively, which points to a new instance of \C. Then, we assert a new type for \x in that new \C, which sends us back to the starting object, where we update the type of \xt{y} to be int, from \any. As a result, we cannot cast simply by examining the statically knowable types, but have to consider the heap structure when determining the final typing for any object.

%We break this operation up into two steps:

%\begin{itemize}
%\item \emph{Type Determination}. We first determine a valid heap typing that both retains the monotonic property, while satisfying the new cast assertion. To do this, we recursively examine the heap structure, iterating until the heap is unchanged by the last type alteration.
%\item \emph{Heap Update}. In the previous phase, we only determined a new valid typing for the heap. In the second step, we take this typing and apply it to the objects that exist in the heap.
%\end{itemize}

%By splitting out the two concerns, we avoid issues where the future state of the heap depends on values produced in the casting process and that do not exist yet. 

Monotonic aims to have \emph{every typed reference still be valid}, including the ones that previously existed, as well as the reference created by the cast. If a reference has a type with a non-star value, then the monotonic semantics will ensure that that type is not violated. To accomplish this, the monotonic cast needs to make sure of two properties:
\begin{itemize}
\item The values that \emph{currently} exist cannot violate any of the types that point to them. Casting needs to recursively ensure that all values referred to by the current object are of the claimed type.
\item Functions ca  nnot be called with or return values that violate any of the types that they are referred to with. The behaviour of the class needs to check that its types are not violated by lesser-typed call sites.
\end{itemize}

The second property is strongly reminisicent of the behavioural semantics, though with the interesting caveat that we now need to make sure that \emph{all} method invocations follow the typed calling conventions, rather than just the ones that inherit this particular type assertion.


\hrulefill

\begin{mathpar}
\IRule{Cast-Mono1 (monotonic)}{
  \Heap \s{\Bind \a{\obj\C{\a_1 \dots \a_n}}} \\
  \C \not\equiv \meet \t\C \\
  \Kp = \K\;\spec{\Class\C{\b{\Ftype\f\t}}{\b\md}, \D, \meet \t\C} \\
  \sp = \Heap \s{\Bind \a{\obj\D{\b{\a_1}}}} \\
  \s_1 = \castfn{\a_1}{\t_1}{\sp}\Kp \\ \ldots \\
  \s_n = \castfn{\a_n}{\t_n}{\s_{n-1}}\Kp \\
}{
  \moncast \a\t\s\K   \Kp {\s_n}\\
}

\IRule{Cast-Mono2 (monotonic)}{
  \Heap \s{\Bind \a{\obj\C{\b{\a_1}}}} \\
  \C \equiv \meet \t\C
}{
  \moncast \a\t\s\K  \K\s
}
\end{mathpar}



\hrulefill

\opdef{
  $\meet{\t_1}{\t_2} \equiv \t$
}{
  The most specific type common to $\t_1$ and $\t_2$ is $\t$
}
\begin{mathpar}
\IRule{M1}{ }{\meet{\t}{\any} \equiv \t}

\IRule{M2}{ }{\meet{\any}{\t} \equiv \t}

\IRule{M3}{ }{\meet{\t}{\t} \equiv \t}

\IRule{M4}{
      \b{\meet{\t_3}{\t_1}  \equiv \t_5} \\
    \meet{\t_2}{\t_4} \equiv \t_6\\
    \meet{\Type{\b{\md_1}}}{\Type{\b{\md_2}}} \equiv \Type{\b{\md_3}} 
}{
  \meet{\Type{\Mtype\m{\t_1}{\t_2}~ \b{\md_1}}}{\Type{\Mtype\m{\t_3}{\t_4} ~ \b{\md_2}}} \equiv \Type{\Mtype\m{\b{\t_5}}{\t_6} ~ \b{\md_3}}
}
\end{mathpar}

\hrulefill

\begin{mathpar}
\IRule{Refine-Method}{
  \b{\meet{\t_1}{\t_1'} = \t_1''}\\
  {\meet{\t_2}{\t_2'} = \t_2''}
}{
  \spec{\m(\b{\x:\t_1}):\t_2 = \e,\m(\b{\t_1'}):\t_2'} = 
  (\m(\b{\x:\t_1''}):\t_2'' = \SubCast{\t_2''}{\e}), \\
  (\m_\xt{u}(\b{\x:\any}):\any = \SubCast{\any}{\this.{\m}(\SubCast{\t_1''}{\x})})
}

\IRule{Refine-Class}{
  \b{\meet{\t}{\t'} = \t''}
}{
  \spec{\Class{\C}{\b{\f : \t}}{\b{\md}}, \xt{D}, \{\b{\f():\t'},\b{\mt}\}} = \Class{\D}{\b{\f : \t''}}{\b{\spec{\f:\t,\t'}},\b{\spec{\md,\mt}}}
}
\end{mathpar}


\hrulefill

\begin{mathpar}
\IRule{Insert-Recv (eager cast)}{
  \GenCast \E{\e_1}{\e_3}{\t_1} \\
  \m(\b{x : \t_2}):\t_3 \in \t_1 \\
  \b{\AnaCast \E{\e_2}{\e_4}{\t_2}}
}{
  \inv \E{\Call{\e_1}\m{\b{\e_2}}} = \Call{\e_3}{\m}{\b{\e_4}}, \t_3
}

\IRule{Insert-Dyn}{
  \GenCast{\E}{\e_1}{\e_3}{\any} \\
  \AnaCast{\E}{\e_2}{\e_4}{\any}
}{
  \inv \E{\Call{\e_1}\m{\b{\e_2}}} =
  \Call{\SubCast{(\Type{\Mtype{\m_\xt{u}}{\b\any}\any}}{\e_3})}{\m_\xt{u}}{\b{\e_4}}, \any
}

\IRule{Insert-Check (lazy cast)}{
  \GenCast \E{\e_1}{\e_3}{\t_1} \\
  \m(\b{x : \t_2}):\t_3 \in \t_1 \\
  \b{\AnaCast \E{\e_2}{\e_4}{\t_2}}
}{
  \inv{\E}{\Call{\e_1}\m{\b{\e_2}}} =
  \SubCast{\t_1}{(\Call{(\SubCast{\Type{\Mtype{\m_\xt{u}}{\b\any}\any}}{\e_3})}{\m_\xt{u}}{\b{\SubCast \any{\e_4}}})}, \t_1
}
\end{mathpar}

\end{document}
\section{Addendum}

\input{figures/syncast}

\hrulefill

\input{figures/anacast}

\hrulefill

\input{figures/classtrans}

\hrulefill

\input{figures/conssub}

\hrulefill

\begin{mathpar}
\IRule{No-Cons}{ \t_1 \Sub \t_2 }{\MetaSub{\t_1}{\t_2}}

\IRule{Has-Cons}{\stcons{\t_1}{\t_2}}{\MetaSub{\t_1}{\t_2}}
\end{mathpar}

\end{document}
