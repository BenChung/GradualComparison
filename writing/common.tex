%!TEX output_directory=pdfs
\documentclass[a4paper,UKenglish,final]{lipics}
\usepackage{xspace,listings,url,framed,amssymb,
            amsmath,mathpartir,hyperref,stmaryrd, graphicx}
\input{macros}
\begin{document}

\section*{Target Langage}

The target language (TL) is built around a parred down statically typed
object calculus. The calculus has non-recursive structural
substyping\footnote{\bf I am not sure that this is the right way to describe
  what we have -- check it is. JV} without inheritance.\footnote{Structural
  subtyping is needed for type systems that have a notion of
  ``consistency''. Inheritance does not add anything other than code reuse.}
The calculus does not have null values.\footnote{Null adds a source of error
  but otherwise should not be too interesting. We should mention what is the
  type of null.} Fields are accessed by automatically provided getter and
setter methods, respectively denoted \Get\x\f and \Set\x\f\e.\footnote{This
  is because we want an easy way to interpose on field access in wrappers.}
Fields appear in type signatures only through the presence of the getter and
setter methods. Method calls are denoted \Call\x\m\e.\footnote{The single
  argument limitation is purely to lighten the notation.} Following C\#
4.0~\cite{} the TL allows a dynamic type, denoted \any, and
dynamically-typed method invocation, denoted
\DynCall\x\m\e. Dynamically-typed method invocation treats arguments and
return value as \any. A new object is created with a class name and a
sequence of arguments in the order of definition of fields, denoted
\New\C{\b\e}.  Meta-variable \x ranges over argument names, \a over memory
locations, \f over field names, \m over method names, \C over class
names. The language has four different kinds of cast expressions: it has two
structural casts and two generative casts. The structural subtype cast,
denoted \SubCast\t\a, asserts that the object at location \a is of type
\t.  The structural shallow cast, denoted \ShaCast\t\a, asserts that the
object at location \a has methods with names matching those of \t. This does
not make any guarantee about the type of arguments.  The generative
behavioral cast, denoted \BehCast\t\a, will ensure that either \a behaves
as a \t or that it get stuck. The generative monotonic cast, denoted
\MonCast\t\a, is a behavioral cast that, in addition, imposes constraints
on fields.

\this is a distinguished variable name that denotes the current object.
\that is a distinguished field name that denotes the target of a wrapper.

\D is a meta-variable used to range over dynamically generated class names.

\begin{minipage}{7cm}\begin{tabular}{l@{~~}l@{}l@{}l@{}ll}
\e &::=  \x &\B \this &\B \that \\
   &\B \Get\e\f    &\B \Set\e\f\e    &\B \Call\e\m\e  &\B \DynCall\e\m\e \\
   &\B \New\C{\b\e} \\
   &\B \SubCast\t\e  &\B \ShaCast\t\e    &\B \BehCast\t\e &\B  \MonCast\t\e \\
   &\B \a 
\end{tabular}\end{minipage}
~~
\begin{minipage}{6cm}\begin{tabular}{l@{~~}l@{}l}
\k &::= \Class \C {\b{\Ftype\f\t}}{\b\md} \\
\end{tabular}
\begin{tabular}{l@{~~}l@{}l@{}l}
\md &::= \Mdef\m\x\t\t\e \\
    &\B  \Mdef\f\x\t\t\e ~\B~ \Mdefz\f\t\e \\
\mt &::= \Mtype\m\t\t ~\B~  \Mtype\f\t\t  ~\B~ \Mtype\f{}\t \\
\E  &::= \Ftype\x\t  \B \none\\
\t  &::= ~ \any  \B   \Type{\b\mt}  \\
\s  &::= ~~\none ~~ \B ~~
    \Heap\s{\Bind\a{\obj\C{\b\a}}}
\end{tabular}\end{minipage}

The semantics of TL is defined by a small step operational semantics with
evaluation contexts.  The context are deterministic. Program error is
denoted by a stuck term. Meta-variable \k ranges over class definitions.
The semantics operate over an explicit class table, denoted \K, which is a
sequence of class definitions. A heap, denoted \s, maps memory locations to
objects. We use the notation \Heap\s{\Bind\a{\obj\C{\b\a}}} to denote the
heap \s extended by the binding of location \a to object \obj\C{\b\a}.  A
configuration \K\e\s evaluates in one step to a new configuration, denoted
\Reduce \K\e\s \Kp\ep\sp. Execution terminate if \ep\xspace is a value, \a,
or if there is no applicable reduction, in which case the program is
stuck.\footnote{Intuitively we would expect that the program can only get
  stuck at dynamic calls or at structural casts. But generative casts add
  some complexity to that statement.}

New object creation picks a fresh memory location \ap and binds it to the
newly created. Operations on fields are require a typed receiver, for
example in the expression \Get\this\f, \this is always of the type of the
current class. Field access through a getter method, works as follows. If
the receiver's class has a getter method, that method is evaluated,
otherwise the field corresponding the getter's name is updated. Methods are
segregated into typed method (methods whose argument is not \any) and
untyped method (methods whose argument is \any). The former can be called by
statically resolved method, the latter must be called by dynamically
resolved methods.

The auxilliary function names return the list of function names in a class
or type, functions that have \any as return values are prefixed with the
symbol \any.


\hrulefill

\begin{minipage}{8cm}
  \opdef{\Reduce \K\e\s \Kp\ep\sp}
        {\e\s evaluates to \ep\xspace in a step}\\[-1mm]
\begin{tabular}{@{}l@{}l@{~}l@{~}l}
\CondRule{E2}{ %% new C -> a
   \sp = \Heap\s{\Bind\ap{\obj\C{\b\a}}} $\wedge ~$ \ap fresh
}{ 
    \ReduceA \K{\New\C{\b\a}}\s \K\ap\sp
}
\CondRule{E5}{ %% a.f() -> e
    \Mdefz\f\t\e \In \classof\a\s\K
}{
   \ReduceA \K\s{\Get\a\f} \K{[\a/\this]\e}\s
}
\CondRule{E4}{ %% a.f(a) -> e
    \Mdef\f\x\t\t\e \In \classof\a\s\K
}{
   \ReduceA \K\s{\Set\a\f\ap} \K{[\a/\this~{\ap/\x}]\e}\s
}
\CondRule{E6}{  %% a.f() -> e
  \readfield \ap\s\a\f
}{
  \ReduceA \K{\Get\a\f}\s  \K\ap\s
}
\CondRule{E7}{ %% a.f(e) -> e
  \setfield \sp\s\a\f\ap
}{
  \ReduceA \K{\Set\a\f\ap}\s \K\ap\sp
}
\CondRule{E3}{ %% a.m(a) -> e
  \Mdef\m\x\t\tp\e \In \classof\a\s\K $\wedge~ \t \not= \any$
}{
 \ReduceA \K\s{\Call\a\m\ap} \K{[\a/\this~{\ap/\x}]\e}\s
}
\CondRule{E3}{ %% a@m(a) -> e
    \Mdef\m\x\any\any\e \In \classof\a\s\K
}{
  \ReduceA \K\s{\DynCall\a\m\ap} \K{[\a/\this~{\ap/\x}]\e}\s
}
\CondRule{E10}{  %% Subtypecast
  \classof\a\s\K \Sub \t
}{ 
  \ReduceA \K{\SubCast \tp\a}\s \K\a\s
}
\CondRule{E11}{
 \names{\classof\a\s\K}  $\supseteq$  \names\t
}{ 
  \ReduceA \K{\ShaCast \tp\a}\s \K\a\s
}
\CondRule{E8}{
  \behcast \a\t\s\K  \Kp\ap\sp
}{ 
  \ReduceA  \K{\BehCast \tp\a}\s \Kp\ap\sp
}
\CondRule{E9}{
  \moncast \a\t\s\K  \Kp\sp
}{ 
  \ReduceA \K{\MonCast\tp\a}\s \Kp\a\sp
}
\CondRule{E1}{ %% e -> e'
  \Reduce \K\e\s \Kp\ep\sp
}{
 \ReduceA \K{\Ctx\e}\s \Kp{\Ctx\ep}\sp
}
\end{tabular}\end{minipage}

%%%%%%%%%%%%%%%%%%% CONTEXTS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
~\\[3mm]

\begin{minipage}{4cm}\begin{tabular}{l@{~~}l@{~}l}
\E &::= \Get\square\f     ~\B~
        \Set\square\f\e   ~\B~
        \Set\a\f\square   ~\B~  
        \Call\square\m\e   ~\B~
        \Call\a\m{\square} \\
   &\B~
        \DynCall\square\m\e   ~\B~
        \DynCall\a\m\square   ~\B~\\
   &\B~
       \SubCast\t\square  ~\B~
       \ShaCast\t\square  ~\B~
       \BehCast\t\square \\ &\B~
       \MonCast\t\square  ~\B~
       \New\C{\b \a\,\square\,\b\e}
\end{tabular}
\end{minipage}

Types are represented by set of methods. 

\hrulefill

\opdef{$\t \Sub \tp$}{\t is a subtype of \tp}
\begin{mathpar}
\IRule{SRef}{
}{
  \t \Sub \t
}

\IRule{STop}{
}{
  \t \Sub {\Type{}}
}

\IRule{SRec}{
 \mt\Sub\mt'\\
  \Type{ \b{\mt_1}} \Sub \Type{\b{\mt_2}}
}{
  \Type{\mt~\b{\mt_1}\,} \Sub
  \Type{\mt'~\b{\mt_2}\,} 
}

\IRule{SMeth}{
  \t_1 \Sub \t_2 \\   \t_2' \Sub \t_1' 
}{
  \Mtype\m{\t_1}{\t_1'} \Sub \Mtype\m{\t_2}{\t_2'}
}


\IRule{SFd1}{
}{
  \Mtype\f{}\t \Sub  \Mtype\f{}\t
}

\IRule{SFd2}{
}{
  \Mtype\f\t\t \Sub \Mtype\f\t\t
}
\end{mathpar}


Type checking is standard.

Field accessor rules W3 and W4 require a typed receiver, since \any does
not have any methods a receiver typed at \any will never typecheck.

Shallow casts, W9, do not change the type of the expression. We are casting
to the name of \t not to \t.  In practice that means that all expression
types in Transient will drift towards \any.

\hrulefill

\opdef{\EnvType\Es\e\t}{\e has type \t in environment \E against heap \s}
\begin{mathpar}
\IRule{W1}{
   \HasType \E\x\t
 }{
   \EnvType \Es\x\t
}

\IRule{W2}{
  \EnvType \Es\e\tp \\
  \tp \Sub \t
 }{
   \EnvType \Es\e\t 
}   

\IRule{W3}{
  \EnvType \Es\e\t \\
  \Mtype \f{}\tp \inc \t  
}{
  \EnvType \Es{\Get\e\f}\tp
}    

\IRule{W4}{
  \EnvType \Es\e\t \\
  \Mtype \f\tp\tp \inc \t  \\
  \EnvType \Es\ep\tp
}{
  \EnvType \Es{\Set\e\f\ep}\tp
}    

\IRule{W5}{
  \EnvType \Es\e\t \\
  \Mtype \m\tp\tpp\inc \t  \\
  \EnvType \Es\ep\tp
}{
  \EnvType \Es{\Call\e\m\ep}\tpp
}    

\IRule{W6}{
  \EnvType \Es\e\any \\
  \EnvType \Es\ep\any
}{
  \EnvType \Es{\DynCall\e\m\ep}\any
}    

\IRule{W7}{
  \b{\EnvType \Es\e\t} \\ 
  \Class \C {\b{\Ftype\f\t}} {\b\md}
}{
  \EnvType \Es{\New\C{\b\e}}\C
}

\IRule{W8}{
  \EnvType \Es\e\tp
}{
  \EnvType \Es{\SubCast\t\e}\t
}

\IRule{W9}{
  \EnvType \Es\e\tp
}{
  \EnvType \Es{\ShaCast\t\e}\any  %%!!!  not \t !!!
}

\IRule{W10}{
  \EnvType \Es\e\tp
}{
  \EnvType \Es{\BehCast\t\e}\t
}

\IRule{W11}{
  \EnvType \Es\e\tp
}{
   \EnvType \Es{\MonCast\t\e}\t
}

\IRule{W12}{
  \s(\a) = \obj\C{\b{\a_1}}
}{
  \EnvType \Es\a\C
}
\end{mathpar}

\section{Generative Casts}

\subsection{Behavioral}



\hrulefill

\begin{mathpar}
\IRule{Cast-Wrap}{
  \D\;\mathit{fresh} \\
  \ap\;\mathit{fresh} \\
  \obj\C{\b{\a_1}} = \s(\a) \\
  \sp = \Heap \s{\Bind \ap{\obj\D{\a}} } \\
  \Kp = \K\;\wrapper{\C,\t,\D}
}{
  \behcast\a\t\s\K  \Kp\ap\sp
}
\end{mathpar}

What does the wrap function do? In english.

\C may be a wrapper or a user class. It may thus have fields or has the
single \that field.

Assume \t = \any.






\hrulefill


\begin{mathpar}
\IRule{UTWrap}{
   \Class\C{\b{\Mdef\m\x\t\tp\e}~\b{\Mdef{\m'_u}\x\t\tp\e}}
}{
  \wrapper{\C,\any,\D} = \Class \D{ \that:\C }
   {\b{\Mdef{\m_u}\x\any\any{\BehCast \any{\this.\that.\m(\b{\BehCast\t\x})}}} ~
    \b{\Mdef{\m'_u}\x\t\tp{\that.\m'_u(\b\x)}}}
}

\IRule{TWrap}{
	\Class\C{\b\fd}{\b\md} \\ 
}{
	\wrapper{\C\Rightarrow\{\b{\mt}\},\D} = \Class \D{\xt{s} : \C}{\tw{\b\md, \b\mt} ~ {\utw{\b\md, \b\mt}}}
}

\IRule{MTWrap}{
}{
  \tw{\Mdef{\m_\xt{u}}\x\any\any\e;\b{\md},\Mtype\m{\b{\tp1}}{\tp2};\b{\mt}} = \Mdef{\m}\x{\tp1}{\tp2}{\SubCast{\tp2}{\this.\xt{s}.{\m_\xt{u}(\b{\SubCast{\any}{\x}})}}} ~ \tw{\b{\md},\b{\mt}}
}

\IRule{MUTWrap}{
	\m \not\in\b{\mt}
}{
  \utw{\Mdef{\m_\xt{u}}\x\any\any\e;\b{\md},\b{\mt}} = \Mdef{\m_\xt{u}}\x\any\any\e ~ \utw{\b{\md},\b{\mt}}
}
\end{mathpar}


\subsection{Monotone}

\hrulefill

\begin{mathpar}
\IRule{Cast-Mono1 (monotonic)}{
  \Heap \s{\Bind \a{\obj\C{\a_1 \dots \a_n}}} \\
  \C \not\equiv \meet \t\C \\
  \Kp = \K\;\spec{\Class\C{\b{\Ftype\f\t}}{\b\md}, \D, \meet \t\C} \\
  \sp = \Heap \s{\Bind \a{\obj\D{\b{\a_1}}}} \\
  \s_1 = \castfn{\a_1}{\t_1}{\sp}\Kp \\ \ldots \\
  \s_n = \castfn{\a_n}{\t_n}{\s_{n-1}}\Kp \\
}{
  \moncast \a\t\s\K   \Kp {\s_n}\\
}

\IRule{Cast-Mono2 (monotonic)}{
  \Heap \s{\Bind \a{\obj\C{\b{\a_1}}}} \\
  \C \equiv \meet \t\C
}{
  \moncast \a\t\s\K  \K\s
}
\end{mathpar}



\hrulefill

\opdef{
  $\meet{\t_1}{\t_2} \equiv \t$
}{
  The most specific type common to $\t_1$ and $\t_2$ is $\t$
}
\begin{mathpar}
\IRule{M1}{ }{\meet{\t}{\any} \equiv \t}

\IRule{M2}{ }{\meet{\any}{\t} \equiv \t}

\IRule{M3}{ }{\meet{\t}{\t} \equiv \t}

\IRule{M4}{
      \b{\meet{\t_3}{\t_1}  \equiv \t_5} \\
    \meet{\t_2}{\t_4} \equiv \t_6\\
    \meet{\Type{\b{\md_1}}}{\Type{\b{\md_2}}} \equiv \Type{\b{\md_3}} 
}{
  \meet{\Type{\Mtype\m{\t_1}{\t_2}~ \b{\md_1}}}{\Type{\Mtype\m{\t_3}{\t_4} ~ \b{\md_2}}} \equiv \Type{\Mtype\m{\b{\t_5}}{\t_6} ~ \b{\md_3}}
}
\end{mathpar}

\hrulefill

\begin{mathpar}
\IRule{Refine-Method}{
  \b{\meet{\t_1}{\t_1'} = \t_1''}\\
  {\meet{\t_2}{\t_2'} = \t_2''}
}{
  \spec{\m(\b{\x:\t_1}):\t_2 = \e,\m(\b{\t_1'}):\t_2'} = 
  (\m(\b{\x:\t_1''}):\t_2'' = \SubCast{\t_2''}{\e}), \\
  (\m_\xt{u}(\b{\x:\any}):\any = \SubCast{\any}{\this.{\m}(\SubCast{\t_1''}{\x})})
}

\IRule{Refine-Class}{
  \b{\meet{\t}{\t'} = \t''}
}{
  \spec{\Class{\C}{\b{\f : \t}}{\b{\md}}, \xt{D}, \{\b{\f():\t'},\b{\mt}\}} = \Class{\D}{\b{\f : \t''}}{\b{\spec{\f:\t,\t'}},\b{\spec{\md,\mt}}}
}
\end{mathpar}


\hrulefill

\begin{mathpar}
\IRule{Insert-Recv (eager cast)}{
  \GenCast \E{\e_1}{\e_3}{\t_1} \\
  \m(\b{x : \t_2}):\t_3 \in \t_1 \\
  \b{\AnaCast \E{\e_2}{\e_4}{\t_2}}
}{
  \inv \E{\Call{\e_1}\m{\b{\e_2}}} = \Call{\e_3}{\m}{\b{\e_4}}, \t_3
}

\IRule{Insert-Dyn}{
  \GenCast{\E}{\e_1}{\e_3}{\any} \\
  \AnaCast{\E}{\e_2}{\e_4}{\any}
}{
  \inv \E{\Call{\e_1}\m{\b{\e_2}}} =
  \Call{\SubCast{(\Type{\Mtype{\m_\xt{u}}{\b\any}\any}}{\e_3})}{\m_\xt{u}}{\b{\e_4}}, \any
}

\IRule{Insert-Check (lazy cast)}{
  \GenCast \E{\e_1}{\e_3}{\t_1} \\
  \m(\b{x : \t_2}):\t_3 \in \t_1 \\
  \b{\AnaCast \E{\e_2}{\e_4}{\t_2}}
}{
  \inv{\E}{\Call{\e_1}\m{\b{\e_2}}} =
  \SubCast{\t_1}{(\Call{(\SubCast{\Type{\Mtype{\m_\xt{u}}{\b\any}\any}}{\e_3})}{\m_\xt{u}}{\b{\SubCast \any{\e_4}}})}, \t_1
}
\end{mathpar}

\end{document}
\section{Addendum}

\input{figures/syncast}

\hrulefill

\input{figures/anacast}

\hrulefill

\input{figures/classtrans}

\hrulefill

\input{figures/conssub}

\hrulefill

\begin{mathpar}
\IRule{No-Cons}{ \t_1 \Sub \t_2 }{\MetaSub{\t_1}{\t_2}}

\IRule{Has-Cons}{\stcons{\t_1}{\t_2}}{\MetaSub{\t_1}{\t_2}}
\end{mathpar}

\end{document}
