%!TEX output_directory=pdfs
\documentclass[a4paper,UKenglish,final]{lipics}
\usepackage{xspace,listings,url,framed,amssymb,
            amsmath,mathpartir,hyperref,stmaryrd, graphicx}
\input{macros}
\begin{document}

\section*{Target Langage}

The target language (TL) is built around a parred down statically typed
object calculus. The calculus has non-recursive structural
substyping\footnote{\bf I am not sure that this is the right way to describe
  what we have -- check it is. JV} without inheritance.\footnote{Structural
  subtyping is needed for type systems that have a notion of
  ``consistency''. Inheritance does not add anything other than code reuse.}
The calculus does not have null values.\footnote{Null adds a source of error
  but otherwise should not be too interesting. We should mention what is the
  type of null.} Fields are accessed by automatically provided getter and
setter methods, respectively denoted \Get\x\f and \Set\x\f\e.\footnote{This
  is because we want an easy way to interpose on field access in wrappers.}
Fields appear in type signatures only through the presence of the getter and
setter methods. Method calls are denoted \Call\x\m\e.\footnote{The single
  argument limitation is purely to lighten the notation.} Following C\#
4.0~\cite{} the TL allows a dynamic type, denoted \any, and
dynamically-typed method invocation, denoted
\DynCall\x\m\e. Dynamically-typed method invocation treats arguments and
return value as \any. A new object is created with a class name and a
sequence of arguments in the order of definition of fields, denoted
\New\C{\b\e}.  Meta-variable \x ranges over argument names, \a over memory
locations, \f over field names, \m over method names, \C over class
names. The language has four different kinds of cast expressions: it has two
structural casts and two generative casts. The structural subtype cast,
denoted \SubCast\t\a, asserts that the object at location \a is of type
\t.  The structural shallow cast, denoted \ShaCast\t\a, asserts that the
object at location \a has methods with names matching those of \t. This does
not make any guarantee about the type of arguments.  The generative
behavioral cast, denoted \BehCast\t\a, will ensure that either \a behaves
as a \t or that it get stuck. The generative monotonic cast, denoted
\MonCast\t\a, is a behavioral cast that, in addition, imposes constraints
on fields.

\this is a distinguished variable name that denotes the current object.
\that is a distinguished field name that denotes the target of a wrapper.

\D is a meta-variable used to range over dynamically generated class names.

\begin{minipage}{7cm}\begin{tabular}{l@{~~}l@{}l@{}l@{}ll}
\e &::=  \x &\B \this &\B \that \\
   &\B \Get\e\f    &\B \Set\e\f\e    &\B \Call\e\m\e  &\B \DynCall\e\m\e \\
   &\B \New\C{\b\e} \\
   &\B \SubCast\t\e  &\B \ShaCast\t\e    &\B \BehCast\t\e &\B  \MonCast\t\e \\
   &\B \a \\ 
\M{M} &::= ~~\none ~~ \B \b{\t \Sub \t} 
% \M{N} &::= ~~\none ~~ \B \b\mt     
\end{tabular}\end{minipage}
~~
\begin{minipage}{6cm}\begin{tabular}{l@{~~}l@{}l}
\k &::= \Class \C {\b{\Ftype\f\t}}{\b\md} \\
\end{tabular}
\begin{tabular}{l@{~~}l@{}l@{}l}
\md &::= \Mdef\m\x\t\t\e \\
    &\B  \Mdef\f\x\t\t\e ~\B~ \Mdefz\f\t\e \\
\mt &::= \Mtype\m\t\t ~\B~  \Mtype\f\t\t  ~\B~ \Mtype\f{}\t  \\
%     &\B  $\mu$\ta.\mt \\
\E  &::= \Ftype\x\t  \B \none\\
\t  &::= ~ \any  \B   \Type{\b\mt} \\ 
% \B \ta \\
\s  &::= ~~\none ~~ \B ~~
    \Heap\s{\Bind\a{\obj\C{\b\a}}}
\end{tabular}\end{minipage}

The semantics of TL is defined by a small step operational semantics with
evaluation contexts.  The context are deterministic. Program error is
denoted by a stuck term. Meta-variable \k ranges over class definitions.
The semantics operate over an explicit class table, denoted \K, which is a
sequence of class definitions. A heap, denoted \s, maps memory locations to
objects. We use the notation \Heap\s{\Bind\a{\obj\C{\b\a}}} to denote the
heap \s extended by the binding of location \a to object \obj\C{\b\a}.  A
configuration \K\e\s evaluates in one step to a new configuration, denoted
\Reduce \K\e\s \Kp\ep\sp. Execution terminate if \ep\xspace is a value, \a,
or if there is no applicable reduction, in which case the program is
stuck.\footnote{Intuitively we would expect that the program can only get
  stuck at dynamic calls or at structural casts. But generative casts add
  some complexity to that statement.}

New object creation picks a fresh memory location \ap and binds it to the
newly created. Operations on fields are require a typed receiver, for
example in the expression \Get\this\f, \this is always of the type of the
current class. Field access through a getter method, works as follows. If
the receiver's class has a getter method, that method is evaluated,
otherwise the field corresponding the getter's name is updated. Methods are
segregated into typed method (methods whose argument is not \any) and
untyped method (methods whose argument is \any). The former can be called by
statically resolved method, the latter must be called by dynamically
resolved methods.

The auxiliary function \texttt{names} return the list of function names in a class
or type, functions that have \any as return values are prefixed with the
symbol \any. The auxiliary function \texttt{typeof} return the type of the object 
at the location \a in the heap \s. The auxiliary function \texttt{read} return
the location \ap pointing to the field \f of the object at location \a. The 
auxiliary function \texttt{write} return the heap \sp with the field \f of
the object at location \a updated to the location \ap.


\hrulefill

\begin{minipage}{8cm}
  \opdef{\Reduce \K\e\s \Kp\ep\sp}
        {\e\s evaluates to \ep\xspace in a step}\\[-1mm]
\begin{tabular}{@{}l@{}l@{~}l@{~}l}
\CondRule{E2}{ %% new C -> a
   \sp = \Heap\s{\Bind\ap{\obj\C{\b\a}}} $\wedge ~$ \ap fresh
}{ 
    \ReduceA \K{\New\C{\b\a}}\s \K\ap\sp
}
\CondRule{E5}{ %% a.f() -> e
    \Mdefz\f\t\e \In \classof\a\s\K
}{
   \ReduceA \K\s{\Get\a\f} \K{[\a/\this]\e}\s
}
\CondRule{E4}{ %% a.f(a) -> e
    \Mdef\f\x\t\t\e \In \classof\a\s\K
}{
   \ReduceA \K\s{\Set\a\f\ap} \K{[\a/\this~{\ap/\x}]\e}\s
}
\CondRule{E6}{  %% a.f() -> e
  \readfield \ap\s\a\f
}{
  \ReduceA \K{\Get\a\f}\s  \K\ap\s
}
\CondRule{E7}{ %% a.f(e) -> e
  \setfield \sp\s\a\f\ap
}{
  \ReduceA \K{\Set\a\f\ap}\s \K\ap\sp
}
\CondRule{E3}{ %% a.m(a) -> e
  \Mdef\m\x\t\tp\e \In \classof\a\s\K $\wedge~ \t \not= \any$
}{
 \ReduceA \K\s{\Call\a\m\ap} \K{[\a/\this~{\ap/\x}]\e}\s
}
\CondRule{E3}{ %% a@m(a) -> e
    \Mdef\m\x\any\any\e \In \classof\a\s\K
}{
  \ReduceA \K\s{\DynCall\a\m\ap} \K{[\a/\this~{\ap/\x}]\e}\s
}
\CondRule{E10}{  %% Subtypecast
%   \BasicType {\none} {\tp \Sub \t} $~\vee~$ \t $= \any$, \textit{s.t.} $\tp = \classof\a\s\K$
   \BasicType {\none} {\classof\a\s\K \Sub \t} $~\vee~$ \t $= \any$
}{ 
  \ReduceA \K{\SubCast \t\a}\s \K\a\s
}
\CondRule{E11}{
 \names{\classof\a\s\K}  $\supseteq$  \names\t
}{ 
  \ReduceA \K{\ShaCast \t\a}\s \K\a\s
}
\CondRule{E8}{
  \behcast \a\t\s\K  \Kp\ap\sp
}{ 
  \ReduceA  \K{\BehCast \t\a}\s \Kp\ap\sp
}
\CondRule{E9}{
  \moncast \a\t\s\K  \Kp\sp
}{ 
  \ReduceA \K{\MonCast\t\a}\s \Kp\a\sp
}
\CondRule{E1}{ %% e -> e'
  \Reduce \K\e\s \Kp\ep\sp
}{
 \ReduceA \K{\Ctx\e}\s \Kp{\Ctx\ep}\sp
}
\end{tabular}\end{minipage}

%%%%%%%%%%%%%%%%%%% CONTEXTS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
~\\[3mm]

\begin{minipage}{4cm}\begin{tabular}{l@{~~}l@{~}l}
\E &::= \Get\square\f     ~\B~
        \Set\square\f\e   ~\B~
        \Set\a\f\square   ~\B~  
        \Call\square\m\e   ~\B~
        \Call\a\m{\square} \\
   &\B~
        \DynCall\square\m\e   ~\B~
        \DynCall\a\m\square   ~\B~\\
   &\B~
       \SubCast\t\square  ~\B~
       \ShaCast\t\square  ~\B~
       \BehCast\t\square \\ &\B~
       \MonCast\t\square  ~\B~
       \New\C{\b \a\,\square\,\b\e}
\end{tabular}
\end{minipage}


Types are represented as a set of methods. 

\hrulefill

\opdef{\BasicType \MN {$~\t \Sub \tp$}}{\t is a subtype of \tp}
\begin{mathpar}
\IRule{SRef}{
}{
 \BasicType \MN {\t \Sub \t}
}

\IRule{STop}{
}{
 \BasicType \MN {\t \Sub {\Type{}}}
}

\IRule{SAssump}{
\t \Sub \tp \in \M{M} 
}{
 \BasicType \MN {\t \Sub \tp}
}

\IRule{SRec}{
 \BasicType {\MNargs\Type{\mt~\b{\mt_1}\,} \Sub  \Type{\mt'~\b{\mt_2}\,}} {\mt\Sub\mt'}\\
 \BasicType {\MNargs\Type{\mt~\b{\mt_1}\,} \Sub  \Type{\mt'~\b{\mt_2}\,}} {\Type{ \b{\mt_1}} \Sub \Type{\b{\mt_2}}}
}{
 \BasicType \MN {\Type{\mt~\b{\mt_1}\,} \Sub
  \Type{\mt'~\b{\mt_2}\,}} 
}

\IRule{SMeth}{
   \BasicType \MN {\t_2 \Sub \t_1} \\ \BasicType \MN {\t_1' \Sub \t_2'} 
}{
  \BasicType \MN {\Mtype\m{\t_1}{\t_1'} \Sub \Mtype\m{\t_2}{\t_2'}}
}

\IRule{SFd1}{
}{
 \BasicType \MN {\Mtype\f{}\t \Sub  \Mtype\f{}\t}
}

\IRule{SFd2}{
}{
 \BasicType \MN {\Mtype\f\t\t \Sub \Mtype\f\t\t}
}


% \IRule{SSearch}{
% }{
%  \BasicType {\M{M;\none}} {\t \Sub \tp}
% }

\end{mathpar}


Type checking is standard.

Field accessor rules W3 and W4 require a typed receiver, since \any does
not have any methods a receiver typed at \any will never typecheck.

Shallow casts, W9, do not change the type of the expression. We are casting
to the name of \t not to \t.  In practice that means that all expression
types in Transient will drift towards \any.

\hrulefill

\opdef{\EnvType\Es\e\t}{\e has type \t in environment \E against heap \s}
\begin{mathpar}
\IRule{W1}{
   \HasType \E\x\t
 }{
   \EnvType \Es\x\t
}

\IRule{W2}{
  \EnvType \Es\e\tp \\
 \BasicType{\M{\none}}{\tp \Sub \t}
 }{
   \EnvType \Es\e\t 
}   

\IRule{W3}{
  \EnvType \Es\e\t \\
  \Mtype \f{}\tp \inc \t  
}{
  \EnvType \Es{\Get\e\f}\tp
}    

\IRule{W4}{
  \EnvType \Es\e\t \\
  \Mtype \f\tp\tp \inc \t  \\
  \EnvType \Es\ep\tp
}{
  \EnvType \Es{\Set\e\f\ep}\tp
}    

\IRule{W5}{
  \EnvType \Es\e\t \\
  \Mtype \m\tp\tpp\inc \t  \\
  \EnvType \Es\ep\tp
}{
  \EnvType \Es{\Call\e\m\ep}\tpp
}    

\IRule{W6}{
  \EnvType \Es\e\any \\
  \EnvType \Es\ep\any
}{
  \EnvType \Es{\DynCall\e\m\ep}\any
}    

\IRule{W7}{
  \b{\EnvType \Es\e\t} \\ 
  \Class \C {\b{\Ftype\f\t}} {\b\md}
}{
  \EnvType \Es{\New\C{\b\e}}\C
}

\IRule{W8}{
  \EnvType \Es\e\tp
}{
  \EnvType \Es{\SubCast\t\e}\t
}

\IRule{W9}{
  \EnvType \Es\e\tp
}{
  \EnvType \Es{\ShaCast\t\e}\any  %%!!!  not \t !!!
}

\IRule{W10}{
  \EnvType \Es\e\tp
}{
  \EnvType \Es{\BehCast\t\e}\t
}

\IRule{W11}{
  \EnvType \Es\e\tp
}{
   \EnvType \Es{\MonCast\t\e}\t
}

\IRule{W12}{
  \s(\a) = \obj\C{\b{\a_1}}
}{
  \EnvType \Es\a\C
}
\end{mathpar}

\section{Generative Casts}

\subsection{Behavioral}



\hrulefill

\begin{mathpar}
\IRule{Cast-Wrap}{
  \D\;\mathit{fresh} \\
  \ap\;\mathit{fresh} \\
  \obj\C{\b{\a_1}} = \s(\a) \\
  \sp = \Heap \s{\Bind \ap{\obj\D{\a}} } \\
  \Kp = \K\;\wrapper{\C,\t,\D}
}{
  \behcast\a\t\s\K  \Kp\ap\sp
}
\end{mathpar}

What does the wrap function do? In english.

\[
\begin{array}{ccc}
& \t & \any \\
\t & \t \Rightarrow \t & \t \Rightarrow \any \\
\any & \any \Rightarrow \t & \any \Rightarrow \any \\
\end{array}
\]

\begin{itemize}
\item $\t \Rightarrow \t$
  Soundness: Need to make sure that all of the methods on the new type exist on the value, can be done statically.
  Completeness: All methods need to be persisted.

  Do a shallow cast, then put a wrapper on the old object.
\item $\t \Rightarrow \any$:

Soundness: Typed arguments are protected from unsafe use, and return types are casted to \any before exiting the typed context.

Completness: All methods in the source object need to be persisted.

Let \C be instance of \t. For every (typed) method \m in \C, generate an untyped method \m in \D which casts its arguments to \C.\m's types. If methods with untyped arguments exist, then they are called from the wrapper verbatim (though typed return values are casted to \any).

\item $\any \Rightarrow \t$:

Soundness: Methods which appear in the type are forced to behave like described. 

Completness: All methods in the source object need to be persisted.

Let \C be instance of \any. For every method \m in \t, generate a typed method that calls \C.\m casting the argument, then casts its return value. Methods \m in \C but not in \t are called directly in an untyped method.

\item $\any \Rightarrow \any$: identity.
\end{itemize}

\C may be a wrapper or a user class. It may thus have fields or has the
single \that field.


Assume \t = \any. 

Assume \C is an untyped class

Nothing more needs to be done.

Assume \C is a typed class.

For each method \m in \C, add a corresponding untyped method \m to \D that calls its corresponding \m in \C, casting the argument.

Field getter and setters are not changed because they are always invoked from a typed context.

Assume \t = \{\b{\mt}\} (typed) 

Assume \C is an untyped class.

For every typed method \m in \t,  if there is an untyped \m in \C, add a typed method \m to \D with a call to the underlying untyped method with behav casts on argument and return.

If there is an untyped \m in \C, but no typed \m in \t, then add an untyped passthrough method to \D.

For methods \m in \t, such that there is no \m in \C, put a method that will cause a stuck state, e.g. a dyn call to \m.

Assume \C is a typed class

For every method \m occuring both in \C and \t, add a call with behcast

For every method \m occuring only in \C, add it to \D, 

For every method \m occuring only in \t then should go boom


{\bf context switching to another task... the above is broken too}



\hrulefill


\begin{mathpar}
\IRule{UTWrap}{
   \Class\C{\b{\Mdef\m\x\t\tp\e}~\b{\Mdef{\m'_u}\x\t\tp\e}}
}{
  \wrapper{\C,\any,\D} = \Class \D{ \that:\C }
   {\b{\Mdef{\m_u}\x\any\any{\BehCast \any{\this.\that.\m(\b{\BehCast\t\x})}}} ~
    \b{\Mdef{\m'_u}\x\t\tp{\that.\m'_u(\b\x)}}}
}

\IRule{TWrap}{
	\Class\C{\b\fd}{\b\md} \\ 
}{
	\wrapper{\C\Rightarrow\{\b{\mt}\},\D} = \Class \D{\xt{s} : \C}{\tw{\b\md, \b\mt} ~ {\utw{\b\md, \b\mt}}}
}

\IRule{MTWrap}{
}{
  \tw{\Mdef{\m_\xt{u}}\x\any\any\e;\b{\md},\Mtype\m{\b{\tp1}}{\tp2};\b{\mt}} = \Mdef{\m}\x{\tp1}{\tp2}{\SubCast{\tp2}{\this.\xt{s}.{\m_\xt{u}(\b{\SubCast{\any}{\x}})}}} ~ \tw{\b{\md},\b{\mt}}
}

\IRule{MUTWrap}{
	\m \not\in\b{\mt}
}{
  \utw{\Mdef{\m_\xt{u}}\x\any\any\e;\b{\md},\b{\mt}} = \Mdef{\m_\xt{u}}\x\any\any\e ~ \utw{\b{\md},\b{\mt}}
}
\end{mathpar}


\subsection{Monotone}

The motivation behind the monotonic semantics is that we must ensure that every reference to an object is still valid up to \any types, and as a result, can only proceed by replacing \any types with concrete types, possibly recursively. We accomplish this by \emph{rewriting} the class that objects are associated with, enforcing the new type guarantee, while simultaneously checking that all of the extant field values match the type that they need to be.

In order to do any of this, however, the new type of the object is required. In Siek et al.'s original formalism, the new type was computed simultaneously as the object was being cast, but this creates problems when recursive objects are encountered. For example, consider the following scenario:

\begin{verbatim}
class C { x:any y:any m(y:any):any }
class D {}
class E { x:{x:{y:int}} y:any}

a = new C(new D(),2)
b = new C(a, 2)
a.x(b)
c = <E>a
\end{verbatim}

Here, when we go to update the value at \x, we then need to go into the type recursively, which points to a new instance of \C. Then, we assert a new type for \x in that new \C, which sends us back to the starting object, where we update the type of \xt{y} to be int, from \any. As a result, we cannot cast simply by examining the statically knowable types, but have to consider the heap structure when determining the final typing for any object.

We break this operation up into two steps:

\begin{itemize}
\item \emph{Type Determination}. We first determine a valid heap typing that both retains the monotonic property, while satisfying the new cast assertion. To do this, we recursively examine the heap structure, iterating until the heap is unchanged by the last type alteration.
\item \emph{Heap Update}. In the previous phase, we only determined a new valid typing for the heap. In the second step, we take this typing and apply it to the objects that exist in the heap.
\end{itemize}

By splitting out the two concerns, we avoid issues where the future state of the heap depends on values produced in the casting process and that do not exist yet. 
\hrulefill

\begin{mathpar}
\IRule{Cast-Mono1 (monotonic)}{
  \Heap \s{\Bind \a{\obj\C{\a_1 \dots \a_n}}} \\
  \C \not\equiv \meet \t\C \\
  \Kp = \K\;\spec{\Class\C{\b{\Ftype\f\t}}{\b\md}, \D, \meet \t\C} \\
  \sp = \Heap \s{\Bind \a{\obj\D{\b{\a_1}}}} \\
  \s_1 = \castfn{\a_1}{\t_1}{\sp}\Kp \\ \ldots \\
  \s_n = \castfn{\a_n}{\t_n}{\s_{n-1}}\Kp \\
}{
  \moncast \a\t\s\K   \Kp {\s_n}\\
}

\IRule{Cast-Mono2 (monotonic)}{
  \Heap \s{\Bind \a{\obj\C{\b{\a_1}}}} \\
  \C \equiv \meet \t\C
}{
  \moncast \a\t\s\K  \K\s
}
\end{mathpar}



\hrulefill

\opdef{
  $\meet{\t_1}{\t_2} \equiv \t$
}{
  The most specific type common to $\t_1$ and $\t_2$ is $\t$
}
\begin{mathpar}
\IRule{M1}{ }{\meet{\t}{\any} \equiv \t}

\IRule{M2}{ }{\meet{\any}{\t} \equiv \t}

\IRule{M3}{ }{\meet{\t}{\t} \equiv \t}

\IRule{M4}{
      \b{\meet{\t_3}{\t_1}  \equiv \t_5} \\
    \meet{\t_2}{\t_4} \equiv \t_6\\
    \meet{\Type{\b{\md_1}}}{\Type{\b{\md_2}}} \equiv \Type{\b{\md_3}} 
}{
  \meet{\Type{\Mtype\m{\t_1}{\t_2}~ \b{\md_1}}}{\Type{\Mtype\m{\t_3}{\t_4} ~ \b{\md_2}}} \equiv \Type{\Mtype\m{\b{\t_5}}{\t_6} ~ \b{\md_3}}
}
\end{mathpar}

\hrulefill

\begin{mathpar}
\IRule{Refine-Method}{
  \b{\meet{\t_1}{\t_1'} = \t_1''}\\
  {\meet{\t_2}{\t_2'} = \t_2''}
}{
  \spec{\m(\b{\x:\t_1}):\t_2 = \e,\m(\b{\t_1'}):\t_2'} = 
  (\m(\b{\x:\t_1''}):\t_2'' = \SubCast{\t_2''}{\e}), \\
  (\m_\xt{u}(\b{\x:\any}):\any = \SubCast{\any}{\this.{\m}(\SubCast{\t_1''}{\x})})
}

\IRule{Refine-Class}{
  \b{\meet{\t}{\t'} = \t''}
}{
  \spec{\Class{\C}{\b{\f : \t}}{\b{\md}}, \xt{D}, \{\b{\f():\t'},\b{\mt}\}} = \Class{\D}{\b{\f : \t''}}{\b{\spec{\f:\t,\t'}},\b{\spec{\md,\mt}}}
}
\end{mathpar}


\hrulefill

\begin{mathpar}
\IRule{Insert-Recv (eager cast)}{
  \GenCast \E{\e_1}{\e_3}{\t_1} \\
  \m(\b{x : \t_2}):\t_3 \in \t_1 \\
  \b{\AnaCast \E{\e_2}{\e_4}{\t_2}}
}{
  \inv \E{\Call{\e_1}\m{\b{\e_2}}} = \Call{\e_3}{\m}{\b{\e_4}}, \t_3
}

\IRule{Insert-Dyn}{
  \GenCast{\E}{\e_1}{\e_3}{\any} \\
  \AnaCast{\E}{\e_2}{\e_4}{\any}
}{
  \inv \E{\Call{\e_1}\m{\b{\e_2}}} =
  \Call{\SubCast{(\Type{\Mtype{\m_\xt{u}}{\b\any}\any}}{\e_3})}{\m_\xt{u}}{\b{\e_4}}, \any
}

\IRule{Insert-Check (lazy cast)}{
  \GenCast \E{\e_1}{\e_3}{\t_1} \\
  \m(\b{x : \t_2}):\t_3 \in \t_1 \\
  \b{\AnaCast \E{\e_2}{\e_4}{\t_2}}
}{
  \inv{\E}{\Call{\e_1}\m{\b{\e_2}}} =
  \SubCast{\t_1}{(\Call{(\SubCast{\Type{\Mtype{\m_\xt{u}}{\b\any}\any}}{\e_3})}{\m_\xt{u}}{\b{\SubCast \any{\e_4}}})}, \t_1
}
\end{mathpar}

\end{document}
\section{Addendum}

\input{figures/syncast}

\hrulefill

\input{figures/anacast}

\hrulefill

\input{figures/classtrans}

\hrulefill

\input{figures/conssub}

\hrulefill

\begin{mathpar}
\IRule{No-Cons}{ \t_1 \Sub \t_2 }{\MetaSub{\t_1}{\t_2}}

\IRule{Has-Cons}{\stcons{\t_1}{\t_2}}{\MetaSub{\t_1}{\t_2}}
\end{mathpar}

\end{document}
