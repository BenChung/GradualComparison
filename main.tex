\documentclass{llncs}
\usepackage{xspace,hyperref,times,amsmath,xspace,listings,url,subfigure}
\usepackage{graphicx,wrapfig,array,multirow}
\newcommand{\doi}[1]{doi:~\href{http://dx.doi.org/#1}{\Hurl{#1}}}
 \hypersetup{colorlinks=true,
   linkcolor=black,  citecolor=black,filecolor=magenta, urlcolor=black,
   pdftitle={R}, pdfauthor={Morandat Hill Osvald Vitek},
   pdfkeywords={Dynamic Languages, R, Reflection, Dynamic Analysis}}

\newcommand{\rl}[1]{{{\small{[{\sc #1}]}}}\xspace}
\newcommand{\lang}[1]{#1}% {\sf\scshape#1}\xspace}
\newcommand{\JAVA}{\lang{Java}\xspace}
\newcommand{\CommonLisp}{\lang{CommonLisp}\xspace}
\newcommand{\Java}{\lang{Java}\xspace}
\newcommand{\Scheme}{\lang{Scheme}\xspace}
\newcommand{\JavaScript}{\lang{Java\-Script}\xspace}
\newcommand{\Python}{\lang{Python}\xspace}
\newcommand{\Ruby}{\lang{Ruby}\xspace}
\newcommand{\Groovy}{\lang{Groovy}\xspace}

\renewcommand{\mapsto}{/}
\newcommand{\NOTE}[3][NOTE]{\marginpar{\textcolor{#2}{\textbf{#1:}\scriptsize\sf#3}}}
\newcommand{\TODO}[2][Unassigned]{\NOTE[#1]{black}{#2}}
\newcommand{\FM}[1]{\NOTE[FM]{blue}{#1}}
\newcommand{\BH}[1]{\NOTE[BH]{magenta}{#1}}
\newcommand{\JV}[1]{\NOTE[JV]{red}{#1}}
\newcommand{\PROOF}[1]{#1}

\newcommand{\NUM}[2][]{#2#1\xspace}
\newcommand{\PC}[1]{#1\%\xspace}

\def\NEEDNUMBER{XXX\xspace}
\def\UrlFont{\fontfamily{cmtt}\selectfont}
\lstset{tabsize=2,columns=flexible,%
	basicstyle=\small\ttfamily,keywordstyle=\bfseries,%
	commentstyle=\rmfamily\itshape,indexstyle=[1]\indexlst,%
	showstringspaces=false,%
	lineskip=1pt,
	showspaces=false,belowcaptionskip=\baselineskip,framexleftmargin=5mm,%
	texcl=true,xleftmargin=15pt, % make room for line numbers
	breaklines=true,
	breakatwhitespace=true,
	escapeinside={(*}{*)},
}
\newcommand{\code}[1]{\lstinline[keywordstyle=]!#1!\xspace}
\newcommand{\etal}{{\em et al.}}
\def\cross{\ding{55}}\def\naive{na\"\i ve }
\newcommand{\app}[1]{{\small\textsf{#1}}}
\newcommand{\IGNORE}[1]{}\newcommand{\hide}[1]{}
\newcommand{\Section}[1]{Sect.~\ref{#1}\xspace}
\newcommand{\Figure}[1]{Fig.~\ref{#1}\xspace}
\newcommand{\figref}[1]{Fig.~\ref{fig:#1}\xspace}
\newcommand{\tabref}[1]{Table~\ref{tab:#1}\xspace}
\mainmatter
%\titlerunning{\it Evaluating the Design of R}
%\authorrunning{\it Morandat et al.}

\title{The Design Space of Gradual Type Systems} \author{Ben and Jan}
\institute{\begin{tabular}{ccc}Northeasern University \end{tabular}}
\begin{document}\maketitle

\begin{abstract}
The popularity of dynamically typed languages has given rise to a cottage
industry of incremental type systems. These type systems allow developpers
to annotate their code with types and to feel better about the correctness
of their code.  The exact properties that these incremental type systems are
able to guarantee vary greatly from one language to another. This paper
compares some of the main design choices by embedding them into one common
core calculus representative of dynamic object-oriented languages such as
Python, TypeScript or Ruby.

\end{abstract} 

\section{Introduction}

The fundamental property a sound type system provides is the guarantee that an 
expression such as 
\begin{lstlisting}
    x = y.m(z);
\end{lstlisting}
will not ``go wrong''. If the expression passes the typechecker and the
variable \code{x} is declared to be of some type \code{T}, setting aside
issues related to null pointers and non-termination, the result of
\code{m()} will be of type \code{T}.  This is not the case in a dynamic
language where the receiver \code{y} may lack the requested method, or may
expect an argument of a different type, or may return a value that does not
belong to type \code{T}.

For any dynamic language, from the early days of Lisp to more recent times
with JavaScript, there have been attempts to add annotations to document
programmer expectations about the nature of values flowing through their
code.  The motivation for burdening the language with these extra
annotations have been either to provide hints for a just-in-time compiler or
to help programmers catch errors early.

\newcommand{\Opt}[1]{#1$^{?}$\xspace}
\newcommand{\Con}[1]{#1$^{!}$\xspace}
\newcommand{\Pro}[1]{#1$^{()}$\xspace}
\newcommand{\dyn}{$\star$}

In the last decade, the design space for these incremental annotations seems
to have stabilized around three alternatives.  A number of systems offer
\emph{optional types}, \Opt{T},
\cite{PluggableTypes,Bracha93,typescript13,oopsla09} which provide local
guarantees but do not prevent type errors at call boundaries. Other systems
rely on \emph{promised types}, \Pro{T}, these type annotations are
associated to the values that flow through the program and represent a
promise that the value will either behave as if it was of that type, or that
type error will be emitted~\cite{siek14,tf-popl08}.  Lastly, some systems
offer \emph{concrete types} which provide the traditional soundness
guarantees one would expect in a statically typed
language~\cite{thorn,stongscript,csharp}. In addition all dynamic languages
have the type dyn (\dyn) as the default type for all dynamically typed
variables.

The design space of incremental type system is an interesting one as there
are seemingly important trade-offs to be made in three different dimensions:
expressiveness, assurance and performance.  By expressiveness, we mean how
much of the legacy code base can be typed (and at what cost in terms of
changes to the original programs).  By assurance, we mean what kinds of
guarantees does the type system give to programmers. At its weakest, the
type system can be little more than a machine-checked documentation, and at
its strongest it can be equivalent to a sound statically typed language.
Performance here refers to the additional runtime overheads that are caused
by the extra checks that the language must perform to provide the
aforementioned guarantees.

\newcommand{\name}{{\sf Gool}\xspace}

This paper elucidates the difference between different designs by setting
them all in a common context. We have picked a simple class based
object-oriented language, representative of the likes of Python, Ruby,
TypeScript. Our core calculus, named \name for Gradual Object-oriented
Language, is stateful, as mutation introduces additional challenges. \name
is agnostic as to the nature of the subtyping relation (structural or
nominal) as this seems to be an orthogonal design choice.

\section{Related Work}

\section{Core Calculus}

\section{Conclusion}

\bibliographystyle{plain}

\bibliography{bib/compactdoi}

\end{document}


